<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[synchronized详解]]></title>
    <url>%2F2020%2F12%2F01%2Fsynchronize%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[synchronizedsynchronized关键字解决的是 多个线程之间访问资源的同步性 synchronized底层原理 synchronized修饰代码块 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件 执⾏ javap -c -s -v -l SynchronizedDemo.class 1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。 相应的在执⾏ monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。 synchronized修饰方法 synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，JVM 通过该 ACC_SYNCHRONIZED 访问 标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。 最主要的三种使用方式 修饰实例方法 对当前实例对象加锁 修饰静态方法 对类加载，作用于所有对象实例 修饰代码块 指定加锁对象，给给定对象加锁 jdk1.6的优化（锁升级） 偏向锁线程访问同步代码块时检查此时是不是偏向锁 是，检查对象头mark word中的记录是不是当前线程ID，是的话获得偏向锁，不是的话通过CAS尝试替换线程ID（贴标签） 轻量级锁出现线程竞争的情况下，偏向锁会升级成轻量级锁 原持有偏向锁的线程会在栈中分配锁记录，把对象的mark word复制到锁记录中，对象头的mark word中的锁记录指针指向当前线程锁记录，竞争线程使用CAS将锁记录指针指向本线程锁记录（线程没阻塞，CAS中，但会消耗cpu资源） 重量级锁CAS多次后升级为重量级锁，mark word中的指针指向重量级锁 参考文档 http://dhbin.cn/index.php/archives/44/]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile详解]]></title>
    <url>%2F2020%2F12%2F01%2Fvolatile%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[volatile原理 volatile关键字主要⽤于解决变量在多个线程之间的可⻅性 当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量值刷新到主内存 当读一个volatile变量时，JMM会把线程队友的本地内存置为无效，再从主内存中读取该共享变量 编译过程java代码编译后会变成java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在cpu上执行，所以java的并发机制依赖于JVM的实现和CPU指令 实现原理java代码 1instance=new Singleton() 转化成汇编代码 10x01a3deld:movb ...lock add1 .. volatile修饰的共享变量在进行写操作时会多出一个lock前缀指令，这个指令有2个作用 将当前处理器缓存行的数据写回到系统内存 写回操作会使其他cpu缓存了该内存地址的数据无效 为了提高处理速度，内存不会直接和cpu进行通信，而是先将系统内存读到内部缓存（L1,L2）,但操作完不知道何时写回内存； 用volatile修饰的变量进行写操作，JVM会向处理器发送一条Lock前缀指令，进行缓存锁定：如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号（总线锁），而是锁住这块内存区域的缓存并写回内存（缓存所），并使用缓存一致性来确保修改的原子性，缓存一致性：会阻止同时修改由两个以上处理器缓存的内存区域数据 使用MESI控制协议维护内部缓存和其他处理器缓存的一致性，通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时。强行进行缓存行填 处理器如何实现原子操作总线锁 使用处理器提供的LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求会被阻塞住，那么该处理器就能独占共享内存 缓存锁见上 CPU 有多级缓存，导致读的数据过期 线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 L3 缓存、L2 缓存、L1 缓存，也就是多级缓存引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。 假设 core 1 修改了变量 a 的值，并写入到了 core 1 的 L1 缓存里，但是还没来得及继续往下同步，由于 core 1 有它自己的的 L1 缓存，core 4 是无法直接读取 core 1 的 L1 缓存的值的，那么此时对于 core 4 而言，变量 a 的值就不是 core 1 修改后的最新的值，core 4 读取到的值可能是一个过期的值，从而引起多线程时可见性问题的发生。 JMM内存模型JMM 定义了一套读写数据的规范，屏蔽了 L1 缓存、L2 缓存、L3 缓存，也就是多层缓存的这些底层细节。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。 线程之间的共享变量存储在主内存中，每个线程都有自己私有的本地内存，本地内存存储了该线程读/写共享变量的副本 volatile两大功能 保证可见性 禁止重排序 可见性依赖于happens-before原则 对一个 volatile 变量的写操作 happen-before 后面对该变量的读操作 ，happens-before原则是JMM呈现给程序员的视图，具体实现是通过禁止指令重排序实现的 禁止重排序则涉及重排序和内存屏障 重排序：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序 禁止指令重排序是通过内存屏障实现的，JMM把内存屏障分为4类 屏障类型 指令示例 说明 LoadLoad Barriers Load1;LoadLoad;Load2 确保Load1数据的装载先于Load2及后序装载指令 StoreStore Barriers Store1;StoreStore;Store2 确保Store1数据对其他处理器可见（刷新到内存）先于Store2及后续存储指令 LoadStore Barriers Load1;LoadStore;Store2 确保Load1数据的装在先于Store2及后续存储指令 StoreLoad Barriers Store1;StoreLoad;Load2 确保Store1对其他处理器可见（刷新到主存）先于Load2及后续装在指令 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障类禁止特定类型的处理器重排序 JMM保守策略下的内存屏障插入策略 在每个volatile写操作前插入SS屏障 在每个volatile写操作会插入SL屏障 在每个volatile读操作后插入LL屏障 在每个volatile读操作后插入LS屏障 实际情况编译器可以省略不必要的屏障]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized 和 ReentrantLock]]></title>
    <url>%2F2020%2F11%2F22%2Fsynchronized-%E5%92%8C-ReentrantLock%2F</url>
    <content type="text"><![CDATA[如何实现synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。 在 Java 中每个对象都隐式包含一个 monitor（监视器）对象，加锁的过程其实就是竞争 monitor 的过程，当线程进入字节码 monitorenter 指令之后，线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。 ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。 区别synchronized 和 ReentrantLock 都提供了锁的功能，具备互斥性和不可见性。在 JDK 1.5 中 synchronized 的性能远远低于 ReentrantLock，但在 JDK 1.6 之后 synchronized 的性能略低于 ReentrantLock，它的区别如下： synchronized 是 JVM 隐式实现的，而 ReentrantLock 是 Java 语言提供的 API； ReentrantLock 可设置为公平锁，而 synchronized 却不行； ReentrantLock 只能修饰代码块，而 synchronized 可以用于修饰方法、修饰代码块等； ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁； ReentrantLock 可以知道是否成功获得了锁，而 synchronized 却不行。 ReentrantLock 的具体实现细节是什么？ReentrantLock 源码分析无参的构造函数创建了一个非公平锁，用户也可以根据第二个构造函数，设置一个 boolean 类型的值，来决定是否使用公平锁来实现线程的调度 123456public ReentrantLock() &#123; sync = new NonfairSync(); // 非公平锁&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 公平锁 VS 非公平锁公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。 ReentrantLock 是通过 lock() 来获取锁，并通过 unlock() 释放锁，使用代码如下 123456789Lock lock = new ReentrantLock();try &#123; // 加锁 lock.lock(); //......业务处理&#125; finally &#123; // 释放锁 lock.unlock();&#125; ReentrantLock 中的 lock() 是通过 sync.lock() 实现的，但 Sync 类中的 lock() 是一个抽象方法，需要子类 NonfairSync 或 FairSync 去实现，NonfairSync 中的 lock() 源码如下 1234567final void lock() &#123; if (compareAndSetState(0, 1)) // 将当前线程设置为此锁的持有者 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 非公平锁比公平锁只是多了一行 compareAndSetState 方法，该方法是尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过 acquire 方法去排队 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 公平锁比非公平锁多了一行代码 !hasQueuedPredecessors() if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //尝试获取锁 setExclusiveOwnerThread(current); // 获取成功，标记被抢占 return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); // set state=state+1 return true; &#125; return false;&#125; 对于此方法来说，公平锁比非公平锁只多一行代码 !hasQueuedPredecessors()，它用来查看队列中是否有比它等待时间更久的线程，如果没有，就尝试一下是否能获取到锁，如果获取成功，则标记为已经被占用。 如果获取锁失败，则调用 addWaiter 方法把线程包装成 Node 对象，同时放入到队列中，但 addWaiter 方法并不会尝试获取锁，acquireQueued 方法才会尝试获取锁，如果获取失败，则此节点会被挂起 12345678910111213141516171819202122232425262728/** * 队列中的线程尝试获取锁，失败则会被挂起 */final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; // 获取锁是否成功的状态标识 try &#123; boolean interrupted = false; // 线程是否被中断 for (;;) &#123; // 获取前一个节点（前驱节点） final Node p = node.predecessor(); // 当前节点为头节点的下一个节点时，有权尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); // 获取成功，将当前节点设置为 head 节点 p.next = null; // 原 head 节点出队，等待被 GC failed = false; // 获取成功 return interrupted; &#125; // 判断获取锁失败后是否可以挂起 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 线程若被中断，返回 true interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 该方法会使用 for(;;) 无限循环的方式来尝试获取锁，若获取失败，则调用 shouldParkAfterFailedAcquire 方法，尝试挂起当前线程 12345678910111213141516171819202122/** * 判断线程是否可以被挂起 */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 获得前驱节点的状态 int ws = pred.waitStatus; // 前驱节点的状态为 SIGNAL，当前线程可以被挂起（阻塞） if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; do &#123; // 若前驱节点状态为 CANCELLED，那就一直往前找，直到找到一个正常等待的状态为止 node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); // 并将当前节点排在它后边 pred.next = node; &#125; else &#123; // 把前驱节点的状态修改为 SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; CANCELLED：当线程等待超时或者被中断，则取消等待，设等待状态为-1，进入取消状态则不再变化 SIGNAL：后继节点处于等待状态，当前节点被取消或中断时会通知后继节点，使后继节点的线程得以运行 CONDITION：当前节点处于等待队列，节点线程等待在Condition上，当其他线程对condition执行signall方法时，等待队列转移到同步队列，加入到对同步状态的获取 PROPAGATE：与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态 线程入列被挂起的前提条件是，前驱节点的状态为 SIGNAL，SIGNAL 状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点。所以在上面这段代码中，会先判断前驱节点的状态，如果为 SIGNAL，则当前线程可以被挂起并返回 true；如果前驱节点的状态 &gt;0，则表示前驱节点取消了，这时候需要一直往前找，直到找到最近一个正常等待的前驱节点，然后把它作为自己的前驱节点；如果前驱节点正常（未取消），则修改前驱节点状态为 SIGNAL 到这里整个加锁的流程就已经走完了，最后的情况是，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放锁之后，才会去唤醒其他的线程去获取锁资源 总结 一开始lock方法中compareAndSetState方法尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁 否则，查看队列中是否有比它等待时间更久的线程，如果没有，就尝试一下是否能获取到锁，如果获取成功，则标记为已经被占用。如果获取锁失败，则调用 addWaiter 方法把线程包装成 Node 对象，同时放入到队列中 在队列中通过一个for无限循环，获取前驱结点，如果前驱是head结点，则尝试获取锁，成功则将当前结点设置为head；失败则判断是否可以挂起，如果前驱结点是通知状态，可以挂起，如果是取消状态，将当前结点连接到最接近的非取消前驱，如果是其他状态，就把前驱设置为通知状态。 用过 CountDownLatch 么？什么场景下用的？ 有没有可以改进的地方呢？CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕 场景 CompletableFuture 的 runAsync 方法，这个方法会异步的去执行任务，每个任务返回一个 CompletableFuture 对象， CompletableFuture 的 allOf 方法的作用是把多个 task 汇总，然后可以根据需要去获取到传入参数的这些 task 的返回结果，或者等待它们都执行完毕等。 场景 最开始的时候是通过 AttributeMap 绑定到Channel上实现的， 每次都要调用 channel.closeFuture().sync(); 阻塞来手动等待请求返回 ， 使用 CompletableFuture 包装返回结果]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存管理]]></title>
    <url>%2F2020%2F11%2F20%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[分页存储管理将内存分为一个个大小相等的分区，每个分区就是一个页框；将用户进程的空间也分为与页框大小相等的一个个区域，称为页面，页号从0开始 逻辑地址到物理地址的映射 根据逻辑地址算出对应的页号 得到该页号对应页面在内存的起始地址 根据逻辑地址算出页面内偏移量 物理地址=页面始址+偏移量 基本地址转换基本地址转换可以将逻辑地址根据页表转换成物理地址：通常系统会设置一个页表寄存器，存放页表的起始地址和页表长度；进程未执行时，页表的起始地址和页表长度保存在进程的PCB中，进程被调度，将它们放到页表寄存器中 转换过程 根据逻辑地址计算出页号、页内偏移量 判断页号是否越界（页号&gt;=页表长度即越界） 查询页表，根据页号找到对应的内存块号 块号加上偏移量就是最后的物理地址 快表快表又称联想寄存器，是一种访问速度比内存快很多的高速缓存寄存器，用来存放当前访问的若干页表项 具有快表的地址变换 根据逻辑地址计算出页号、页内偏移量 判断页号是否越界（页号&gt;=页表长度即越界 查询快表，若快表命中，直接拿到内存块号，不需要再访问内存了 没命中，和上面一样 虚拟内存程序装入时，可以将程序中很快用到的部分装入内存，暂时用不到的部分放在外存 程序执行过程中，当访问的信息不在内存中时，操作系统将所需信息从外存加载到内存（缺页中断） 当内存空间不够时，操作系统将暂时不用的信息移除内存 在操作系统管理下，用户似乎有一个比实际大得多的内存，这就是虚拟内存 缺页中断在请求分页系统中，当要访问的页面不在内存时，就产生一个缺页中断，然后由操作系统缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后将其唤醒，放入就绪队列。 页面置换算法最佳置换 每次淘汰的页面是最长时间内不再被访问的页面 先进先出 每次淘汰的页面是最先进入内存的页面 最近最久未使用 每次淘汰的页面是最近最久未使用的页面]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B+树,索引,主键]]></title>
    <url>%2F2020%2F11%2F19%2Fmysql%E4%B8%8EB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[局部性原理与磁盘预读磁盘本身存取就比主存慢很多，为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页。 这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使 程序运行期间所需要的数据通常比较集中 mysql使用B+树的优点 索引往往以索引文件的形式存储的磁盘上，这样的话，索引查找过程中就要产生磁盘I/O ；磁盘往往不是严格按需读取，而是每次都会预读 而B+树将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入； B/B+树一次最多需要h-1次I/O，B/B+树相比于红黑树，h要小得多（对于一个出度为d的B树，h上限为logd N+1/2）,一般出度会很大，因此h非常小（比红黑树2好） B+树内节点去掉了data域，一个页内存放更多的key，一次读入的关键字就更多，相应I/O也更少 mysql的B+树在原来的基础上增加了顺序访问指针，每个叶子节点指向相邻叶子结点，这样增加了区间访问的性能，例如访问key从18-49的数据，只需从18开始，沿着结点和顺序指针找就行了，提高了区间查找效率（比B树好） MyISAM索引实现MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复 MyISAM索引文件和数据文件是分离的，这样的索引方式称为非聚集索引 InnoDB索引实现InnoDB的数据文件本身就是索引文件，表数据文件本身就是按B+Tree组织的一个索引结构，即主索引，这棵树的叶节点data域保存了完整的数据记录 InnoDB的辅助索引data域存储相应记录主键的值而不是地址 对于InnoDB的索引，叶节点包含了完整的数据记录。这种索引叫做聚集索引 索引是不是越多越好？索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引 表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引 索引的选择性较低。所谓索引的选择性，是指不重复的索引值与表记录的比值 ， 选择性越高的索引价值越大 InnoDB的主键选择在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键 InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求 各条数据记录按主键顺序存放 ； 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置 ，此时MySQL不得不为了将新记录插到合适位置而移动数据， 频繁的移动、分页操作造成了大量的碎片 最左前缀原则查询从索引的最左前列开始并且不跳过索引中的列， 遇到范围查询，范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引 参考文档 http://blog.codinglabs.org/articles/theory-of-mysql-index.html https://www.cnblogs.com/shuxiaosheng/p/12976922.html]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2020%2F11%2F15%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal的两种典型使用场景 ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本（也就不用考虑线程共享，这里是独享），这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全 ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景,避免了传参，类似于全局变量的概念 典型场景1（SimpleDateFormat进化过程-详细看参考链接）1.2 个线程都要用到 SimpleDateFormat 123456789101112131415161718public class ThreadLocalDemo01 &#123; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; String date = new ThreadLocalDemo01().date(1); System.out.println(date); &#125;).start(); Thread.sleep(100); new Thread(() -&gt; &#123; String date = new ThreadLocalDemo01().date(2); System.out.println(date); &#125;).start(); &#125; public String date(int seconds) &#123; Date date = new Date(1000 * seconds); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("mm:ss"); return simpleDateFormat.format(date); &#125;&#125; 2.10 个线程都要用到 SimpleDateFormat （使用for循环） 3.需求变成了 1000 个线程都要用到 SimpleDateFormat（使用线程池复用，但还得创建1000个SimpleDateFormat对象） 4.所有的线程都共用一个 simpleDateFormat 对象（simpleDateFormat 对象变成 static 静态变量） 5.线程不安全，出现了并发安全问题（多线程出现并发，加锁或者ThreadLocal） 6.加锁（synchronized ，这样线程得等待，效率不高） 7.使用 ThreadLocal（让每个线程都拥有一个自己的 simpleDateFormat 对象） 典型场景2每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样） 例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。 在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦 想到可以用HashMap保存user，但是线程不安全 使用ThreadLocal 拿到只属于自己的独享对象 ThreadLocal 是用来解决共享资源的多线程访问的问题吗不是，ThreadLocal 并不是用来解决共享资源问题的。虽然 ThreadLocal 确实可以用于解决多线程情况下的线程安全问题，但其资源并不是共享的，而是每个线程独享的 具体而言，它可以在 initialValue 中 new 出自己线程独享的资源，而多个线程之间，它们所访问的对象本身是不共享的，自然就不存在任何并发问题 ThreadLocal 和 synchronized 是什么关系面试官可能会问：你既然说 ThreadLocal 和 synchronized 它们两个都能解决线程安全问题，那么 ThreadLocal 和 synchronized 是什么关系呢？ ThreadLocal 是通过让每个线程独享自己的副本，避免了资源的竞争。 synchronized 主要用于临界资源的分配，在同一时刻限制最多只有一个线程能访问该资源 synchronized 的效率会更低一些，但是花费的内存也更少，ThreadLocal还可以用来避免传参 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？ 可以看到： 每个 Thread 对象中都持有一个 ThreadLocalMap 类型的成员变量 而这个 ThreadLocalMap 自身类似于是一个 Map，里面会有一个个 key value 形式的键值对 key 就是 ThreadLocal 的引用，value就是ThreadLocal 存储的内容 源码 1234567891011121314151617181920212223242526272829303132333435public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; 内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？内存泄漏内存泄漏指的是，当某一个对象不再有用的时候，占用的内存却不能被回收，这就叫作内存泄漏 Key 的泄漏之前讲了ThreadLocal存储的过程，如果我们执行ThreadLocal instance = null 操作，想清理掉这个 ThreadLocal 实例，但是呢entry里的key又强引用了ThreadLocal，引用链依然存在，可达性分析会发现实例依然可达没无法回收，造成内存泄漏 所以 ThreadLocalMap 中的 Entry 继承了 WeakReference 弱引用 12345678static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 此时的k就是弱引用，一旦gc就被回收 Value 的泄漏 ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。所以，如果 ThreadLocal 没有被外部强引⽤的情况下，在垃圾回收的时候，key 会被清理掉，⽽ value 不会被 清理掉。这样⼀来， ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话， value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。ThreadLocalMap实现中已经考虑了这种 情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null 的记录。使⽤完 ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法 如何避免内存泄露使用完了 ThreadLocal 之后，我们应该手动去调用它的 remove 方法]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深克隆与浅克隆]]></title>
    <url>%2F2020%2F11%2F15%2F%E6%B7%B1%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B5%85%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[深克隆，浅克隆概念浅克隆 把原型对象中成员变量为值类型的属性都复制给克隆对象，把原型对象中成员变量为引用类型的引用地址也复制给克隆对象；简单来说就是浅克隆只会复制原型对象，但不会复制它所引用的对象 深克隆 原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，都复制一份给克隆对象 java实现克隆在 Java 语言中要实现克隆则需要实现 Cloneable 接口，并重写 Object 类中的 clone() 方法 12345678910111213141516171819202122232425262728293031323334353637public class CloneExample &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; // 创建被赋值对象 People p1 = new People(); p1.setId(1); p1.setName(&quot;Java&quot;); // 克隆 p1 对象 People p2 = (People) p1.clone(); // 打印名称 System.out.println(&quot;p2:&quot; + p2.getName()); &#125; static class People implements Cloneable &#123; // 属性 private Integer id; private String name; /** * 重写 clone 方法 * @throws CloneNotSupportedException */ @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; Arrays.copyOf() 是深克隆还是浅克隆？123456789People[] o1 = &#123;new People(1, &quot;Java&quot;)&#125;;People[] o2 = Arrays.copyOf(o1, o1.length);// 修改原型对象的第一个元素的值o1[0].setName(&quot;Jdk&quot;);System.out.println(&quot;o1:&quot; + o1[0].getName());System.out.println(&quot;o2:&quot; + o2[0].getName());o1:Jdko2:Jdk 所以Arrays.copyOf() 是浅克隆，修改了原型对象的第一个属性，克隆对象也被修改了 深克隆实现方式（这里只介绍两种） 所有对象都实现克隆方法 通过构造方法实现深克隆 1234567891011121314public class People &#123; private Integer id; private String name; private Address address; // 包含 Address 引用对象 // 忽略构造方法、set、get 方法&#125;/** * 地址类 */public class Address &#123; private Integer id; private String city; // 忽略构造方法、set、get 方法&#125; 所有对象都实现克隆方法这种方式我们需要修改 People 和 Address 类，让它们都实现 Cloneable 的接口，让所有的引用对象都实现克隆，从而实现 People 类的深克隆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CloneExample1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Address address = new Address(&quot;南京&quot;); Person person1 = new Person(&quot;小李&quot;,address); Person clone = person1.clone(); person1.getAddress().setCity(&quot;北京&quot;); System.out.println(clone.getAddress().getCity()); &#125; static class Person implements Cloneable&#123; private String name; private Address address; public Person(String name, Address address) &#123; this.name = name; this.address = address; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public Person clone( ) throws CloneNotSupportedException &#123; Person clonePerson = (Person) super.clone(); clonePerson.setAddress(this.address.clone()); return clonePerson; &#125; &#125; static class Address implements Cloneable&#123; private String city; public Address(String city) &#123; this.city = city; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public Address clone() throws CloneNotSupportedException &#123; return ((Address) super.clone()); &#125; &#125;&#125;输出：南京 通过构造方法实现深克隆如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新 new 一个对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CloneExample2 &#123; public static void main(String[] args) &#123; Address address = new Address("南京"); Person person1 = new Person("小李", address); Person person2=new Person(person1.getName(),new Address(person1.getAddress().getCity())); person1.getAddress().setCity("北京"); System.out.println(person2.getAddress().getCity()); &#125; static class Person &#123; private String name; private Address address; public Person(String name, Address address) &#123; this.name = name; this.address = address; &#125; public String getName() &#123; return name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; &#125; static class Address implements Cloneable &#123; private String city; public Address(String city) &#123; this.city = city; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis持久化]]></title>
    <url>%2F2020%2F10%2F27%2Fredis%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[redis持久化有2种方式，RDB和AOFRDB概念redis会创建一个子进程来进行持久化，先将数据写入到一个临时文件中，写入完成后再替换上次持久化好的文件，整个过程中主进程是不进行IO操作的。 触发机制Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息： save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照 save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照 save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照 RDB优缺点优点 相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速 RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可 缺点 一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据 AOF概念以日志的形式记录下每个写操作，将redis的每个操作记录下来，只许追加文件不可以改写文件，redis启动的时候读取该文件重新构建数据（将所有指令从前往后执行一次） AOF默认不开启，需要手动配置，将appendonly改为yes即可 触发机制123appendfsync always 每次都同步appendfsync everysec 每秒执行一次，可能会丢失一秒数据appendfsync no 优缺点优点 AOF可以更好的保护数据不丢失，最多丢失1秒钟的数据 OF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据 缺点 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大 AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的 AOF和RDB怎么选 不要仅仅使用RDB，因为那样会导致你丢失很多数据 也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug 综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强软弱虚四种引用]]></title>
    <url>%2F2020%2F10%2F12%2F%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用一般正常的引用都是强引用 有如下特点 直接指向对象 强引用指向的对象在任何时候都不会被回收 因而也可能出现内存泄露 123456public static void main(String[] args) throws Exception &#123; M m=new M(); m=null; System.gc(); System.in.read();&#125; 软引用软引用的对象也不会很快被回收，jvm会判断堆的使用情况来判断是否回收，一旦达到堆的使用率的阈值，进行回收 123456789101112131415ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();Object obj = new Object();SoftReference softRef = new SoftReference&lt;Object&gt;(obj,queue);//删除强引用obj = null;//调用gcSystem.gc();System.out.println("gc之后的值: " + softRef.get()); // 对象依然存在//申请较大内存使内存空间使用率达到阈值，强迫gcbyte[] bytes = new byte[100 * 1024 * 1024];//如果obj被回收，则软引用会进入引用队列Reference&lt;?&gt; reference = queue.remove();if (reference != null)&#123; System.out.println("对象已被回收: "+ reference.get()); // 对象为null&#125; 软引用也可以和一个引用队列联合使用，如果软引用中的对象（obj）被回收，那么软引用会被 JVM 加入关联的引用队列中 引用队列 Queue的意义在于我们在外部可以对queue中的引用进行监控，当引用中的对象被回收后，我们可以对引用对象本身继续做一些清理操作，因为我们引用对象（softRef）也占有一定的资源 用途 可以处理缓存，因为垃圾收集器只在内存需要时才会收集软可及对象，软引用对于垃圾收集器是这样一种方式，即“内存不太紧张，保留该对象，内存不够了采取收集处理该对象”； 这样可用软引用来管理缓冲区，只要不是特别需要内存，缓存就保留，不够了再去收集处理 弱引用弱引用中的对象具有很短的声明周期，因为在系统GC时，只要发现弱引用，不管堆空间是否足够，都会将对象进行回收 1234WeakReference&lt;M&gt;m=new WeakReference&lt;&gt;(new M());System.out.println(m.get());System.gc();System.out.println(m.get()); 用途 软引用也可处理缓存，WeakHashMap中当key只有弱引用时，GC发现后会自动清理键和值，作为简单的缓存表解决方案 ThreadLocal ThreadLocal.ThreadLocalMap.Entry 继承了弱引用，key为当前线程实例，和WeakHashMap基本相同 ThreadLocal部分源码分析，和弱引用有关 ThreadLocal的set方法存储，实际上是通过Thread里的ThreadLocalMap来存储key-value，key为ThreadLocal，value为值 ThreadLocalMap又是怎么set的呢，new Entry(key, value)，也就是通过新建entry键值对来完成set的 那来看下Entry的类型， static class Entry extends WeakReference，原来是继承了弱引用类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; 虚引用虚引用 就是 形同虚设 ，它并不能决定 对象的生命周期。任何时候这个只有虚引用的对象都有可能被回收。因此，虚引用主要用来跟踪对象的回收，清理被销毁对象的相关资源]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http与https]]></title>
    <url>%2F2020%2F10%2F12%2Fhttp%E4%B8%8Ehttps%2F</url>
    <content type="text"><![CDATA[HTTP协议是无连接的，无状态的且透明传输 HTTPS使用SSL套接字对传输的数据进行加密。在发送方，SSL从SSL套接字接收应用层的数据，对数据进行加密，然后把加密的数据送往TCP套接字；在接收方，SSL从TCP套接字读取数据，解密后，通过SSL套接字把数据交给应用层 SSL提供的安全服务可归纳为三种： SSL服务器鉴别，允许用户证实服务器身份 SSL客户鉴别，允许服务器鉴别客户身份 加密的SSL会话 假设服务器B为顾客A提供购物服务。当顾客点击链接建立TCP连接后，先进行浏览器和服务器的握手协议，然后 协商加密算法。1.浏览器向服务器发送浏览器的SSL版本号以及可选的加密算法。2.B从中选定自己所支持的算法，并告知A 服务器鉴别。3.服务器B向A发送包括自己RSA密钥的数字证书。4.浏览器使用该证书的认证机构CA公开发布的RSA进性验证 会话密钥计算。浏览器A随机产生一个秘密数。5.用B的RSA公钥进性加密发送给B。6.双方根据协商的算法产生共享的对称会话密钥 安全数据传输]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程基础]]></title>
    <url>%2F2020%2F10%2F10%2F%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[创建线程的方式 继承Thread，重写run方法，调用start启动 123456789101112public class test02 extends Thread &#123; @Override public void run() &#123; for (int i=0;i&lt;20;i++)&#123; //重写run方法 System.out.println(&quot;test02:&quot;+i); &#125; &#125;&#125;new test02().start(); 实现Runnable接口，重写run方法，将实现接口的类丢入thread，调用start启动 12345678public class test01 implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;test01启动&quot;); &#125;&#125;new Thread(new test01()).start(); 线程池 Executors线程池工厂类，用于创建线程；ExecutorService真正的线程池接口 1234567ExecutorService executorService= Executors.newFixedThreadPool(10);executorService.execute(new test01());executorService.execute(new test01());executorService.execute(new test01());executorService.execute(new test01());//关闭连接executorService.shutdown(); 线程状态 线程方法 线程礼让yield 礼让不一定成功，取决于cpu调度 12345678910111213public class test03 implements Runnable &#123; @Override public void run() &#123; System.out.println("test03启动"); Thread.yield(); System.out.println("test03结束"); &#125;&#125;test03启动test03启动test03结束test03结束 线程强制执行join 12345678910Thread vip=new Thread(new test04(),"c"); vip.start(); for(int j=0;j&lt;100;j++)&#123; //从main线程j=1就插入 if(j==1)&#123; vip.join(); &#125; System.out.println("main线程执行中:"+j); &#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS解析]]></title>
    <url>%2F2020%2F09%2F22%2FDNS%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[域名服务器类型 根域名服务器：所有域名服务器都知道所有顶级域名服务器的域名和IP地址 顶级域名服务器：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名 权限域名服务器：负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当去找哪一个权限服务器 本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求就会发送到本地域名服务器。每一个互联网服务提供者ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器。当所要查询的主机也属于同一个本地ISP时，该本地域名服务器就能立刻将查询的主机名转换成IP地址，而不需要再去询问其他域名服务器 域名解析过程主机向本地域名服务器主机向本地域名服务器一般采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道要被查询的域名的IP地址，那么本地域名服务器会以DNS客户的身份向其他根域名服务器继续发出查询报文 本地域名服务器向根域名服务器本地域名服务器向根域名服务器的查询一般是迭代查询。迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出IP，要么告诉本地域名服务器你下一步应该向哪个域名服务器查询。因为根域名服务器保存着顶级域名服务器的域名和IP地址，所以一般会让本地域名服务器去查询顶级域名服务器，还没查到的话顶级域名服务器再去权限域名服务器 解析实例假定m.xyz.com的主机想知道另一台主机y.abc.com的IP地址 主机m.xyz.com先向其本地域名服务器dns.xyz.com进行递归查询 本地域名服务器采用迭代查询。它先向一个根域名服务器查询 根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.com的IP地址 本地域名服务i去向顶级域名服务器dns.com查询 顶级域名服务器告诉本地域名服务器下一次应该查询的权限域名服务器dns.abc.com的IP地址 本地域名服务器向权限域名服务器dns.abc.com进行查询 权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址 本地域名服务器最后把查询结果告诉主机 注意在查询过程中都是使用的UDP用户数据报的报文 为了提高DNS查询效率，减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。 例如前面的例子，已经有用户查询过y.abc.com的IP，那么本地域名服务器就不必向根域名服务器重新查询，直接把高速缓存的结果给用户；又或者本地域名服务器没有y.abc.com的IP地址，保存着顶级域名服务器的地址dns.com，那么本地域名服务器可以不想根域名服务器请求，而是直接向com顶级域名服务器发送查询报文 为什么使用UDP客户端向DNS服务器查询域名，一般返回的内容都不超过512字节（udp报文最大512字节，tcp报文不止512字节），用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向下转型与向上转型]]></title>
    <url>%2F2020%2F09%2F19%2F%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[遇到一道面试题，发现向下转型有点问题 1234567891011121314151617181920class A &#123; public int func1(int a, int b) &#123; return a - b; &#125;&#125;class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125;&#125;public class ChildClass &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); System.out.println("Result=" + a.func1(100, 50)); System.out.println("Result=" + b.func1(100, 50)); &#125;&#125;Result=150 Result=150 多态可以概括为 父类引用指向子类对象 该引用只能调用父类的方法和变量 子类如果重写了父类方法，那么调用这个方法的时候将会调用子类中的方法 所以多态的三个条件 继承 重写 父类引用指向子类对象 向上转型与向下转型 向上转型： Person p = new Man() ; //向上转型不需要强制类型转型 向下转型： Man man = (Man)new Person() ; //必须强制类型转化 对于向上转型我们知道，向下转型有什么用呢，来个例子 新建一个电子产品接口 123public interface Electronics&#123;&#125; 新建一个Thinkpad笔记本类， Mouse鼠标类 ，并实现电子产品接口 12345678910111213141516171819202122232425public class Thinkpad implements Electronics&#123; //Thinkpad引导方法 public void boot()&#123; System.out.println(&quot;welcome,I am Thinkpad&quot;); &#125; //使用Thinkpad编程 public void program()&#123; System.out.println(&quot;using Thinkpad program&quot;); &#125;&#125;public class Mouse implements Electronics&#123; //鼠标移动 public void move()&#123; System.out.println(&quot;move the mouse&quot;); &#125; //鼠标点击 public void onClick()&#123; System.out.println(&quot;a click of the mouse&quot;); &#125;&#125; 我们想象一个情景：我们去商城买电子产品，电子产品有很多，所以就需要一个购物车来装这些电子产品吧。我们可以添加进购物车，然后通过购物车还能知道存放的电子产品数量，能拿到对应的电子产品。那么，一个购物车类就出来了 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.List;public class ShopCar&#123; private List&lt;Electronics&gt; mlist = new ArrayList&lt;Electronics&gt;(); public void add(Electronics electronics)&#123; mlist.add(electronics); &#125; public int getSize()&#123; return mlist.size(); &#125; public Electronics getListItem(int position)&#123; return mlist.get(position); &#125;&#125; 因为要存放多种电子产品，所以需要使用泛型，即 List ，但是呢放进去就自动进行了向上转型，失去了子类独有的方法，这显然不是我们想要的，这是我们就需要向下转型了，来恢复子类特有的方法 1234//开始测试thinkpad电脑Thinkpad thinkpad = (Thinkpad)shopcar.getListItem(THINKPAD);thinkpad.boot();thinkpad.program(); 经过上面这个过程，子类实例已经赋值给了父类引用（即完成了向上转型），但很遗憾的丢失了子类扩展的方法。很好的是Java语言有个向下转型的特性，让我们可以重新获得丢失的方法，即强转回子类 向下转型最大的用处是java的泛型编程，用处很大，Java的集合类都是这样的]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql锁及mvcc]]></title>
    <url>%2F2020%2F09%2F15%2Fmysql%E9%94%81%E5%8F%8Amvcc%2F</url>
    <content type="text"><![CDATA[锁的分类 无锁 12# 明确指定主键，但不存在该主键的值(没有数据，当然不会有锁)SELECT * FROM products WHERE id=-1 FOR UPDATE; 表锁 1234# 主键不明确SELECT * FROM products WHERE name='Mouse' FOR UPDATE;SELECT * FROM products WHERE id&lt;&gt;'3' FOR UPDATE;SELECT * FROM products WHERE id LIKE '3' FOR UPDATE; 行锁 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁 假设有个表 products ，字段id、name、type，id是主键。 只有「明确」指定主键，才会执行锁，否则将会执行表锁 123# 明确指定主键SELECT * FROM products WHERE id=3 FOR UPDATE;SELECT * FROM products WHERE id=3 AND type=1 FOR UPDATE; 行锁算法（机制） 普通行锁：对于键值在条件范围内，且存在的记录，使用” Record Lock “，即普通的行锁机制 1SELECT * FROM products WHERE id='3' FOR UPDATE; 间隙锁：对于键值在条件范围内但并不存在的记录，叫做” 间隙（GAP) “，InnoDB会对这个“间隙”加锁，这种锁机制就是所谓的” Gap Lock “(间隙锁)； 12#products表内并没有id=10，假如有一个9，会将9之后的锁住SELECT * FROM products WHERE id&gt;'10' FOR UPDATE; （行&amp;间隙） 对于存在于不存在的数据同时加锁，则称为” Next-Key Lock “ 12#假设有一个id=7，7就是存在的，(5,7),(7,10)不存在，7存在SELECT * FROM products WHERE id&gt;'5' and id&lt;'10' FOR UPDATE; 行表锁具体应用共享锁&amp;排他锁 行锁和表锁是锁粒度的概念，共享锁和排它锁是他们的具体实现 共享锁：读锁 只能读，不能写 表锁：写锁 连读都不行 表锁算法意向锁 当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁 详细看这篇博客 自增锁 事务插入自增类型的列时获取自增锁 锁（搭配MVCC）在4种隔离级别下的运作-怎么实现隔离效果 读未提交(Read Uncommitted) ： 此时select语句不加任何锁。此时并发最高，但会产生脏读 脏读：读取到尚未提交的数据 读提交(Read Committed, RC) ：会出现不可重复读问题 普通select语句是快照读（MVCC的内容，所以是搭配使用） update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update），使用当前读， 毕竟这些操作都要读取当前数据最新版本嘛 不可重复读： 事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了 可重复读(Repeated Read, RR) ：会出现幻读问题 普通select语句也是快照读 （和RC有区别的） update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update），使用当前读 幻读： 事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读 不可重复读和幻读区别：一个是修改（update），一个是增加（insert）数据 串行化(Serializable) : 此时所有select语句都会被隐式加锁：select … in share mode. MVCCMVCC多版本并发控制，是现代数据库（包括 MySQL、Oracle、PostgreSQL 等）引擎实现中常用的处理读写冲突的手段 可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。大多数的MVCC都实现了非阻塞的读操作，写操作也只锁定必要的行 对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。这样，实现两个隔离级别就非常容易： Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本 Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本 原理对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列 trx_id ：事务ID roll_pointer ：回滚指针 每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息 3个概念 快照读 select时的读就是快照读，对于RC，RR是有区别的，因而产生ReadView的时机也不一样 当前读 更新数据时，都是先读后写，而这个读，就是当前读。读取数据时，读取该条数据的已经提交的最新的事务，生成的 readView ReadView Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。 min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。 max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。 creator_trx_id：表示生成该ReadView的事务的事务id ReadView是如何工作的？ 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，或者不在m_ids中，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问 m_ids里的事务就是还未提交的，之前的就代表提交了，提交了就可以被访问 RC情况下假设数据库内一张表t包含一条记录，插入该记录的事务id为80 123456# Transaction 100BEGIN; UPDATE t SET c = &apos;关羽&apos; WHERE id = 1; UPDATE t SET c = &apos;张飞&apos; WHERE id = 1; 1234# Transaction 200BEGIN; # 更新了一些别的表的记录 此时id为1的记录的版本链 假设现在有一个使用READ COMMITTED隔离级别的事务开始执行，注意100没提交 12345# 使用READ COMMITTED隔离级别的事务BEGIN; # SELECT1：Transaction 100、200未提交SELECT * FROM t WHERE id = 1; # 得到的列c的值为'刘备' 这个SELECT1的执行过程如下 在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是&#39;张飞&#39;，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。 下一个版本的列c的内容是&#39;关羽&#39;，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列c的内容是&#39;刘备&#39;，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为&#39;刘备&#39;的记录 之后，我们把事务id为100的事务提交一下 12345678# Transaction 100BEGIN; UPDATE t SET c = '关羽' WHERE id = 1; UPDATE t SET c = '张飞' WHERE id = 1; COMMIT; 再到事务id为200的事务中更新一下表t中id为1的记录 123456789# Transaction 200BEGIN; # 更新了一些别的表的记录... UPDATE t SET c = '赵云' WHERE id = 1; UPDATE t SET c = '诸葛亮' WHERE id = 1; 此刻，表t中id为1的记录的版本链 ，100提交，200未提交 再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个id为1的记录 12# SELECT2：Transaction 100提交，Transaction 200未提交SELECT * FROM t WHERE id = 1; # 得到的列c的值为'张飞 这个SELECT2的执行过程如下 在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[200]（事务id为100的那个事务已经提交了，所以生成快照时就没有它了）。 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是&#39;诸葛亮&#39;，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。 下一个版本的列c的内容是&#39;赵云&#39;，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列c的内容是&#39;张飞&#39;，该版本的trx_id值为100，比m_ids列表中最小的事务id200还要小，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为&#39;张飞&#39;的记录。 总结一下就是：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView RR情况下（ 在第一次读取数据时生成一个ReadView ）还是之前的情况 这个SELECT1的执行过程如下（100未提交） 在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是&#39;张飞&#39;，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。 下一个版本的列c的内容是&#39;关羽&#39;，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列c的内容是&#39;刘备&#39;，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为&#39;刘备&#39;的记录 这个SELECT2的执行过程如下 （100提交，200提交） 因为之前已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView中的m_ids列表就是[100, 200]。 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是&#39;诸葛亮&#39;，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。 下一个版本的列c的内容是&#39;赵云&#39;，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列c的内容是&#39;张飞&#39;，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列c的内容是&#39;关羽&#39;的版本也不符合要求。继续跳到下一个版本。 下一个版本的列c的内容是&#39;刘备&#39;，该版本的trx_id值为80，80小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为&#39;刘备&#39;的记录 也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是&#39;刘备&#39;，这就是可重复读的含义 参考文档 https://blog.csdn.net/qq_24313635/article/details/102888242 https://blog.csdn.net/zcl_love_wx/article/details/83305645]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新生代为啥要分三块区域]]></title>
    <url>%2F2020%2F09%2F09%2F%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%BA%E5%95%A5%E8%A6%81%E5%88%86%E4%B8%89%E5%9D%97%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[java虚拟机根据对象生命周期的不同把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言） 为什么堆内存要分区呢给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率，这简直太可怕了。 有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中 ， 新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收 为什么Survivor不是0块Survivor如果是0的话，那在eden中垃圾回收之后存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC 为什么Survivor不是1块如果 Survivor 分区是 1 个的话，假设我们把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低 但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作 堆内存分3块有什么好处HotSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1。划分的目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。 GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3构建Vue项目]]></title>
    <url>%2F2020%2F07%2F29%2Fvue-cli3%E6%9E%84%E5%BB%BAVue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[vue-cli3构建Vue项目 shift+右键打开shell，使用create vue 项目名指令 选择manually select，使用空格选择 这里没有选择使用历史模式 选择在package.json中放配置，不作为未来工程的一个模板 进入有package.json的文件夹，运行npm run serve启动]]></content>
      <categories>
        <category>仿牛客项目</category>
      </categories>
      <tags>
        <tag>仿牛客项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2020%2F07%2F26%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[[TOC] 不知道怎么归类精选top42.接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 123输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 思路 当左边和右边的最大的较小的一个都比height[i]大时才会有雨水，需要知道每一个height[i]对应的左边最大和右边最大（画图） 代码 12345678910111213141516171819class Solution &#123; public int trap(int[] height) &#123; int ans=0; int[] left_max=new int[height.length]; int[] right_max=new int[height.length]; for(int i=1;i&lt;height.length;i++)&#123; left_max[i]=Math.max(height[i-1],left_max[i-1]); &#125; for(int i=height.length-2;i&gt;=0;i--)&#123; right_max[i]=Math.max(height[i+1],right_max[i+1]); &#125; for(int i=0;i&lt;height.length;i++)&#123; if(Math.min(left_max[i],right_max[i])&gt;height[i])&#123; ans+=Math.min(left_max[i],right_max[i])-height[i]; &#125; &#125; return ans; &#125;&#125; 7.整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 12输入: 123输出: 321 思路 从个位开始取出每个数 每位数x10+前面一位数 注意结果越界 int范围： -2147483648- 2147483647 代码 12345678910111213class Solution &#123; public int reverse(int x) &#123; int res=0; while(x!=0)&#123; int pop=x%10; x/=10; if(res&gt;Integer.MAX_VALUE/10||(res==Integer.MAX_VALUE/10&amp;&amp;pop&gt;7)) return 0; if(res&lt;Integer.MIN_VALUE/10||(res==Integer.MIN_VALUE/10&amp;&amp;pop&lt;-8)) return 0; res=res*10+pop; &#125; return res; &#125;&#125; 快慢指针精选top287.寻找重复数给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数 12输入: [1,3,4,2,2]输出: 2 思路 把数组当成链表，0-nums[0]-nums[nums[0]],这样因为有重复数字，会出现环 快指针走2步，慢指针走1步，当快指针与慢指针相遇时，假设慢指针n步，则快指针2n步 slow走了n步，在环内走了n-m步，所以需要再走m步到环的入口 但我们不知道m具体多少，所以需要新指针从0开始和slow一起走，直到相遇 代码 12345678910111213141516171819202122class Solution &#123; public int findDuplicate(int[] nums) &#123; //把数组当成链表，0-nums[0]-nums[nums[0]],这样因为有重复数字，会出现环 int slow=0; int fast=0; int last=0; //快指针走2步，慢指针走1步，当快指针与慢指针相遇时，假设慢指针n步，则快指针2n步，所以n%c==0 //slow走了n步，在环内走了n-m步，所以需要再走m步到环的入口 //但我们不知道m具体多少，所以需要新指针从0开始和slow一起走，直到相遇 slow=nums[slow]; fast=nums[nums[fast]]; while(slow!=fast)&#123; slow=nums[slow]; fast=nums[nums[fast]]; &#125; while(slow!=last)&#123; last=nums[last]; slow=nums[slow]; &#125; return slow; &#125;&#125; 精选top141.环形链表给定一个链表，判断链表中是否有环 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 思路 快慢指针，存在环必会相遇 代码 1234567891011121314151617public class Solution &#123; //快指针选2步，更多步的话可能会跳过快指针 //只比慢指针慢一步的话，必然相遇 public boolean hasCycle(ListNode head) &#123; if(head==null||head.next==null) return false; ListNode slow=head; ListNode fast=head.next; while(slow!=fast)&#123; if(fast==null||fast.next==null) return false; slow=slow.next; fast=fast.next.next; &#125; return true; &#125;&#125; 异或等位运算65.不用加减乘除做加法写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 12输入: a = 1, b = 1输出: 2 思路 将2个数相加转换二进制相加，即会产生进位与非进位，转换成进位+非进位，除非加完进位等于0了，循环结束，否则会一直有进位来循环 进位呢相当于与操作，即2个同为1才为1，当然在与操作的基础上还得左移一位,1+1 非进位呢相当于异或操作，即不同为1，相同为0，0+1,1+0,0+0 123456789101112131415class Solution &#123; //思路：将2个数相加转换二进制相加，即会产生进位与非进位，转换成进位+非进位，除非加完进位等于0了，循环结束，否则会一直有进位来循环 //进位呢相当于与操作，即2个同为1才为1，当然在与操作的基础上还得左移一位,1+1 //非进位呢相当于异或操作，即不同为1，相同为0，0+1,1+0,0+0 public int add(int a, int b) &#123; while(b!=0)&#123; int c=(a&amp;b)&lt;&lt;1; //b保存进位 a=a^b; //a保存非进位 b=c; &#125; return a; &#125;&#125; 56-1数组中数字出现的字数 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 12输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 解题思路 异或：相同为0，不同为1 与：同为1才是1，否则是0 只有2个不一样的值，对所有数据进行异或操作，最后的结果就是这两个不一样数字异或的结果。所以考虑通过这个结果将3个不一样的数字分开到2组，实际上异或的结果值中肯定有1位是1，我们选择最低位的1（因为容易找），除了这个1其余为0，将数组所有数字和结果进行与操作，相同数字我们很容易放到一边，因为2个不同数字进行异或结果的那个1意味着在这一位上2个数字是不一样的，那进行与操作分类是也会被分到2组 x&amp;(-x)可以确定最低位的1，为啥？ -x是x符号位不变，其余取反+1，这样进行与操作时，x中最低位的1，前面是0，最低位取反就是0，+1最低位就是1，这样&amp;就是1了 代码 12345678910111213141516171819class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int[] res=new int[2]; int x=0; for(int i:nums)&#123; //找到最近的一个1的位数 x=x^i; &#125; int flag=x&amp;(-x); for(int i:nums)&#123; if((flag&amp;i)==0)&#123; res[0]^=i; &#125;else&#123; res[1]^=i; &#125; &#125; return res; &#125;&#125; 56-2数组中数字出现的字数II在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 12输入：nums = [3,4,3,3]输出：4 思路 通过与运算可以获得每个数字最后一位的值，然后无符号右移看第二位数字 最终将所有数字每位之和放在一个32位的数组里面，将数组中每一个数字%3的结果就是只出现一次的数字 最后将counts数组中的数进行或操作得到结果res 代码 123456789101112131415161718192021222324class Solution &#123; public int singleNumber(int[] nums) &#123; int[] counts=new int[32]; for(int num:nums)&#123; for(int j=0;j&lt;counts.length;j++)&#123; //通过与操作判断每一个数字的每一位，1就是1，0还是0 //int 4个字节，每个字节8位 //32位数字来保存所有数字每位之和，出现3次的最后%3结果是0 counts[j]+=num&amp;1; //无符号右移 num&gt;&gt;&gt;=1; &#125; &#125; for(int i=0;i&lt;32;i++)&#123; counts[i]%=3; &#125; int res=0; for(int m=0;m&lt;32;m++)&#123; res&lt;&lt;=1; res|=counts[31-m]; &#125; return res; &#125;&#125; 用到栈的题目操作 入栈stack.push() / stack.add()返回值类型boolean 出栈stack.pop()返回值类型元素类型 取栈顶值stack.peek() 27请完成一个函数，输入一个二叉树，该函数输出它的镜像思路二：从上到下依次交换每个节点的左右子节点，借助栈来保存树的每个结点进行遍历 1234567891011121314151617181920class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if(root==null) return root; Stack&lt;TreeNode&gt;stack=new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node=stack.pop(); if(node.left!=null) stack.push(node.left); if(node.right!=null) stack.push(node.right); TreeNode temp=new TreeNode(); temp=node.left; node.left=node.right; node.right=temp; &#125; return root; &#125;&#125; 字符串类题目算法6.Z字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 思路 构建3个字符串 遍历字符串，同时让对应字符串改变，比如l就让字符串1append，e就让字符串2append，e让字符串2append，到达行数-1是字符串编号开始减小，即t让字符串2减少 可以发现转折点就是0（开始）和numsRow-1（尾） 可以设一个flag，正常情况下编号+falg完成字符串变化，遇到转折flag=-1，即减一，在遇到0，再变回1，即加1 代码 1234567891011121314151617181920212223class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1) return s; int i=0; int flag=-1; List&lt;StringBuilder&gt;rows=new ArrayList&lt;&gt;(); for(int j=0;j&lt;numRows;j++)&#123; rows.add(new StringBuilder()); &#125; for(char c:s.toCharArray())&#123; rows.get(i).append(c); if(i==0||i==numRows-1) flag=-flag; i+=flag; &#125; StringBuilder res=new StringBuilder(); for(StringBuilder a:rows)&#123; res.append(a); &#125; return res.toString(); &#125;&#125; 58.翻转单词顺序输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 思路：charAt（）得到特定位置字符，substring（int beginIndex，int endIndex）截取字符串，添加到StringBuilder中去 12345678910111213141516171819202122class Solution &#123; public String reverseWords(String s) &#123; //删除单元格 s=s.trim(); int j=s.length()-1; int i=j; StringBuilder str=new StringBuilder(); while(i&gt;=0)&#123; //注意这里的空字符串，中间有空格 while(i&gt;=0 &amp;&amp; s.charAt(i)!=' ')&#123; i--; &#125; //截取字符串，这里的j+1为结束索引，不过不会取的 str.append(s.substring(i+1,j+1)+" "); while(i&gt;=0&amp;&amp;s.charAt(i)==' ')&#123; --i; &#125; j=i; &#125; return str.toString().trim(); &#125;&#125; 58.左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 思路 subString（）2段子字符串拼接+ StringBuilder.append() charAt() 123456789101112class Solution &#123; public String reverseLeftWords(String s, int n) &#123; StringBuilder str=new StringBuilder(); for(int i=n;i&lt;s.length();i++)&#123; str.append(s.charAt(i)); &#125; for(int j=0;j&lt;n;j++)&#123; str.append(s.charAt(j)); &#125; return str.toString(); &#125;&#125; 二分法53-II.0 0~n-1缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字 12输入: [0,1,3]输出: 2 思路 将数组分成2块，值与索引相等的一块，不等的一块 如果不等，nums[m]=m ，则 “右子数组的首位元素” 一定在闭区间[m+1,high];如果相等，则左数组的首位元素一定在[low,m-1] 代码 1234567891011121314151617class Solution &#123; //将数组分成2块，值与索引相等的一块，不等的一块 //如果不等，nums[m]=m ，则 “右子数组的首位元素” 一定在闭区间[m+1,high];如果相等，则左数组的首位元素一定在[low,m-1] public int missingNumber(int[] nums) &#123; int low=0; int high=nums.length-1; while(low&lt;=high)&#123; int mid=(high+low)/2; if(nums[mid]==mid)&#123; low=mid+1; &#125;else&#123; high=mid-1; &#125; &#125; return low; &#125;&#125; 11.旋转数组最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1 思路：一般排序数组都可采用二分法查找，二分法取中位数，此题中如果mid小于right，说明mid在右数组中；mid大于right，说明mid在右边；mid=right，则mid可能在左数组，也可能在右数组，比如33313和3411 1234567891011121314151617181920class Solution &#123; public int minArray(int[] numbers) &#123; if(numbers.length==0) return 0; int left=0; int right=numbers.length-1; while(left&lt;right)&#123; int m=left+(right-left)/2; if(numbers[m]&lt;numbers[right])&#123; right=m; &#125;else if(numbers[m]&gt;numbers[right])&#123; left=m+1; &#125;else&#123; //numbers[m]=numbers[j],j可以直接-1，剪了之后还会有m在 right-=1; &#125; &#125; return numbers[left]; &#125;&#125; 53-1 在排序数组中查找数字统计一个数字在排序数组中出现的次数 12输入: nums = [5,7,7,8,8,10], target = 8输出: 2 思路 还是二分查找，只不过关注左右边界，right-left-1就是答案 当nums[mid]&gt;=target时，i=mid+1，这样i就在最后一个target后面一个位置 当nums[mid]&lt;=target时，j=mid-1，这样j就在第一个target前一个位置 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int search(int[] nums, int target) &#123; int i=0; int j=nums.length-1; while(i&lt;=j)&#123; int mid=(i+j)/2; if(nums[mid]&lt;=target)&#123; i=mid+1; &#125;else&#123; j=mid-1; &#125; &#125; //上面循环的时候每次有mid=target，i就mid+1，所以i一定在最后一个target之后 int right=i; if(j&gt;0&amp;&amp;nums[j]!=target) return 0; i=0; j=nums.length-1; //与上面同理，j始终会在target前一个位置，所以返回左边界为j while(i&lt;=j)&#123; int mid=(i+j)/2; if(nums[mid]&gt;=target)&#123; j=mid-1; &#125;else&#123; i=mid+1; &#125; &#125; int left=j; return right-left-1; &#125;&#125; 双指针普通15.三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路 排序 从第一个元素开始，进行遍历k 再设两个指针分别从K+1，length-1开始，使得3数之和为0 代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int k=0;k&lt;nums.length-2;k++)&#123; if(nums[k]&gt;0) break; if(k&gt;0&amp;&amp;nums[k]==nums[k-1]) continue; int i=k+1; int j=nums.length-1; while(i&lt;j)&#123; List&lt;Integer&gt;path=new ArrayList&lt;&gt;(); int sum=nums[k]+nums[i]+nums[j]; if(sum&lt;0)&#123; i+=1; while(i&lt;j&amp;&amp;nums[i]==nums[i-1])&#123; i+=1; &#125; &#125;else if(sum&gt;0)&#123; j-=1; while(i&lt;j&amp;&amp;nums[j]==nums[j+1])&#123; j-=1; &#125; &#125;else&#123; path.add(nums[k]); path.add(nums[i]); path.add(nums[j]); res.add(new ArrayList&lt;&gt;(path)); while(i&lt;j&amp;&amp;nums[i]==nums[++i]); while(i&lt;j&amp;&amp;nums[j]==nums[--j]); &#125; &#125; &#125; return res; &#125;&#125; 21.调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一 思路 i，j数组两端，分别向中间遍历，i遇到偶数停下，j遇到奇数停下 怎么判断奇偶：和1进行&amp;操作，奇数结果为1，偶数结果为0 代码 123456789101112131415class Solution &#123; public int[] exchange(int[] nums) &#123; int temp; int i=0; int j=nums.length-1; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;(nums[i]&amp;1)==1) ++i; while(i&lt;j&amp;&amp;(nums[j]&amp;1)==0) --j; temp=nums[i]; nums[i]=nums[j]; nums[j]=temp; &#125; return nums; &#125;&#125; 56.和为s的两个数字输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可 12输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2] 初始化：i，j分别指向数组两端 循环搜索：当双指针相遇时跳出循环 若nums[i]+nums[j]&gt;target，j– 若nums[i]+nums[j]&lt;target，i++ 若nums[i]+nums[j]=target，nums[j]和nums[j即为所求 代码 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] res=new int[2]; int i=0; int j=nums.length-1; while(i&lt;=j)&#123; if(nums[i]+nums[j]&gt;target)&#123; --j; &#125;else if(nums[i]+nums[j]&lt;target)&#123; ++i; &#125;else&#123; res[0]=nums[i]; res[1]=nums[j]; break; &#125; &#125; return res; &#125;&#125; 精选top26.删除排序数组重复的选项给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 思路 双指针，i慢指针，j快指针，j遇到重复的就往后走，遇到不一样的就把值赋给i+1的位置，这样从0-新的i都是不一样的了；也就是j每次遍历到不一样的，就把内容代替相同的内容，保证i后面都是不一样的 例如1112，j到2的适合，就让2覆盖原来第二个1，也就是长度为12 代码 123456789101112class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i=0; for(int j=1;j&lt;nums.length;j++)&#123; if(nums[i]!=nums[j])&#123; i+=1; nums[i]=nums[j]; &#125; &#125; return i+1; &#125;&#125; 剑指offer52.两个链表的第一个公共结点输入两个链表，找出它们的第一个公共节点 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 思路 假设链表1：l1+lx(相同结点后的公共部分) 链表2：l2+lx 这样两个指针，一个走l1+lx+l2，一个走l2+lx+l1，路径长度相同，且会相遇 代码 1234567891011public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode hA=headA; ListNode hB=headB; while(hA!=hB)&#123; hA=hA==null?headB:hA.next; hB=hB==null?headA:hB.next; &#125; return hA; &#125;&#125; 滑动窗口48.最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 思路 j用来遍历字符串，窗口区间采用【i，j】，res=max(res,j-i+1)，hashmap用来存储每个字符的位置，当j遍历到相同字符时，改变左边界i，i=max(i，map.get(ch)+1)，为什么要取max呢 比如abba，当j到2时，i也变为2，当j继续往下走，到3时，如果还是+1这种，i反而成了1，此时bb重复了 代码 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt;map=new HashMap&lt;&gt;(); int i=0; int res=0; for(int j=0;j&lt;s.length();j++)&#123; char ch=s.charAt(j); if(map.containsKey(ch)) i=Math.max(map.get(ch)+1,i); map.put(ch,j); res=Math.max(res,j-i+1); &#125; return res; &#125;&#125; 57.和为s的连续正数序列输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数） 12输入：target = 9输出：[[2,3,4],[4,5]] 思路 采用滑动窗口，即【a,b】的形式，如果【a,b】的和&gt;target，则需要左边界向右移一位；如果sum&lt;target，需要右边界向右移一位；如果相等，将数字存入List&lt;int[ ]&gt;中。需要特别注意的是滑动窗口只能向右滑 代码 123456789101112131415161718192021222324252627class Solution &#123; public int[][] findContinuousSequence(int target) &#123; //滑动窗口，【a,b】,初始【1，1】 int i=1; int j=1; int sum=1; List&lt;int[]&gt;list=new ArrayList&lt;&gt;(); while(i&lt;=target/2)&#123; if(sum&gt;target)&#123; sum-=i; i++; &#125;else if(sum&lt;target)&#123; j++; sum+=j; &#125;else&#123; int[] res=new int[j-i+1]; for(int k=i;k&lt;=j;k++)&#123; res[k-i]=k; &#125; list.add(res); sum-=i; i++; &#125; &#125; return list.toArray(new int[list.size()][]); &#125;&#125; 利用哈希35.复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 思路 题目要求就是复制一个一模一样的链表 常理我们会写只有next指针的链表的复制，我们复制所有结点并连接起来 链接完就想接下来要链接random，要连random就要找到原来一样的head，怎么快速找到，用map 代码 123456789101112131415161718192021222324252627282930class Solution &#123; public Node copyRandomList(Node head) &#123; if(head==null) return null; Map&lt;Node,Node&gt;map=new HashMap&lt;&gt;(); //2个链表，所以需要两个遍历指针 Node temp1=head; Node res=new Node(head.val); Node temp2=res; map.put(head,res); //第一步复制所有节点连接起来 while(temp1.next!=null)&#123; temp2.next=new Node(temp1.next.val); temp2=temp2.next; temp1=temp1.next; map.put(temp1,temp2); &#125; //链接完就想接下来要链接random，要连random就要找到原来一样的结点，h.random对应的结点s,也就是h2.random对应的s2 //怎么找到s2，用map取出h.random就是s2 temp1=head; temp2=res; while(temp1!=null)&#123; if(temp1.random!=null) temp2.random=map.get(temp1.random); temp1=temp1.next; temp2=temp2.next; &#125; return res; &#125;&#125; 50.第一个只出现一次的字符在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 12345s = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot; 思路 建立一个HashMap，键值对分别为字符和boolean，第一轮遍历字符数组，将每个字符以及之前的是否存储过存入map，前面有则为false，否则true，第二轮将每个字符到map中去查找出来，value为true既是第一个只出现一次的字符 代码 1234567891011121314class Solution &#123; public char firstUniqChar(String s) &#123; char[]sc=s.toCharArray(); HashMap&lt;Character,Boolean&gt;map=new HashMap&lt;&gt;(); for(char a:sc)&#123; map.put(a,!map.containsKey(a)); &#125; for(char b:sc)&#123; if(map.get(b)) return b; &#125; return ' '; &#125;&#125; 39.数组中出现超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字 12输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 思路 利用hashmap存储每个数字的出现次数，在进行一轮查找即可，但效率不高 1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; HashMap&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;(); for(int i:nums)&#123; if(!map.containsKey(i))&#123; map.put(i,1); &#125;else&#123; map.put(i,map.get(i)+1); &#125; &#125; for(int j:nums)&#123; if(map.get(j)&gt;nums.length/2) return j; &#125; return 0; &#125;&#125; 动态规划算法1143.最长公共子串给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。 思路 定义二维数组dp：字符串1从1…i和字符串2从1…j的最长公共子串 两个指针i，j遍历字符串，如果相等，则dp[i] [j]=i-1的字符串和j-1的字符串的公共子串 如果不相等，要么是1…i-1和1…j的子串，要么是1…i和1…j-1的最长公共子串，取大的就行 代码 1234567891011121314151617181920212223class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; char[] s1=text1.toCharArray(); char[] s2=text2.toCharArray(); int len1=s1.length; int len2=s2.length; //dp[i][j]数组表示s[1..i]和s[1..j]的最长公共子串 int[][]dp=new int[len1+1][len2+1]; for(int i=1;i&lt;len1+1;i++)&#123; for(int j=1;j&lt;len2+1;j++)&#123; //如果s[i]和是s[j]相等，那么公共子串长度从之前的再加一 //字符串下标从0开始，所以是i-1 if(s1[i-1]==s2[j-1])&#123; dp[i][j]=1+dp[i-1][j-1]; &#125;else&#123; //如果不相等，那最长公共子串要么是i-1和j，要么是i和j-1,取大的 dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125; 牛客.最长公共子序列和上题的区别就是要求字符是连续的 思路 和上题一样记录最大长度 区别在于状态定义不一样，因而转移方程也有所区别，这里要求是以s[i]和s2[j]为底的最长子序列 代码 精选top300.最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 思路 dp[i]代表以nums[i]为结尾的最长上升子序列 dp[i]=dp[j]+1或者dp[i]，条件是dp[j]&lt;dp[i] 代码 12345678910111213141516171819202122class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if(nums.length==0) return 0; int maxans=0; int len=nums.length; //dp[i]为以nums[i]为结尾的 int[]dp=new int[len]; for(int i=0;i&lt;len;i++)&#123; //每一轮开始都初始化为1，因为后面还要比较大小 dp[i]=1; for(int j=0;j&lt;i;j++)&#123; if(nums[j]&lt;nums[i])&#123; //1是nums[i] dp[i]=Math.max(dp[i],dp[j]+1); &#125; &#125; maxans=Math.max(maxans,dp[i]); &#125; return maxans; &#125;&#125; 42.连续子数组的和 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值 123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 思路 dp[i]代表以nums[i]为结尾的子数组之和 12345678910111213141516class Solution &#123; public int maxSubArray(int[] nums) &#123; int[]dp=new int[nums.length]; dp[0]=nums[0]; int res=dp[0]; for(int i=1;i&lt;nums.length;i++)&#123; if(dp[i-1]&gt;0)&#123; dp[i]=dp[i-1]+nums[i]; &#125;else&#123; dp[i]=nums[i]; &#125; res=Math.max(res,dp[i]); &#125; return res; &#125;&#125; 精选top5.最长回文串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 思路 通过l即字符串长度从0开始遍历 状态定义：dp[i] [j]代表字符串中下表i-j的最大回文串 初始状态：l=1 dp一定为true l=2 si=sj时为true 转移方程： P(i,j)=P(i+1,j−1)∧(Si==Sj) 代码 1234567891011121314151617181920212223class Solution &#123; public String longestPalindrome(String s) &#123; int n=s.length(); boolean[][] dp=new boolean[n][n]; String ans=""; for(int l=0;l&lt;n;l++)&#123; for(int i=0;i+l&lt;n;i++)&#123; int j=i+l; if(l==0)&#123; dp[i][j]=true; &#125;else if(l==1)&#123; dp[i][j]=(s.charAt(i)==s.charAt(j)); &#125;else&#123; dp[i][j]=(s.charAt(i)==s.charAt(j)&amp;&amp;dp[i+1][j-1]); &#125; //只有子串更长了才更新 if(dp[i][j]&amp;&amp;l+1&gt;ans.length()) ans=s.substring(i,j+1); &#125; &#125; return ans; &#125;&#125; 63.股票的最大利润假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 思路 状态定义 dp[i]：以price[i]结尾的子数组的最大利润 转移方程：dp[i]=max(dp[i-1],price-min(price[0:4])) 初始状态：dp[0]=0 代码 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length==0) return 0; int min=Integer.MAX_VALUE; int[]dp=new int[prices.length]; for(int i=0;i&lt;prices.length;i++)&#123; min=Math.min(min,prices[i]); if(i==0)&#123; dp[i]=0; continue; &#125; dp[i]=Math.max(dp[i-1],prices[i]-min); &#125; return dp[prices.length-1]; &#125;&#125; 60.n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率 12输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 思路 状态定义 dp[i] [j] 表示投掷完i枚骰子后，点数j的出现次数 转移方程 dp[i] [j]=dp[i-1] [j-k] k从1-6，j-k必须小于i-1 初始状态 dp[1] [j]=1 j从1-6 代码 1234567891011121314151617181920212223class Solution &#123; public double[] twoSum(int n) &#123; int[][] dp=new int[n+1][6*n+1]; for(int t=1;t&lt;=6;t++)&#123; dp[1][t]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=i;j&lt;=6*n;j++)&#123; for(int k=1;k&lt;=6;k++)&#123; if(j-k&lt;i-1) break; dp[i][j]+=dp[i-1][j-k]; &#125; &#125; &#125; double total=Math.pow((double)6,(double)n); double[]res=new double[5*n+1]; for(int m=n;m&lt;=6*n;m++)&#123; res[m-n]=(double)dp[n][m]/total; &#125; return res; &#125;&#125; 47.礼物的最大价值在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 12345678输入: [ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 思路 状态定义 dp[i] [j] 代表从棋盘的左上角开始，到达单元格（i，j）时能拿到礼物的最大累计价值 状态转移 dp[i] [j] grid[i] [j]=max(grid[i-1] [j-1]+grid[i-1] [j]，grid[i-1] [j-1]+grid[i] [j-1]) 初始状态 dp[0] [0]=grid[0] [0] 代码 1234567891011121314151617181920class Solution &#123; public int maxValue(int[][] grid) &#123; int m=grid.length; int n=grid[0].length; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0&amp;&amp;j==0) continue; if(j==0)&#123; grid[i][j]+=grid[i-1][j]; &#125;else if(i==0)&#123; grid[i][j]+=grid[i][j-1]; &#125;else&#123; grid[i][j]+=Math.max(grid[i-1][j],grid[i][j-1]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125; 46.把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 思路 状态定义 dp[i]代表以i结尾的数字的翻译方法 转移方程 如果第i和i-1个数字可以被翻译，则dp[i]=dp[i-1]+dp[i-2]；否则，dp[i]=dp[i-1] 初始状态 dp[0]=1 dp[1]=1，dp[0]可由dp[2] 代码 123456789101112131415161718192021class Solution &#123; public int translateNum(int num) &#123; String s=String.valueOf(num); //数字第一位对应着dp[1]，所以还有个dp[0] int[]dp=new int[s.length()+1]; //dp[0]由dp[2]求得，因为2位树肯定是在10-25之间，所以dp[2]=2,dp[0]=1 dp[0]=1; dp[1]=1; //字符串下表为0-length-1,而转移方程是i-1，i-2位，所以i需要从2到length for(int i=2;i&lt;=s.length();i++)&#123; String a=s.substring(i-2,i); if(a.compareTo("10")&gt;=0&amp;&amp;a.compareTo("25")&lt;=0)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125;else&#123; dp[i]=dp[i-1]; &#125; &#125; //dp数组是从0-length return dp[s.length()]; &#125;&#125; 14-I 剪绳子I给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 思路 状态定义 dp[i] 长度为i的绳子最大乘积 初始状态 dp[1]=1 dp[2]=1 状态转移 dp[i]=Math.max(dp[i],Math.max(dp[i-j]j,(i-j)j)); 代码 123456789101112131415class Solution &#123; public int cuttingRope(int n) &#123; int[] dp=new int[n+1]; dp[1]=1; dp[2]=1; for(int i=3;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; //Math.max只能比较两个，所以后面才要再使用一次max //这里的dp[i]起到一个保存相同总长,不同切法,乘积最大值的作用.确保把内循环不同切法得到的乘积的最大值保存下来. dp[i]=Math.max(dp[i],Math.max(dp[i-j]*j,(i-j)*j)); &#125; &#125; return dp[n]; &#125;&#125; 回溯法 终止条件 for实现每个分支 要不要去重，begin(组合问题)，used[]（排列问题）/要不要剪枝 递归到下一层，参数变化 普通77.组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合 代码 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; Deque&lt;Integer&gt;path=new ArrayDeque&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;(); if(k&lt;=0) return res; DFS(k,path,res,1,n); return res; &#125; void DFS(int k,Deque&lt;Integer&gt;path,List&lt;List&lt;Integer&gt;&gt;res,int begin,int len)&#123; if(path.size()==k)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=begin;i&lt;=len;i++)&#123; path.addLast(i); DFS(k,path,res,i+1,len); path.removeLast(); &#125; &#125;&#125; 78.子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集） 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 思路 什么时候递归结束，遍历到最后一个元素的时候 什么时候加入一个结果，每一个结点都是一个答案 代码 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; int len=nums.length; Deque&lt;Integer&gt;path=new ArrayDeque&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;(); res.add(new ArrayList()); DFS(0,len,path,res,nums); return res; &#125; void DFS(int begin,int len,Deque&lt;Integer&gt;path,List&lt;List&lt;Integer&gt;&gt;res,int[] nums)&#123; if(begin==len)&#123; return; &#125; for(int i=begin;i&lt;len;i++)&#123; path.addLast(nums[i]); res.add(new ArrayList&lt;&gt;(path)); DFS(i+1,len,path,res,nums); path.removeLast(); &#125; &#125;&#125; 普通93.复原ip给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1“ 是 无效的 IP 地址 思路 回溯 注意剪枝 https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int len=s.length(); List&lt;String&gt;res=new ArrayList&lt;&gt;(); if (len &gt; 12 || len &lt; 4) &#123; return res; &#125; Deque&lt;String&gt;path=new ArrayDeque&lt;&gt;(4); DFS(len,0,4,s,path,res); return res; &#125; //begin是每一段的开始 void DFS(int len,int begin,int residue,String s,Deque&lt;String&gt;path,List&lt;String&gt;res)&#123; //如果只是begin==len，还不够，因为可能是5段，6段才达到的，需要满足4段 if(begin==len)&#123; if(residue==0)&#123; res.add(String.join(&quot;.&quot;,path)); &#125; return; &#125; for(int i=begin;i&lt;begin+3;i++)&#123; if(i&gt;=len)&#123; break; &#125; if(residue*3&lt;len-i)&#123; continue; &#125; //判断字符串left，i字符串是否有效 if(judge(s,begin,i))&#123; String temp=s.substring(begin,i+1); path.addLast(temp); DFS(len,i+1,residue-1,s,path,res); path.removeLast(); &#125; &#125; &#125; private boolean judge(String s,int left,int right)&#123; int len=right-left+1; //单个0是符合的，01这种就不行了，所以需要len if(len&gt;1&amp;&amp;s.charAt(left)==&apos;0&apos;)&#123; return false; &#125; //计算一段ip的数值 int res=0; while(left&lt;=right)&#123; res=res*10+s.charAt(left)-&apos;0&apos;; left++; &#125; return res&gt;=0&amp;&amp;res&lt;=255; &#125;&#125; 精选top46.全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路 https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/ 代码 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; int len=nums.length; List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;(); if(len==0) return res; boolean[] used=new boolean[len]; List&lt;Integer&gt;temp=new ArrayList&lt;&gt;(); DFS(nums,0,len,res,temp,used); return res; &#125; void DFS(int[] nums,int depth,int len,List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,boolean[] used)&#123; if(depth==len)&#123; res.add(new ArrayList&lt;&gt;(temp)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(!used[i])&#123; temp.add(nums[i]); used[i]=true; //加入一个元素后，深度加一 DFS(nums,depth+1,len,res,temp,used); //回退 used[i] = false; temp.remove(temp.size() - 1); &#125; &#125; &#125;&#125; 38.字符串的排列输入一个字符串，打印出该字符串中字符的所有排列 ，你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 12输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 思路 · 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String[] permutation(String s) &#123; char[] str=s.toCharArray(); Arrays.sort(str); int len=s.length(); StringBuilder res=new StringBuilder(); boolean[] used=new boolean[len]; List&lt;String&gt;ans=new ArrayList&lt;&gt;(); DFS(used,str,res,0,len,ans); return ans.toArray(new String[0]); &#125; void DFS(boolean[]used,char[]str,StringBuilder res,int depth,int len,List&lt;String&gt;ans)&#123; if(depth==len)&#123; ans.add(res.toString()); return; &#125; for(int i=0;i&lt;len;i++)&#123; if(!used[i])&#123; //剪枝，这一轮的str[i]和上一轮一样，且used被置为了true，必然出现重复 if(i&gt;0&amp;&amp;str[i]==str[i-1]&amp;&amp;!used[i-1])&#123; continue; &#125; used[i]=true; res.append(str[i]); DFS(used,str,res,depth+1,len,ans); res.deleteCharAt(res.length()-1); used[i]=false; &#125; &#125; &#125;&#125; 12.矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 思路 回溯法 代码 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; int[][] direction=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; //m行号，n列号 int m,n; public boolean exist(char[][] board, String word) &#123; m=board.length; n=board[0].length; boolean[][] marked=new boolean[m][n]; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; //return DFS(0,i,j,board,word,marked) ;这种写法错误，这样只是从一个点开始，错误就false，没有把每个点都试过去 if(DFS(0,i,j,board,word,marked)) return true; &#125; &#125; return false; &#125; //start word的指针，i，j坐标 boolean DFS(int start,int i,int j,char[][]board,String word,boolean[][]marked)&#123; if(start==word.length()-1)&#123; return board[i][j]==word.charAt(start); &#125; if(board[i][j]==word.charAt(start))&#123; marked[i][j]=true; for(int k=0;k&lt;4;k++)&#123; int newX=i+direction[k][0]; int newY=j+direction[k][1]; if(inArea(newX,newY)&amp;&amp;!marked[newX][newY])&#123; if(DFS(start+1,newX,newY,board,word,marked))&#123; return true; &#125; &#125; &#125; marked[i][j]=false; &#125; return false; &#125; boolean inArea(int i,int j)&#123; return i&gt;=0&amp;&amp;i&lt;m&amp;&amp;j&gt;=0&amp;&amp;j&lt;n; &#125;&#125; 13.机器人的运动范围地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 12输入：m = 2, n = 3, k = 1输出：3 思路 仿机器人 代码 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; int[][]direction=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; int m,n; int res; public int movingCount(int m, int n, int k) &#123; this.m=m; this.n=n; res=0; boolean[][]visited=new boolean[m][n]; DFS(0,0,visited,k); return res; &#125; void DFS(int i,int j,boolean[][]visited,int k)&#123; if(sum(i)+sum(j)&gt;k||!inArea(i,j)||visited[i][j])&#123; return; &#125; visited[i][j]=true; res+=1; for(int m=0;m&lt;4;m++)&#123; int newX=i+direction[m][0]; int newY=j+direction[m][1]; DFS(newX,newY,visited,k); &#125; &#125; int sum(int x)&#123; int total=0; while(x!=0)&#123; total+=x%10; x=x/10; &#125; return total; &#125; boolean inArea(int i,int j)&#123; return i&gt;=0&amp;&amp;i&lt;m&amp;&amp;j&gt;=0&amp;&amp;j&lt;n; &#125;&#125; 贪心法14-II 剪绳子给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 思路 若切分方案合理，绳子段切分的越多，乘积越大 为使乘积最大，只有长度为 22 和 33 的绳子不应再切分，且 3比 2 更优 绳子切分方案 乘积 结论 2=1+1 1×1=1 2 不应切分 3=1+2 1×2=2 3 不应切分 4=2+2=1+3 2×2=4&gt;1×3=3 4 和 2 等价，且 2+2 比 1+3 更优 5=2+3=1+4 2×3=6&gt;1×4=4 5 应切分为 2+3 6=3+3=2+2+2 3×3=9&gt;2×2×2=8 6 应切分为 3+3，进而推出 3 比 2 更优 代码 1234567891011121314class Solution &#123; public int cuttingRope(int n) &#123; if(n &lt;= 3) return n - 1; long res=1L; int p=(int)1e9+7; //贪心算法，优先切三，其次切二 while(n&gt;4)&#123; res=res*3%p; n-=3; &#125; //出来循环只有三种情况，分别是n=2、3、4 return (int)(res*n%p); &#125;&#125; 链表遍历24.反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路 两个指针，cur=head，pre=null，让head.next=pre，注意保存后一个结点 代码 123456789101112131415class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode cur=head; ListNode pre=null; while(cur!=null)&#123; ListNode temp=cur.next; cur.next=pre; pre=cur; cur=temp; &#125; return pre; &#125;&#125; 06.从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 12输入：head = [1,3,2]输出：[2,3,1] 思路 利用栈 代码 12345678910111213141516class Solution &#123; public int[] reversePrint(ListNode head) &#123; Stack&lt;ListNode&gt;stack=new Stack&lt;&gt;(); ListNode temp=head; while(temp!=null)&#123; stack.push(temp); temp=temp.next; &#125; int size=stack.size(); int[] res=new int[size]; for(int i=0;i&lt;size;i++)&#123; res[i]=stack.pop().val; &#125; return res; &#125;&#125; 精选top19 删除链表的倒数第n个结点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5 思路 删除倒数第n个，也就是删除l-(n-1)个结点，那就找到l-n个结点完成删除 代码 123456789101112131415161718192021222324class Solution &#123; //求倒数第n个相当于求l-(n-1)个，也就是找到l-(n-1)-1即l-n public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy=new ListNode(0); dummy.next=head; ListNode first=head; int count=0; int length=0; //遍历到最后的元素，求链表长度 while(first!=null)&#123; length+=1; first=first.next; &#125; //从头开始遍历 first=dummy; //找l-(n-1)个，也就是找到l-(n-1)-1即l-n，这样才能删除 while(!(count==length-n))&#123; count+=1; first=first.next; &#125; first.next=first.next.next; return dummy.next; &#125;&#125; 25.合并两个有序的链表 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路 两个指针依次进行遍历，比大小 代码 123456789101112131415161718class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode node=new ListNode(-1); ListNode last=node; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&gt;=l2.val)&#123; node.next=l2; l2=l2.next; &#125;else&#123; node.next=l1; l1=l1.next; &#125; node=node.next; &#125; node.next=l1!=null?l1:l2; return last.next; &#125;&#125; 排序40.最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1] 思路 堆排序，Java中有现成的类 快排 每进行一趟快排，就确定了一个元素的位置，此时该元素左边都比元素小，右边都比元素大；要找第k大的数，即nums[k-1]，就可以多次快排，确定一个nums[j],如果j比k小，则在右边递归进行排序，否则左边 代码 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if(k==0||arr.length==0) return new int[0]; int right=arr.length-1; int[]res=new int[k]; res=quickSort(arr,0,right,k-1); return res; &#125; private int[] quickSort(int[] nums,int left,int right,int k)&#123; int j=partition(nums,left,right); if(j==k) return Arrays.copyOf(nums,j+1); return j&lt;k?quickSort(nums,left+1,right,k):quickSort(nums,left,right-1,k); &#125; //一次快排,确定了nums[j] private int partition(int[] nums,int left,int right)&#123; //right+1是因为后面循环要--j int i=left,j=right+1; //基准元素 int target=nums[left]; while(true)&#123; while(++i&lt;=right&amp;&amp;nums[i]&lt;target); while(--j&gt;=left&amp;&amp;nums[j]&gt;target); //循环终止 if(i&gt;=j) break; int temp=nums[i]; nums[i]=nums[j]; nums[j]=temp; &#125; nums[left]=nums[j]; nums[j]=target; return j; &#125;&#125; 树类28.对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 、 思路 如果结点的左右孩子有一个为空或者值不相等，那false 如果都存在，那true，因为上面判断了值不相等的情况 代码 123456789101112class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; return Symmetric(root.left,root.right); &#125; boolean Symmetric(TreeNode left,TreeNode right)&#123; if(left==null&amp;&amp;right==null) return true; if(left==null||right==null||left.val!=right.val) return false; return Symmetric(left.left,right.right)&amp;&amp;Symmetric(left.right,right.left); &#125;&#125; 普通617.合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 代码 123456789101112class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; TreeNode node=new TreeNode(t1.val+t2.val); node.left=mergeTrees(t1.left,t2.left); node.right=mergeTrees(t1.right,t2.right); return node; &#125;&#125; 36.二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 思路 二叉搜索树中序为有序的，添加指针即可 cur结点的left为前驱结点，前驱结点的right为cur结点 对于中序第一个结点的pre为空，让head=cur 最后在首尾相顾，构成循环 代码 123456789101112131415161718192021222324class Solution &#123; Node pre,head; public Node treeToDoublyList(Node root) &#123; if(root==null) return null; DFS(root); //循环，构建首尾 head.left=pre; pre.right=head; return head; &#125; void DFS(Node cur)&#123; if(cur==null) return; DFS(cur.left); if(pre!=null) pre.right=cur; else head=cur; cur.left=pre; pre=cur; DFS(cur.right); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2020%2F07%2F23%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式概念单例模式即一个类负责创建自己的对象，且确保是单个对象，并且该类提供访问自己唯一对象的方法，可以直接访问，不需要实例化 场景数据库连接对象connection，每次建立连接都创建一个对象，消耗太大（可以复用的对象为毛还要每次创建销毁呢），所以我们可以把这个对象设计成单例，只需创建一次并且可以重复使用不就行了 单例模式三大目标 懒加载：程序创建时不需要创建对象，等用到时在创建 线程安全 单例模式代码演化one这种情况下线程不安全 123456789101112public class Singleton1 &#123; private Singleton1()&#123;&#125;; private static Singleton1 singleton1; public static Singleton1 getSingleton()&#123; if(singleton1==null)&#123; singleton1 =new Singleton1(); &#125; return singleton1; &#125;&#125; two锁方法造成效率低下，每次拿对象都得获取锁，我们只需要在构建对象时加锁即可 123456789101112public class Singleton2 &#123; private Singleton2()&#123;&#125;; private static Singleton2 singleton2; public static synchronized Singleton2 getSingleton()&#123; if(singleton2==null)&#123; singleton2 =new Singleton2(); &#125; return singleton2; &#125;&#125; three这里在构建对象时加锁，但还是存在问题，例如A,B两个线程都执行完1步，此时假设A线程获取锁，创建了对象，结束；然后B线程此时因为已经执行完1，也会获得锁，创建对象 123456789101112private static Singleton3 singleton3;private Singleton3()&#123;&#125;;private static Singleton3 getSingleton()&#123; if(singleton3==null)&#123;//1 synchronized (Singleton3.class)&#123;//2 singleton3=new Singleton3();//3 &#125; &#125; return singleton3;&#125; four双校验锁，在获得锁之后再加一次判断，当然这种方式也会有问题，但已经不错了。问题在于：singleton5=new Singleton5()这一句代表包括3步，分配内存，初始化对象，对象指向内存空间；此时可能会有指令重排，假设A执行了分配内存，对象执行内存空间，而没有初始化，当B线程判断instance已存在时会直接返回一个A线程没有初始化的instance 12345678910111213141516public class Singleton5 &#123; private static Singleton5 singleton5; private Singleton5()&#123;&#125;; private static Singleton5 getSingleton()&#123; if(singleton5==null)&#123;//1 synchronized (Singleton5.class)&#123;//2 if(singleton5==null)&#123; singleton5=new Singleton5();//3 &#125; &#125; &#125; return singleton5; &#125;&#125; five加个volatile解决 12345678910111213141516public class Singleton5 &#123; private static volatile Singleton5 singleton5; private Singleton5()&#123;&#125;; private static Singleton5 getSingleton()&#123; if(singleton5==null)&#123;//1 synchronized (Singleton5.class)&#123;//2 if(singleton5==null)&#123; singleton5=new Singleton5();//3 &#125; &#125; &#125; return singleton5; &#125;&#125;]]></content>
      <categories>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq]]></title>
    <url>%2F2020%2F06%2F16%2Frabbitmq%2F</url>
    <content type="text"><![CDATA[RabbitMqRabbitMQ是一个实现了AMQP（Advanced Message Queuing Protocol）高级消息队列协议的消息队列服务 基本概念 publisher：生产者，即数据的发送方，会发送一个实现了序列化的Message对象进行消息传递，Message包括 payload（有效载荷）和label（标签），payload顾名思义就是传输的数据，label是exchange的名字或者说是一个tag，它描述了payload，而且RabbitMQ也是通过这个label来决定把这个Message发给哪个Consumer 12345rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME,MailConstants.MAIL_ROUTING_KEY_NAME,emp,new CorrelationData(msgId));public CorrelationData(String id) &#123; this.id = id;&#125; 这里的convertAndSend方法会将emp对象转换为Message发送，CorrelationData只有一个id属性可用来保证可靠消息，以后再说 broker： 接收和分发消息的应用 （rabbitmq服务器） exchange：交换机， 根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast) binding： exchange和queue之间的虚拟连接，binding中可以包含routing key queue：队列 Connection： publisher／consumer和broker之间的TCP连接 Channel： 如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的 exchange类型 Direct exchange 直接转发路由 将消息的routing key和binding中的routing key比照，匹配则发到对应的队列 Fanout exchange 复制分发路由 不需要routkey，当exchange收到消息后，将消息复制多份转发给与自己绑定的消息队列 topic exchange 通配路由 根据routing key，及通配规则，Topic exchange将分发到目标queue中。 可靠消息在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两个选项用来控制消息的投递可靠性模式。 消息传递路径为 producer-&gt;rabbitmq broker cluster-&gt;exchange-&gt;queue-&gt;consumer message 从 producer 到 rabbitmq broker cluster 则会返回一个 confirmCallback 开启配置（这边的思路是发送者发送完消息会在数据库中记录下消息id，状态，创建时间等信息，发送成功则confirmcallback并修改数据库表的信息，发送失败则通过定时任务进行重发） 常规配置 1234567891011121314@BeanQueue mailQueue()&#123; return new Queue(MailConstants.MAIL_QUEUE_NAME,true);&#125; @BeanDirectExchange directExchange()&#123; return new DirectExchange(MailConstants.MAIL_EXCHANGE_NAME,true,false);&#125; @BeanBinding binding()&#123; return BindingBuilder.bind(mailQueue()).to(directExchange()).with(MailConstants.MAIL_ROUTING_KEY_NAME);&#125; 1spring.rabbitmq.publisher-confirms=true 12345678910111213141516171819@BeanRabbitTemplate rabbitTemplate()&#123; RabbitTemplate rabbitTemplate=new RabbitTemplate(cachingConnectionFactory); //保证消息到broker rabbitTemplate.setConfirmCallback((data,ack,cause)-&gt;&#123; String msgId = data.getId(); if (ack)&#123; logger.info("发送成功"); mailSendLogService.updateMailSendLog(msgId,1); &#125;else &#123; logger.info("发送失败"); &#125; &#125;); //保证消息到queue rabbitTemplate.setReturnCallback((msg,repCode,repText,exchange,routingKey)-&gt;&#123; logger.info("发送失败"); &#125;); return rabbitTemplate;&#125; 123456789101112131415//0为初始值，10偏移量，第一位秒，分，小时，日，月，星期（1，2）@Scheduled(cron = "0/10 * * * * ?")public void reSend()&#123; List&lt;MailSendLog&gt;logs= mailSendLogService.getMailByStatus(); logs.forEach(mailSendLog -&gt; &#123; if (mailSendLog.getCount() &gt;= 3) &#123; //重发超过三次就失败，改数据库表的状态为2 mailSendLogService.updateMailSendLog(mailSendLog.getMsgId(),2); &#125;else&#123; mailSendLogService.updateMailCount(mailSendLog.getMsgId(),new Date()); Employee emp=employeeService.getEmployeeById(mailSendLog.getEmpId()); rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME,MailConstants.MAIL_ROUTING_KEY_NAME,emp,new CorrelationData(mailSendLog.getMsgId())); &#125; &#125;);&#125; message 从 exchange-&gt;queue 投递失败则会返回一个 returnCallback 1spring.rabbitmq.publisher-returns=true 1234//保证消息到queuerabbitTemplate.setReturnCallback((msg,repCode,repText,exchange,routingKey)-&gt;&#123; logger.info(&quot;发送失败&quot;);&#125;); 解决幂等性问题幂等性指的是消费者已经接受的消息，下次就不用再发了 例如消费者接收消息后在返回ack的过程中，出现了故障，此时可能队列那边又会重新发送一遍，这样就出现了重复消费 这里的思路是：消费者接收逻辑执行完后将消息的msgId存入redis中，发送channel.ack确认，下次如果有相同的消息即msgId一样就通过再channel.ack告诉消息中间件已经确认收到了，此时不需要在进行消费逻辑直接return结束 12spring.rabbitmq.listener.simple.acknowledge-mode=manualspring.rabbitmq.listener.simple.prefetch=100 123456789101112@SpringBootApplicationpublic class MailserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MailserverApplication.class, args); &#125; @Bean Queue queue()&#123; return new Queue("javaboy.mail") ; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536@RabbitListener(queues = "javaboy.mail") public void handler(Message message, Channel channel) throws IOException &#123; Employee employee = (Employee) message.getPayload(); MessageHeaders headers = message.getHeaders(); Long tag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG); String msgId = (String) headers.get("spring_returned_message_correlation"); if(redisTemplate.opsForHash().entries("mail_log").containsKey(msgId))&#123; logger.info("消息被消费"); channel.basicAck(tag,false); return; &#125; logger.info(employee.toString()); MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage); try &#123; mimeMessageHelper.setTo(employee.getEmail()); mimeMessageHelper.setFrom(mailProperties.getUsername()); mimeMessageHelper.setSubject("入职欢迎"); mimeMessageHelper.setSentDate(new Date()); Context context=new Context(); context.setVariable("name",employee.getName()); context.setVariable("posName",employee.getPosition().getName()); context.setVariable("joblevelName",employee.getJobLevel().getName()); context.setVariable("departmentName",employee.getDepartment().getName()); String mail = templateEngine.process("mail", context); mimeMessageHelper.setText(mail,true); javaMailSender.send(mimeMessage); redisTemplate.opsForHash().put("mail_log",msgId,"javaboy"); channel.basicAck(tag,false); logger.info(msgId+"邮件发送成功"); &#125; catch (MessagingException e) &#123; channel.basicNack(tag,false,true); e.printStackTrace(); logger.error("发送失败"+e.getMessage()); &#125; &#125; 参考链接 https://zhuanlan.zhihu.com/p/63700605 https://www.cnblogs.com/frankyou/p/5283539.html https://www.cnblogs.com/wangiqngpei557/p/9381478.html]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象内存]]></title>
    <url>%2F2020%2F06%2F16%2F%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[对象内存对象的内存布局对象的内存布局可分为3部分：对象头，对象实例数据和对齐填充（padding） 对象头又包括2部分信息 Mark Word：存储一些对象自身数据，比如哈希码，Gc分代年龄，锁状态等，一般64位虚拟机就占8字节，32位占4字节 对象类型数据（引用）：指向方法区的.class，确定这个对象是哪个类的实例 对象实例数据：包括成员变量等 对齐填充：可有可不有，满足是8字节的整数倍时为0，不满足时进行填充 对象访问两种方式 句柄访问：堆内划分出一块内存作为句柄，包括指向对象实例数据和对象类型数据的指针 直接访问 new Object()占多少字节普通对象和数组在内存布局是不一样的 对象头8字节 类型指针8字节，但一般开启了压缩为4字节 实例数据暂时没有，为0字节 此时一共12字节，需要填充4字节，所以一共占16字节 ps：如果关闭了压缩，则类型指针8字节，一共16字节，不需要填充 查看是否压缩指针通过java -XX:+PrintCommandLineFlags -version查看指向java命令时默认带着的参数 -XX:+UseCompressedClassPointers：这个就是指压缩了指针，64位jvm虚拟机默认指针是64位，压缩到4个字节 -XX:+UseCompressedOops：和上面的并不一样，它指的是例如一个对象内部有一个String成员变量指向了另一个对象，此时也会压缩，也是4个字节]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC]]></title>
    <url>%2F2020%2F06%2F16%2FGC%2F</url>
    <content type="text"><![CDATA[GC看这篇就够了什么是垃圾不再被使用的对象就是垃圾 怎么定位垃圾 引用计数算法（reference counting） 可对象增加一个引用计数器，每有一个地方引用它时，计数加1，引用失效就减一，归零就代表这个对象不被使用，作为垃圾清除 但是这种方式存在问题，解决不了循环依赖的情况。比如说a，b相互引用对方，而实际上两个对象都已经不再被使用了，但此时计数器依然为1，这样就无法垃圾收集器收集了 可达性分析 通过一系列GC Roots做为起点，从这些节点往下搜索，搜索走过的路径称为引用链，如果一个对象到GC Roots没有引用链则是垃圾 垃圾回收算法标记-清除先标记需要回收的对象，然后进行清除 问题：会造成内存碎片 复制将内存一分为二，每次只使用一半，当这一块使用完，将其中存活者的对象复制到另一块中去，然后把使用的内存空间进行清理。也就是每次只清理整个半区（实际情况不是对半分，后面再说） 优点：避免了碎片 缺点：每次只使用一半内存 标记-整理 标记还是一样，只是不直接对垃圾（可回收对象）进行回收，而是先整理，将存活对象移到一端，将端边界以外的内存进行清理 堆内存逻辑分区堆内存逻辑上分为新生代和老年代。新生代使用复制算法，老年代使用标记整理算法。 新生代又分为eden和survivor，每次使用eden和一个survivor，回收时将eden和survivor中存活的对象复制到另一个survivor中去，一个eden和一个survivor的比例为8：1，这样就只会有10%的内存被浪费 经过多次回收还存活的对象会进入到老年中去 垃圾收集器垃圾收集包括有Serial，ParNew，Parallel Scavenge，CMS等，通常组合使用，常用组合如下 SerialSerial收集器是一个单线程收集器，需要STW（stop the world），在进行垃圾回收的时候需要停掉正常工作的线程 新生代叫做Serial（使用复制算法），回收老年代时叫做Serial Old（使用标记整理算法） ParNew（和CMS组合）ParNew就是Serial收集器的多线程版本，多个线程进行垃圾回收 Parallel Scanvenge+Parallel Old（jdk默认的哦）同样需要stop the world，卡顿时间长，和ParNew差不多，看下面的-XX:+UseParallelGC CMS前面的都需要STW，卡顿时间较长，CMS的目标就是最短回收停顿时间 运行过程包括4个阶段 初始标记 这阶段标记的是GC roots后的第一个节点（没有标记全部），所以时间不长 并发标记 之前只标记了最接近GC Roots的结点，这个阶段沿着引用链标记其他的结点，不过是和其他工作线程一起进行的（之所以CMS卡顿时间短就在于并发标记，原来并发标记这一部分和初始标记一起的，卡顿时间就长，现在和其他线程一起进行，所以时间大大减少） 重新标记 并发标记时工作线程还是在运行的，还会产生垃圾或者引用的改变，所以需要重新标记。不过之前大部分垃圾已经找到了，重新标记的垃圾并不多，所以浪费的时间也不长 并发清除 清理垃圾，和其他工线程一起进行，也正因为其他工作线程还在干活，所以会产生浮动垃圾 CMS也存在问题 浮动垃圾，并发清理时会出现新的垃圾，只能下次回收 内存碎片化：CMS采用的是Mark-Sweep，这个算法上面讲了会产生很多的内存碎片，当碎片很多以至于从新生代来到老年代的存活对象都没放时，会进行Serial Old，即使用标记整理（Mark-Compact）来整理这些碎片，由于Serial Old是需要STW的，此时会非常卡]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis主从复制]]></title>
    <url>%2F2020%2F06%2F01%2Fredis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[单机redis存在问题 机器故障：单机redis出现故障会对业务造成毁灭性打击 容量瓶颈：需要不断升内存 将数据复制多个副本保存在不同的服务器上，链接在一起，并保证数据是否同步的，即使有其中一台服务器宕机，其他服务器依然可以继续提供服务 一个master可以拥有多个slave，一个slave只对应一个master 。主要分为3步：建立连接，同步数据，反复同步建立连接 主从复制搭建进入redis目录，分别建立（vim会直接新建文件）redis6379.conf，redis6380.conf， redis6381.conf 以redis6380.conf为例进行配置 一个配置完cp命令复制就行 12345include /opt/redis-5.0.9/redis.conf #拷贝redis目录下的redis配置文件port 6380pidfile /var/run/redis6380.confdbfilename dump6380.rdbslaveof 127.0.0.1 6379 配置完后，分别启动 通过命令查看进程 1ps -ef | grep redis 开启3个客户端，通过info replication查看信息 12redis-cli -h 127.0.0.1 6379 #6380/6381info replication #6379端口的的role:master 6380/6381 role:slave 分别set可以发现，主服务器可以读写，而从服务器只能读不能写 主从复制原理-建立连接指令就1条 1slaveof master_ip master_port 3种方式连接 发送命令 slaveof master_ip master_port 启动时使用参数--slaveof master_ip master_port （redis-cli -p xxxx –slaveof） 服务器配置 slaveof master_ip master_port （修改配置文件） 主从复制原理-数据同步 具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。 全量复制用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作 从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。 主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令 主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态 部分复制用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效 部分复制依赖于下面三个主要概念 复制偏移量 主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。 offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。 复制积压缓冲区 复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。 在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区 服务器运行ID(runid) 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制： 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)； 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制 主从复制原理-命令传播阶段 心跳机制master 通过ping指令看slave是否连接着，一般10秒一次 REPLCONF ACK从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量 检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区） 参考文档 https://www.cnblogs.com/kismetv/p/9236731.html]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层]]></title>
    <url>%2F2020%2F04%2F30%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[UDP协议传输层有两个协议：大哥TCP，二哥UDP，大哥可靠，二哥不可靠 UDP主要特点： 无连接，减少发送数据前的时延 使用最大努力交付，不可靠 面向报文，适合一次传送少量数据的应用 无拥塞控制，适合实时应用，如网络开会 TCP协议TCP连接 每一条TCP连接有两个端点，而这个端点叫做套接字。将端口号拼接到IP地址后面构成了套接字，例如192.3.4.5：80 每一个TCP连接唯一地被通信两端（即两个套接字）所确定。即： TCP连接::={socket1，socket2}={（IP1：port1），（IP2：port2）} TCP协议特点 面向连接 提供可靠交付服务 全双工通信 发送方，接收方都有缓存来存放数据 面向字节流 TCP报文首部 序号（seq）：TCP连接中传送的字节都有自己的编号，序号是本报文段发送数据的第一个字节的编号（发送端的） 确认号（ack）：对应序号，指接收端希望获得的下个报文段的第一个字节的编号（接收端） 六个控制位： URG（紧急位）：URG=1代表有紧急数据，不需要通过缓存，直接发送 ACK（确认位）：ACK=1代表确认位有效，和ack一般一起出场 SYN（同步位）：SYN=1表明这是一个请求/连接接收报文 FIN（中止位）：FIN=1表示发送端数据已经发送完，请求断开连接 检验位：检验首部+数据 TCP连接管理TCP连接传输分3个阶段：连接建立——发送数据——连接释放 TCP连接建立（3次握手） round1：发送方发送连接请求报文段，SYN=1，seq=x（随机） round2：接收方返回确认报文段，SYN=1，ACK=1，seq=y(随机)，ack=x+1 round3：服务器返回确认的确认，ACK=1，seq=x+1，ack=y+1 TCP连接释放（4次握手） round1：客户端发送连接释放报文，关闭TCP连接，FIN=1，seq=u round2：服务器端返回确认，ACK=1，seq=v，ack=u+1,此时处于半关闭状态 round3：服务器端发送连接释放报文，关闭TCP连接，FIN=1，ACK=1，seq=w，ack=u+1 round4：客户端返回确认报文段，结束 为什么建立连接要3次握手呢？假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销 TCP可靠传输网络层提供的是不可靠交付，所以需要在传输层提供可靠传输 可靠传输4个机制：检验（首部）-序号-确认-重传 序号 确认TCP默认使用累计重传 这里123到达TCP缓存后，456因为网络问题尚未到达，78也已经到达，此时接收端的报文段首部确认号字段依然为4 重传超时重传 TCP的发送端在规定时间内没有收到确认就要重传已发送的报文段 冗余重传 当收到比期望报文序号大的报文时，发送一个冗余ACK，指明下一个期待的序号 例如发送端已经发送12345报文 接收端收到1，返回1的确认 接收端收到3，返回1的确认 接收端收到4，任然返回1的确认 接收端收掉5，依旧返回1的确认 发送方收到3次冗余，知道2号报文丢失，重传报文 TCP流量控制流量控制：让发送方发送的慢点，好让接收方来得及接收 主要思路：让发送方知道自己的接受能力 TCP利用滑动窗口实现流量控制，发送窗口取决于接收窗口和拥塞窗口 当接收方发生了零窗口后一段时间，有了空间后通知发送方的报文丢失了，发送方一直等待接受方的非零窗口通知，接收方一直等待发送方发送数据，这就死锁了，怎么办呢？ TCP为每个连接设立一个持续计时器，只要发送方收到零窗口通知，就启动持续计时器，到时了就发送一个零窗口探测报文，询问能否发送数据，可以，接收方告诉此时窗口的大小；不可以，就刷新计时器 TCP拥塞控制拥塞原因：对资源的需求总和大于可用资源 拥塞控制和流量控制的区别可用理解为目标停车场停不下了和路上堵车的区别 拥塞控制是为了防止过多的包注入网络，造成网络负载过大，网络拥塞的情况 解决办法： 慢开始 拥塞避免 快重传 快恢复 慢开始就是在tcp连接刚建立时，一点点增加拥塞窗口cwnd的值，试探网络的承受能力 慢开始算法 连接刚建立时，cwnd初始化为1 每收到一个ACK，cwnd+1 每经过一个往返延迟时间，cwnd就X2 达到阈值，进入拥塞避免算法 拥塞避免算法 每收到一个ACK，窗口+1 每当过了一个RTT，cwnd加1 一般来说TCP默认认为网络丢包是网络出现拥塞导致的，所以以丢包作为网络出现拥塞的信号； 而丢包有2种判定方式 超时重传，发送一个数据后就启动超时计数器，一定时间内没用收到ACK，就重发 收到3个重复ACK报文 之前的TCP算法认为一旦丢包，问题非常严重，直接从头开始，会让网络不太稳定 优化后的TCP算法，使用了快重传和快恢复 快重传算法发送端收到3个ACK报文后就可断定报文丢失了，此时立即重传丢失的报文而不用等重传计时器 快恢复算法 接收端收到3个重复确认后进行乘法减小，即让新的阈值等于门限的一半，以防止网络拥塞 让cwnd也为门限的一半，开始进行拥塞避免]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F2020%2F04%2F28%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[IP数据报格式 版本：IPv4/IPv6 首部长度：单位为4B，最少为5（毕竟首部固定部分就有20B） 总长度：首部+数据(链路层有最小和最大长度) 标识：同一个数据报分片用同一个标识 标志：3位，只有2位有效 ，中间位DF=1，禁止分片，=0允许分片，最低位MF=1，后面还有分片，=0最后一个分片 片偏移：某片在原分组的位置 生存时间：每经过一个路由器TTL-1 首部检验和：只检验首部，因为首部中的标志，片偏移等是会变的 IPv4像每个人都有身份证，IP地址可以唯一标识一个路由器，主机的接口 分类的IP地址 A，B，C类地址网络号中依次有1位，2位，3位用来标识，网络号依次占8，16，24位 网络地址转换NAT路由器对目的地址是私有IP地址的数据报一律不转发 网络地址转换NAT在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫做NAT路由器，它至少有一个外部全球Ip地址 这里专用网192.168.0.0下的主机要和互联网进行数据交换，就需要用NAT路由器的IP地址作为一个代表。具体实现就依靠NAT转换表 子网划分和子网掩码分类的IP地址存在问题：比如一个单位申请了一个B类IP，但是实际在用的并不多，会造成资源浪费问题。划分子网还能提高灵活性，比如一个单位要新开一个部门，没划分子网的话得重新去申请一个IP 子网划分 划分子网后对外仍表现为一个网络 子网掩码路由器需要根据收到的IP找到相应子网 除了主机号其余为0，通过IP地址与子网掩码进行与操作，就能得到子网网络地址 无分类编址CIDR以前的一个子网的子网掩码是一样的，如果子网掩码不固定长度，那子网下的主机数更灵活（比如如果部门人比较多，那就可以让子网掩码短一点，这样主机数可以更多） 网络前缀相同的组成一个网络块 128.14.35.7/20一个地址块的IP地址 最小IP地址10000000 00001110 00100000 00000000 最大IP地址10000000 00001110 00101111 11111111 子网掩码 11111111 11111111 11110000 00000000 ARP协议在实际网络的链路上传输数据帧时，最终必须使用mac地址，如下图的mac6，但是你可能不知道mac6是什么，这就需要arp了 ARP协议可以完成主机或路由器IP地址到mac地址的映射 基本过程：检查ARP高速缓存（高速缓存保存的是局域网内的IP与mac地址映射），有对应表项就写入mac地址（目标地址在一个局域网），没有则用FF-FF-FF-FF-FF-FF代替（目标地址不在局域网）。封装成帧后广播ARP分组，局域网内都能收到。目的主机收到后会单播一个响应分组，源主机收到后将此写入ARP高速缓存 例子 应用层发送一个pdf文件，传输层分成123，对123分为加首部（如果123长度过大，还要分片） 主机1发送文件到主机5，先让IP5与子网掩码与以下看一下在不在一个局域网内，在1所在局域网广播一个ARP请求分组，因为5不在同一个局域网，所以局域网会单播一个分组回来，此时对应的mac地址为mac6，在数据链路层传输后到达路由器，解封装，再封装（路由器只有3层，最高到网络层），封装后源mac地址为mac7，目标mac为mac8，同理到mac9直至最高的主机5IP. ICMP协议（网际控制报文协议）目的：进行差错报告 类型：ICMP报文有不同类型 检验和：检查发过来的IP数据报的首部和数据部分，区别于IP地址的首部检验和 ICMP报文是作为返回的IP数据报的数据部分 ICMP差错报告报文的数据部分由收到的IP数据报的首部+IP数据报数据部分前8个字节组成 IPv6IPv6格式 与IPv4区别 IPv4 32位，IPv6 128位 IPv4总长度取消，改为有效载荷长度 IPv4生存时间取消，改为下一个首部 IPv4首部长度是4B倍数，IPv6基本单位必须是40B IPv4路由器和主机均可分片，IPv6只能主机分片 RIP协议RIP是一种基于距离向量的协议，每一个路由器都维护到每一个目的网络的最短距离 特点： 只和相邻路由器交换信息 交换的信息是自己的路由表 每30秒交换一次路由表 一条路由最多包含15个路由器，距离为16代表不可达，所以适合小型网络 基本过程： 对相邻路由器x发来的RIP报文，修改报文每一项，把下一跳地址改为x，距离+1 如果R1没有目标为net3的表项，则把修改完的表项插入 有net3，如果下一跳为x，则进行更新（毕竟30秒交换一次，保持最新的）；如果下一跳不为x，则比较距离，挑小的]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层]]></title>
    <url>%2F2020%2F04%2F24%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[数据链路层作用将网络层的IP数据包封装成帧，可靠的传输到相邻结点的目标机网络层。用 MAC 地址访问媒介，并进行错误检测与修正 封装成帧与透明传输封装成帧就是在IP数据报前后添加首部和尾部，构成一个帧。首部和尾部往往包含多个控制信息，它们有一个很重要的作用：帧定界 透明传输：不管传输的数据是怎么样的比特组合，都应当可以在链路上传输。 问题来了：当所传数据中的比特组合和控制信息完全一样时，必须采取措施，使接收方不会以为这就是控制信息，保证透明传输。 字符计数法帧首部使用一个计数字段（第一个字符）来表明帧内字符数 缺陷：例如第一个字符5出错了变成了4，那后面到3结束，第二个帧从4开始，即一步错步步错，一锅端了 字符填充法这里开始的SOH和结尾的EOT为帧的首尾。发送时添加转义字符ESC，接受时再去掉ESC即可。注意这里的SOH，EOT和ESC均为8位的二进制数，例如10010010等。 零比特填充法这里的首部和尾部是一样的，字符填充不一定一样。 发送时如果有连续5个1，就在后面加一个0，这样就保证首尾（因为有6个1）不会和数据报中有一样的 接受时遇到5个连续的1再去掉后面的0 违规编码法曼彻斯特法只会出现”高-低”，”低-高“，因而可以用”高-高“，”低-低“来作为帧的开始或结尾 总结计数填充计数字段脆弱（容易出现灾难性后果），字符填充复杂和不兼容性，普遍使用的是零比特填充和曼彻斯特编码 差错控制差错是由传输过程中的噪声产生的 全局性：线路电气特性产生的随机噪声 局部性：外界造成的短暂噪声 链路层如图所示，如果出错没有控制，那从路由器中一直传，资源浪费严重 检错控制奇偶校验码 但是存在问题 这一题，1100101采用奇校验，则需要前面加个1，5个1，A，B，C都是4个1，说明出错了，D5个1就看不出来，不一定出错。缺陷：只能检验出一半错误 CRC循环冗余码最终发送的数据=要发送的数据+冗余码 加0，生成多项式的阶数 求余 接收端同样需要除以多项式，余数为0，则正确，不为0，则错误 纠错控制海明码（太牛批了） 1.确定校验码位数 假设要发送的数据101101，数据位数6，对应校验位4位 2.确定校验码位置 3.求出校验码的值 例如P1⊕D1⊕D2⊕D4⊕D5=0，得到P1=0，规则：就是看位，P1看第一位为1，对应的D1,D2,D4,D5第一位为1；P2看第二位，对应有D1,D3,D4,D6 最终101101的海明码0010011101 4.检错并纠错 D2出错，接收方进行异或操作，例如P1⊕D1⊕D2⊕D4⊕D5=0，得到二进制序列0101为5，得到错误的位数 链路层设备mac地址计算机与外界局域网的连接是通过通信适配器，适配器上有处理器和存储器（ROM,RAM）,RAM上有mac地址（物理地址） 帧格式数据46-1500字节 物理层扩展以太网 链路层扩展以太网主要是网桥和交换机 网桥 网桥根据mac帧的目标地址进行转发，当网桥收到帧时，并不向所有接口转发，而是根据目标mac地址确定转发到哪个接口（转发表） 交换机–多接口网桥 冲突域和广播域冲突域：域内每一个结点都能收到发送的帧，冲突域内相互交互会引起冲突，比如ab打电话同时讲话不就听不清了。 广播域：发一个消息大家伙都能听见（老师在教室讲话所有人都能听见），交换机可以隔离冲突域 交换机每一个端口就是一个冲突域]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@import组件注册]]></title>
    <url>%2F2020%2F04%2F09%2Fimport%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[给容器中注册组件主要有以下几种方式 包扫描+组件标注注解（@Component、@Service、@Controller、@Repository），主要是自己写的类 @Bean，导入的第三方包里面的组件 @Import，快速给容器中导入一个组件 今天就来具体聊聊@Import注解，这个注解有3三种使用方式 Import(类名)12345@Configuration@Import(&#123;Color.class&#125;)public class myConfig &#123; &#125; 编写测试类测试一下 12345678910111213141516public class myTest &#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(myConfig.class); @Test public void testImport()&#123; printBeans(annotationConfigApplicationContext); &#125; private void printBeans(AnnotationConfigApplicationContext annotationConfigApplicationContext)&#123; String[] beanDefinitionNames = annotationConfigApplicationContext.getBeanDefinitionNames(); for(String name:beanDefinitionNames)&#123; System.out.println(name); &#125; &#125;&#125; 测试结果可以看到person已经注入容器中去 ImportSelector：返回需要导入的组件的全类名的数组通过 import 一个实现了 ImportSelector 接口的类来注册组件，ImportSelector 返回要注册的组件全类名，这种方式也是springboot自动配置所采用的方式 12345@Configuration@Import(&#123;Color.class,MyImportSelector.class&#125;)public class myConfig &#123;&#125; 12345public class MyImportSelector implements ImportSelector &#123; public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; return new String[]&#123;&quot;com.xjh.model.Blue&quot;,&quot;import com.xjh.model.Yellow;&quot;&#125;; &#125;&#125; 同样进行测试，测试结果表明Blue和Yellow也都注入了容器 ImportBeanDefinitionRegistrar：手动注册bean实现 ImportBeanDefinitionRegistrar 接口，调用 registerBeanDefinition 注册 123456789public class MyImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar &#123; //BeanDefinitionRegistry组件注册类，把要添加到容器的bean手动通过beanDefinitionRegistry.registerBeanDefinition手动注册进来 public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; //组件bean定义信息，包括bean类型。。。 RootBeanDefinition beanDefinition = new RootBeanDefinition(car.class); //注册组件，car为组件名 beanDefinitionRegistry.registerBeanDefinition(&quot;car&quot;,beanDefinition); &#125;&#125; 12345@Configuration@Import(&#123;Color.class,MyImportSelector.class, MyImportBeanDefinitionRegister.class&#125;)public class myConfig &#123;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot自动配置]]></title>
    <url>%2F2020%2F04%2F08%2Fspringboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[springboot 的自动配置主要靠的是应用启动类的@SpringBootApplication注解，今天我们就来探秘这个注解的背后都是些啥! 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 可以看到最为重要的是 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解，下面依次来看看其中的作用 @SpringBootConfiguration看源码 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; @SpringBootConfiguration源于 @ Configuration ，用来将当前类标注为注解类， 并以 @Bean 注解标记的方法的实例注入到spring容器中，实例名即为方法名。 @EnableAutoConfiguration继续看代码 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; @Import(AutoConfigurationImportSelector.class)，import 有三种注入方式，可以看下import组件注册篇博客，这里用的是ImportSelector接口这种方式 1234567891011@Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125; 发现通过实现selectImports方法可以将Configuration导出，我们来看看其中的 getAutoConfigurationEntry 方法 发现通过调用 getCandidateConfigurations 方法可以得到配置的一个集合，那我们继续看其中的源码 现在看出是调用了 SpringFactoriesLoader 的 loadFactoryNames 方法来读取 ClassPath 下面的 META-INF/spring.factories 文件来获取所有导出类 ，打个断点具体瞧瞧 再来看看 spring.factories 文件，其实里面的配置以键值对的形式存在 总结来说就是从 ClassPath 下扫描所有的 META-INF/spring.factories 配置文件，并将 spring.factories 文件中的 EnableAutoConfiguration 对应的配置项通过反射机制实例化为对应标注了 @Configuration 的形式的 IoC 容器配置类，然后注入 IoC 容器。 @ComponentScan@ComponentScan 可以将带有指定注解的类自动装配到bean容器里。会被自动装配的注解包括@Controller、@Service、@Component、@Repository等等]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何安全删除集合元素]]></title>
    <url>%2F2020%2F04%2F04%2F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[删除集合的元素，如果采用下面的方法，可以吗 1234567891011121314public class deleteElement &#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList(); list.add(&quot;小明&quot;); list.add(&quot;小李&quot;); list.add(&quot;小红&quot;); list.add(&quot;小王&quot;); for (String s:list)&#123; if (s.equals(&quot;小李&quot;))&#123; list.remove(s); &#125; &#125; &#125;&#125; 运行时异常 为什么呢？ 增强for循环本质上也是通过迭代器实现的 arraylist等集合都已经实现了Iterator接口，那我们来看看其中的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; arraylist通过size属性来维护状态，而Iterator是通过 cursor 来维护状态。当你使用集合的remove删除元素时，迭代器的cursor并不能同步更新，从而报错，只有采用迭代的remove方法使元素列表发生变化时，它会更新cursor来同步这一变化。 为了防止状态不一致可能引发的无法设想的后果，Iterator会经常做checkForComodification检查，以防有变。 当然你可以采用遍历集合的方式来删，但并不推荐 123456for(int i=0;i&lt;list.size();i++)&#123; String s = list.get(i); if (s.equals(&quot;小李&quot;))&#123; list.remove(s); &#125;&#125; 正确姿势 1234567891011121314151617public class deleteElement &#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList(); list.add(&quot;小明&quot;); list.add(&quot;小李&quot;); list.add(&quot;小红&quot;); list.add(&quot;小王&quot;); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; String s = iterator.next(); if (s.equals(&quot;小李&quot;))&#123; iterator.remove(); &#125; &#125; System.out.println(list); &#125;&#125; 1[小明, 小红, 小王]]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞清内存分配]]></title>
    <url>%2F2019%2F12%2F05%2F%E6%90%9E%E6%B8%85%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[java中的内存划分java的内存分为5个部分 栈（Stack）：存放的都是方法的局部变量，方法的运行也是在栈中 堆（Heap）：凡是new出来的东西都在堆中，堆里面的东西都有一个地址值，堆内存里的数据都有默认值 方法区（Method Area）：存储.class相关信息，包含方法的信息 本地方法栈：与操作系统相关 寄存器：与cpu相关 数组的内存图数组属于引用变量，array[0]是通过地址值找到new 出的数组，访问对应索引得到的 对象的内存图 栈中遵循先进后出的原则 方法的执行是在栈中 成员方法在堆中存放的是地址值，指向方法区中的方法 字符串的常量池字符串内存图 底层都是通过btye[]实现的 str1和str2的地址值都是指向常量池中的字符串对象，是相同的 str3通过new的方式。会在堆中创建一个字符串对象，是不同的对象，这也是通过构造函数和通过new方式创建字符串对象的区别 String类的构造方法创建对象的3种方式构造方法创建有3种形式 public String() ：初始化新创建的 String对象，以使其表示空字符序列 public String(char[] value) ：通过当前参数中的字符数组来构造新的String public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String 12345String s1=new String(&quot;abc&quot;);char[] chars=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;String s2=new String(chars);byte[] bytes=&#123;97,98,99&#125;;String s3=new String(bytes); static的内存图static修饰的内容： 是随着类的加载而加载的，且只加载一次 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用 它优先于对象存在，所以，可以被所有对象共享]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashcode和equals]]></title>
    <url>%2F2019%2F11%2F22%2Fhashcode%E5%92%8Cequals%2F</url>
    <content type="text"><![CDATA[一道常问面试题你重写过hashcode方法吗？答：没有 你在用hashMap的时候，key的部分用过自定义对象吗？答：有 这其实就自相矛盾了 hash算法回顾 hash在查找上效率很高，通过设计合适的hash函数，很多时候一下就能找到，例如6在如下hash表中直接定位到1的位置 就算发生冲突，也可用链地址法加以解决 重写hashcode以及equals的必要性2个基础知识： HashMap在存数据时，要先计算key类的hashcode方法返回hash值，默认使用Object的hashcode方法，返回对象地址 如果自定义类不重写equals方法，默认会调用Object的equals方法，通过对象地址进行比较 看下面的代码 1234567891011121314151617181920212223242526272829303132333435public class Key &#123; private Integer id; public Integer getKey()&#123; return id; &#125; Key(Integer id)&#123; this.id=id; &#125;/* public int hashCode()&#123; return id.hashCode(); &#125; public boolean equals(Object o)&#123; if (o==null)&#123; return false; &#125;else &#123; return this.getKey().equals(((Key)o).getKey()); &#125; &#125;*/&#125;public class Judge &#123; public static void main(String[] args) &#123; Key key1 = new Key(1); Key key2 = new Key(1); HashMap&lt;Key, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(key1, &quot;我的id是1&quot;); String value = hashMap.get(key2); System.out.println(value); &#125;&#125; 在注释掉hashcode和equals方法后输出为null，即取不出key2的值，为啥呢？ 在put时，会调用key1的默认hashcode方法，返回的是key1的地址，get的时候也会调用key2的hashcode方法，按照key2的地址进行查询，可能key1的地址1000，key2的地址为2000，也就自然查不到了 那接下来把hashcode的注释取消掉，结果还是null，为啥呢？ 现在重写了之后，get的时候都是按照id的hashcode来查，都是一样的，但是只是按照相同的hash值来找，找到对应位置后可能有很多对象在一条链上，毕竟是会有冲突的可能，get（key2），可事实上key2并没有存入map，只有key1，我们的本意是key1和key2的value值是一样的，通过key2也能拿到value值，现在的问题出在了key1和key2默认的equals的比较的是对象地址，并不一样。 所以我们重写equals方法，只要id值一样，我们就算他们一样，这样key1和key2对象实际上就是相等的，通过hash值找到对应位置，再通过key2对象，就拿到了我们需要的值 参考参考了羊哥的博客，欢迎关注codesheep公众号，一个很nice的b站up主]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化流]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream("employee.txt");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 12345678910111213141516171819202122232425262728293031323334 public class Person implements Serializable &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 1234567 public class xuliehua1 &#123; public static void main(String[] args) throws IOException &#123; Person person=new Person("小李",18); ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream("F:\\test\\test1\\a.txt")); objectOutputStream.writeObject(person); &#125;&#125; ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678 public class xuliehua2 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream("F:\\test\\test1\\a.txt")); Object o=objectInputStream.readObject(); System.out.println(o); &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 transient关键字transient关键字叫瞬态关键字，被该关键字修饰的变量无法被序列化 SerialVersionUID另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 手动加入序列版本号，声明为常量 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println("Address check : " + name + " -- " + address); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化-索引]]></title>
    <url>%2F2019%2F11%2F16%2Fmysql%E4%BC%98%E5%8C%96-%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[单表优化12345678910111213CREATE TABLE book( bid INT(4) PRIMARY KEY, NAME VARCHAR(20) NOT NULL, authorid INT(4) NOT NULL, publicid INT(4) NOT NULL, typeid INT(4) NOT NULL );INSERT INTO book VALUES(1,&apos;tjava&apos;,1,1,2) ;INSERT INTO book VALUES(2,&apos;tc&apos;,2,1,2) ;INSERT INTO book VALUES(3,&apos;wx&apos;,3,2,1) ;INSERT INTO book VALUES(4,&apos;math&apos;,4,2,3) ; 查询authorid=1且 typeid为2或3的bid 1EXPLAIN SELECT bid FROM book WHERE typeid IN(2,3) AND authorid=1 ORDER BY typeid 优化：加索引 1ALTER TABLE book ADD INDEX idx_bta (bid,typeid,authorid) 索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。 1DROP INDEX idx_bta ON book 根据SQL实际解析的顺序，调整索引的顺序alter table book add index idx_tab (typeid,authorid,bid); –虽然可以回表查询bid，但是将bid放到索引中可以提升使用using index ; 总结 a.最佳左前缀，保持索引的定义和使用的顺序一致性 b.索引需要逐步优化 c.将含In的范围查询 放到where条件的最后，防止失效。 本例中同时出现了Using where（需要回原表）; Using index（不需要回原表）：原因，where authorid=1 and typeid in(2,3)中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）；而typeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有typeid这个索引，所以需要回原表（using where）； 例如以下没有了In，则不会出现using where explain select bid from book where authorid=1 and typeid =3 order by typeid desc ; 还可以通过key_len证明In可以使索引失效。两表优化12345678910111213141516171819CREATE TABLE teacher2( tid INT(4) PRIMARY KEY, cid INT(4) NOT NULL);INSERT INTO teacher2 VALUES(1,2);INSERT INTO teacher2 VALUES(2,1);INSERT INTO teacher2 VALUES(3,3);CREATE TABLE course2( cid INT(4) , cname VARCHAR(20));INSERT INTO course2 VALUES(1,&apos;java&apos;);INSERT INTO course2 VALUES(2,&apos;python&apos;);INSERT INTO course2 VALUES(3,&apos;kotlin&apos;); 左连接： 1EXPLAIN SELECT *FROM teacher2 t LEFT OUTER JOIN course2 c ON t.cid=c.cid WHERE c.cname=&apos;java&apos;; 索引往哪张表加？ 小表驱动大表 索引建立经常使用的字段上 本题 t.cid=c.cid可知，t.cid字段使用频繁，因此给该字段加索引 [一般情况对于左外连接，给左表加索引；右外连接，给右表加索引] select ...where 小表.x10=大表.x300 ; for(int i=0;i&lt;小表.length10;i++) { for(int j=0;j&lt;大表.length300;j++) { ... } } select ...where 大表.x300=小表.x10 ; for(int i=0;i&lt;大表.length300;i++) { for(int j=0;j&lt;小表.length10;j++) { ... } }–以上2个FOR循环，最终都会循环3000次；但是 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内存。 --当编写 ..on t.cid=c.cid 时，将数据量小的表 放左边（假设此时t表数据量小） alter table teacher2 add index index_teacher2_cid(cid) ; alter table course2 add index index_course2_cname(cname); Using join buffer:extra中的一个选项，作用：Mysql引擎使用了 连接缓存。三张表优化A B Ca.小表驱动大表 b.索引建立在经常查询的字段上 示例： 123456789CREATE TABLE test03( a1 INT(4) NOT NULL, a2 INT(4) NOT NULL, a3 INT(4) NOT NULL, a4 INT(4) NOT NULL);ALTER TABLE test03 ADD INDEX idx_a1_a2_a3_4(a1,a2,a3,a4) 1explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a3=3 and a4 =4 ; --推荐写法，因为 索引的使用顺序（where后面的顺序） 和 复合索引的顺序一致 12explain select a1,a2,a3,a4 from test03 where a4=1 and a3=2 and a2=3 and a1 =4 ; --虽然编写的顺序 和索引顺序不一致，但是 sql在真正执行前 经过了SQL优化器的调整，结果与上条SQL是一致的。--以上 2个SQL，使用了 全部的复合索引 12explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a4=4 order by a3; --以上SQL用到了a1 a2两个索引，该两个字段 不需要回表查询using index ;而a4因为跨列使用，造成了该索引失效，需要回表查询 因此是using where 12explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3; --以上SQL出现了 using filesort(文件内排序，“多了一次额外的查找/排序”) ：不要跨列使用( where和order by 拼起来，不要跨列使用) explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a2 , a3; --不会using filesort总结 如果 (a,b,c,d)复合索引 和使用的顺序全部一致(且不跨列使用)，则复合索引全部使用。如果部分一致(且不跨列使用)，则使用部分索引 where和order by 拼起来，不要跨列使用 避免索引失效的一些原则 复合索引复合索引，不要跨列或无序使用（最佳左前缀原则）复合索引，尽量使用全索引匹配 不要在索引上进行任何操作（计算、函数、类型转换），否则索引失效 123456789101112131415161718CREATE TABLE book ( bid INT(4) PRIMARY KEY, NAME VARCHAR(20) NOT NULL, authorid INT(4) NOT NULL, publicid INT(4) NOT NULL, typeid INT(4) NOT NULL ); INSERT INTO book VALUES(1,&apos;tjava&apos;,1,1,2) ; INSERT INTO book VALUES(2,&apos;tc&apos;,2,1,2) ; INSERT INTO book VALUES(3,&apos;wx&apos;,3,2,1) ; INSERT INTO book VALUES(4,&apos;math&apos;,4,2,3) ; SELECT *FROM book ALTER TABLE book ADD INDEX index_fuhe(authorid,typeid) EXPLAIN SELECT *FROM book WHERE authorid=1 AND typeid=2 --用到了2个索引 EXPLAIN SELECT *FROM book WHERE authorid=1 AND typeid*2=2--用到了a1个索引 EXPLAIN SELECT *FROM book WHERE authorid*2=1 AND typeid*2=2--到了0个索引,原因：对于复合索引，如果左边失效，右侧全部失效。(a,b,c)，例如如果 b失效，则b c同时失效 复合索引不能使用不等于（!= &lt;&gt;）或is null (is not null)，否则自身以及右侧所有全部失效。复合索引中如果有&gt;，则自身和右侧索引全部失效。 尽量使用索引覆盖（using index） select a,b,c from xx..where a= .. and b =.. ; like尽量以“常量”开头，不要以’%’开头，否则索引失效 1234567select * from xx where name like &apos;%x%&apos; ; --name索引失效explain select * from teacher where tname like &apos;%x%&apos;; --tname索引失效explain select * from teacher where tname like &apos;x%&apos;; explain select tname from teacher where tname like &apos;%x%&apos;; --如果必须使用like &apos;%x%&apos;进行模糊查询，可以使用索引覆盖 挽救一部分。 尽量不要使用类型转换（显示、隐式），否则索引失效 explain select * from teacher where tname =’’ or tcid &gt;1 ; –将or左侧的tname 失效 尽量不要使用or，否则索引失效 explain select * from teacher where tname =’’ or tcid &gt;1 ; –将or左侧的tname 失效 explain select * from book where authorid = 1 and typeid =2 ; – SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。 explain select * from book where authorid != 1 and typeid =2 ; explain select * from book where authorid != 1 and typeid !=2 ; 体验概率情况(&lt; &gt; =)：原因是服务层中有SQL优化器，可能会影响我们的优化。 drop index idx_typeid on book; drop index idx_authroid on book; alter table book add index idx_book_at (authorid,typeid); explain select * from book where authorid = 1 and typeid =2 ;–复合索引at全部使用 explain select * from book where authorid &gt; 1 and typeid =2 ; –复合索引中如果有&gt;，则自身和右侧索引全部失效。 explain select * from book where authorid = 1 and typeid &gt;2 ;–复合索引at全部使用 —-明显的概率问题— explain select * from book where authorid &lt; 1 and typeid =2 ;–复合索引at只用到了1个索引 explain select * from book where authorid &lt; 4 and typeid =2 ;–复合索引全部失效 –我们学习索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因 该结论不是100%正确。 –一般而言， 范围查询（&gt; &lt; in），之后的索引失效。 一些其他的优化方法 exist和in select ..from table where 字段 exist (子查询) ;select ..from table where 字段 in (子查询) ; 如果主查询的数据集大，则使用in ,效率高。如果子查询的数据集大，则使用exist,效率高。 exist语法： 将主查询的结果，放到子查需结果中进行条件校验（看子查询是否有数据，如果有数据 则校验成功)，如果复合校验，则保留数据。 12select tname from teacher where exists (select * from teacher) ; --等价于select tname from teacher order by 优化 使用oder by过程中会出现using filesort（额外依次排序） 底层有两种算法：双路排序、单路排序 （根据IO的次数） MySQL4.1之前 默认使用 双路排序；双路：扫描2次磁盘（1：从磁盘读取排序字段 ,对排序字段进行排序（在buffer中进行的排序） 2：扫描其他字段 也就是一次扫要排序的字段，一次扫要找的字段 MySQL4.1之后 默认使用 单路排序 ： 只读取一次（将所有字段放入buffer扫描） 存在隐患：如果数据量很大，buffer中可能放不下，此时会进行分片读取，分多次读取 单路排序比双路排序会占用更多的buffer set max_length_for_sort_data可设置buffer大小，如果max_length_for_sort_data值太低，则mysql会自动从 单路-&gt;双路 （太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数） 提高order by策略： a.选择使用单路、双路 ；调整buffer的容量大小；b.避免select * …c.复合索引不要跨列使用 ，避免using filesortd.保证全部的排序字段 排序的一致性（都是升序 或 降序）]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化-锁]]></title>
    <url>%2F2019%2F11%2F15%2Fmysql%E4%BC%98%E5%8C%96-%E9%94%81%2F</url>
    <content type="text"><![CDATA[目标解决因资源共享 而造成的并发问题。 示例 买最后一件衣服X A: X 买 ： X加锁 -&gt;试衣服…下单..付款..打包 -&gt;X解锁 B: X 买：发现X已被加锁，等待X解锁， X已售空 分类操作类型 读锁（共享锁）： 对同一个数据（衣服），多个读操作可以同时进行，互不干扰 写锁（互斥锁）： 如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作、写操作 操作范围 表锁 一次性对一张表整体加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低 行锁 一次性对一条数据加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题） 页锁 示例（表锁）表锁 ： –自增操作 MYSQL/SQLSERVER 支持；oracle需要借助于序列来实现自增 12345678910CREATE TABLE tablelock(id INT PRIMARY KEY AUTO_INCREMENT ,NAME VARCHAR(20));INSERT INTO tablelock(NAME) VALUES(&quot;a1&quot;)INSERT INTO tablelock(NAME) VALUES(&apos;a2&apos;);INSERT INTO tablelock(NAME) VALUES(&apos;a3&apos;);INSERT INTO tablelock(NAME) VALUES(&apos;a4&apos;);INSERT INTO tablelock(NAME) VALUES(&apos;a5&apos;); 加读锁123LOCK TABLE tablelock READSELECT *FROM tablelock --读（查），可以UPDATE tablelock SET NAME=&quot;a6&quot; WHERE id=1 --写（增删改），不可以 12SELECT *FROM USERDELETE FROM USER WHERE id=1 结论1： 如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作； 且 该会话不能对其他表进行读、写操作。 即如果给A表加了读锁，则当前会话只能对A表进行读操作 12345会话1select * from tablelock --读（查），可以delete from tablelock where id =1 --写，会“等待”会话0将锁释放SELECT *FROM USER --读（查），可以DELETE FROM USER WHERE id=1 --写，可以 结论2 会话0给A表加了锁；其他会话的操作 可以对其他表（A表以外的表）进行读、写操作 对A表：读-可以； 写-需要等待释放锁 1释放锁: unlock tables 加写锁12会话0： lock table tablelock write ; 结论 当前会话（会话0） 可以对加了写锁的表 进行任何操作（增删改查）；但是不能 操作（增删改查）其他表 其他会话 对会话0中加写锁的表 可以进行增删改查的前提是：等待会话0释放写锁 MySQL表级锁的锁模式MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（DML）前，会自动给涉及的表加写锁。 所以对MyISAM表进行操作，会有以下情况： 对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。 对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。 分析表锁定：查看哪些表加了锁： show open tables 1代表被加了锁分析表锁定的严重程度： show status like ‘table%’ Table_locks_immediate :即可能获取到的锁数 Table_locks_waited：需要等待的表锁数(如果该值越大，说明存在越大的锁竞争） 一般建议： Table_locks_immediate/Table_locks_waited &gt; 5000， 建议采用InnoDB引擎，否则MyISAM引擎 示例（行锁）123456789CREATE TABLE linelock(id INT(5) PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20))ENGINE=INNODB ;INSERT INTO linelock(NAME) VALUES(&apos;1&apos;) ;INSERT INTO linelock(NAME) VALUES(&apos;2&apos;) ;INSERT INTO linelock(NAME) VALUES(&apos;3&apos;) ;INSERT INTO linelock(NAME) VALUES(&apos;4&apos;) ;INSERT INTO linelock(NAME) VALUES(&apos;5&apos;) ; *mysql默认自动commit; oracle默认不会自动commit * 为了研究行锁，暂时将自动commit关闭; set autocommit =0 ; 以后需要通过commit 12345会话0： 写操作 insert into linelock values(&apos;a6&apos;) ; 会话1： 写操作 同样的数据 update linelock set name=&apos;ax&apos; where id = 6; 结论1 如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务(commit/rollback)后 才能对数据a进行操作 补充：表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁 行锁，操作不同数据： 会话0： 写操作 insert into linelock values(8,&apos;a8&apos;) ; 会话1： 写操作， 不同的数据 update linelock set name=&apos;ax&apos; where id = 5;结论2 行锁，一次锁一行数据；因此 如果操作的是不同数据，则不干扰 行锁的注意事项： 如果没有索引，则行锁会转为表锁 这里第二次会话使用了3，4，发生类型转换，会使索引失效，行锁转成表锁 12345678910111213会话0： 写操作 update linelock set name = &apos;ai&apos; where name = &apos;3&apos; ; 会话1： 写操作， 不同的数据 update linelock set name = &apos;aiX&apos; where name = &apos;4&apos; ;会话0： 写操作 update linelock set name = &apos;ai&apos; where name = 3 ; 会话1： 写操作， 不同的数据 update linelock set name = &apos;aiX&apos; where name = 4 ;--可以发现，数据被阻塞了（加锁）-- 原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。 行锁的一种特殊情况：间隙锁：值在范围内，但却不存在 此时linelock表中 没有id=7的数据update linelock set name =’x’ where id &gt;1 and id&lt;9 ; –即在此where范围中，没有id=7的数据，则id=7的数据成为间隙。间隙：Mysql会自动给 间隙 加索 -&gt;间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。行锁：如果有where，则实际加锁的范围 就是where后面的范围（不是实际的值） 行锁：InnoDB默认采用行锁； 缺点： 比表锁性能损耗大。 优点：并发能力强，效率高。因此建议，高并发用InnoDB，否则用MyISAM。 ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换流]]></title>
    <url>%2F2019%2F11%2F14%2F%E8%BD%AC%E6%8D%A2%E6%B5%81%2F</url>
    <content type="text"><![CDATA[编码引出的问题GBK 一个字符 2个字节 UTF-8 一个字符 3个字节 在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader("E:\\File_GBK.txt"); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 转换流原理图知识点：字符流本质上也是用的字节流，只是在读取字节后把字节转换成字符 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK"); 指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = "E:\\file_gbk.txt"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK"); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK"); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = "E:\\out.txt"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write("你好"); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = "E:\\out2.txt"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK"); // 写出数据 osw2.write("你好");// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现12345678910111213141516171819202122232425public class TransDemo &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = "file_gbk.txt"; String destFile = "file_utf8.txt"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , "GBK"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲流]]></title>
    <url>%2F2019%2F11%2F14%2F%E7%BC%93%E5%86%B2%E6%B5%81%2F</url>
    <content type="text"><![CDATA[缓冲流概述 缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 字节缓冲流构造函数 public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt")); 效率测试这里说下，字节流读取字节可以一个一个，也可以读多个。 缓冲流的效率体现在也就是2的情况，每次读取一个字节进入缓冲，缓冲满了，在反馈，相当于一车带一堆货，不用每次一车带一个货 用数组的情况下使读取效率更高，一次可以读取多个字节 有个疑惑：字节流用数组不是和缓冲流用数组差不多嘛？ 查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream("jdk9.exe"); FileOutputStream fos = new FileOutputStream("copy.exe") )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println("普通流复制时间:"+(end - start)+" 毫秒"); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe")); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println("缓冲流复制时间:"+(end - start)+" 毫秒"); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe")); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println("缓冲流使用数组复制时间:"+(end - start)+" 毫秒"); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader("br.txt"));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt")); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader("in.txt")); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println("------"); &#125; // 释放资源 br.close(); &#125;&#125; newLine方法演示，代码如下： 1234567891011121314151617181920public class BufferedWriterDemo throws IOException &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter("out.txt")); // 写出数据 bw.write("黑马"); // 写出换行 bw.newLine(); bw.write("程序"); bw.newLine(); bw.write("员"); bw.newLine(); // 释放资源 bw.close(); &#125;&#125;输出效果:黑马程序员 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 解析文本信息到集合中。 遍历集合，按顺序，写出文本信息。 案例实现hashmap是有序的集合 12345678910111213141516171819202122232425262728293031323334public class BufferedTest &#123; public static void main(String[] args) throws IOException &#123; // 创建map集合,保存文本数据,键为序号,值为文字 HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;(); // 创建流对象 BufferedReader br = new BufferedReader(new FileReader("in.txt")); BufferedWriter bw = new BufferedWriter(new FileWriter("out.txt")); // 读取数据 String line = null; while ((line = br.readLine())!=null) &#123; // 解析文本 String[] split = line.split("\\."); // 保存到集合 lineMap.put(split[0],split[1]); &#125; // 释放资源 br.close(); // 遍历map集合 for (int i = 1; i &lt;= lineMap.size(); i++) &#123; String key = String.valueOf(i); // 获取map中文本 String value = lineMap.get(key); // 写出拼接文本 bw.write(key+"."+value); // 写出换行 bw.newLine(); &#125; // 释放资源 bw.close(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化-基础]]></title>
    <url>%2F2019%2F11%2F12%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原理MYSQL逻辑分层 连接层 ： 提供与客户端连接的服务。当客户端发出一个请求后（如增删改查的SQL语句），首先到达该层，将服务器与客户端建立连接。 服务层 ：提供各种用户使用的接口并且对sql进行优化 引擎层 ：提供存储数据的方式 存储层：具体存储数据 引擎 InnoDB(默认) ：事务优先 （适合高并发操作；行锁：一次锁一行）MyISAM ：性能优先 （表锁：一次锁一张表） 查询数据库引擎： 支持哪些引擎？ show engines ; 查看当前使用的引擎 show variables like ‘%storage_engine%’ ; 指定数据库对象的引擎： 1234567create table tb( id int(4) auto_increment , name varchar(5), dept varchar(5) , primary key(id) )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ; SQL优化原因：性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不合理（缓冲、线程数） SQL执行及解析过程 编写过程： select dinstinct ..from ..join ..on ..where ..group by …having ..order by ..limit .. ​ 解析过程：​ from .. on.. join ..where ..group by ….having …select dinstinct ..order by limit … SQL优化（主要就是在优化索引） ​ 索引： 相当于书的目录​ 索引： index是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树…） 索引的弊端 索引本身很大， 可以存放在内存/硬盘（通常为硬盘） 索引不是所有情况均适用： a.少量数据 b.频繁更新的字段 c.很少使用的字段 索引会降低增删改的效率（增删改 查）实际上查是最主要的，所以利大于弊 优势提高查询效率（降低IO使用率） 降低IO使用率 降低CPU使用率 （…order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时 可以直接使用） 索引索引是一种数据结构，通过索引可以提高查询效率 实际上b树并不是2叉，应该为多路平衡树，这里只是便于理解 关于B树和B+树看这篇博客， https://zhuanlan.zhihu.com/p/54102723 分类与使用 主键索引： 不能重复。id 不能是null 唯一索引 ：不能重复。id 可以是null 单值索引 ： 单列， age ;一个表可以多个单值索引,name。 复合索引 ：多个列构成的索引 （相当于 二级目录 ： z: zhao） (name,age) (a,b,c,d） 创建索引 方式一： create 索引类型 索引名 on 表(字段) 单值索引： create index dept_index on tb(dept); 唯一索引： create unique index name_index on tb(name) ; 复合索引 create index dept_name_index on tb(dept,name); 方式二：alter table 表名 索引类型 索引名（字段） ​ 单值： ​ alter table tb add index dept_index(dept) ;​ 唯一：​ alter table tb add unique index name_index(name);​ 复合索引​ alter table tb add index dept_name_index(dept,name);​ 注意：如果一个字段是primary key，则改字段默认就是 主键索引 删除索引： drop index 索引名 on 表名 ;drop index name_index on tb ; 查询索引： show index from 表名 ; show index from 表名 \G SQL性能问题分析SQL的执行计划explain 可以模拟SQL优化器执行SQL语句，从而让开发人员 知道自己编写的SQL状况 b.MySQL查询优化其会干扰我们的优化 查询执行计划： explain +SQL语句 explain select * from tb ; id: id值相同，从上往下 顺序执行 ​ id值不同：id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层) select_type:查询类型 ​ PRIMARY:包含子查询SQL中的主查询 （最外层） ​ SUBQUERY：包含子查询SQL中的子查询 （非最外层） ​ simple:简单查询（不包含子查询、union） ​ derived:衍生查询(使用到了临时表) type:索引类型 possible_keys ：可能用到的索引，是一种预测，不准 key ：实际使用到的索引 key_len ：索引的长度 用于判断复合索引是否被完全使用 ref : 注意与type中的ref值区分 指明当前表所参照的字段 rows: 被索引优化查询的 数据个数 (实际通过索引而查询到的数据个数) Extra using filesort ： 性能消耗大；需要“额外”的一次排序（查询） 。常见于 order by 语句中。排序会先进行先查询 1EXPLAIN SELECT a1 FROM test02 WHERE a1 =&apos;&apos; ORDER BY a2 where对a1进行了查询，order by需要先查询再排序，所以多了额外一次 1EXPLAIN SELECT a1 FROM test02 WHERE a1 =&apos;a&apos; ORDER BY a1 where查a1，order by就不需要查 using temporary:性能损耗大 ，用到了临时表。一般出现在group by 语句中。 12explain select a1 from test02 where a1 in (&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) group by a1 explain select a1 from test02 where a1 in (&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) group by a2 ; --using temporary a2 using index :性能提升; 索引覆盖（覆盖索引）。原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询） using where （需要回表查询） impossible where ： where子句永远为false]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date]]></title>
    <url>%2F2019%2F10%2F31%2FDate%2F</url>
    <content type="text"><![CDATA[Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = "2018年12月11日"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; Calendar类概念java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO]]></title>
    <url>%2F2019%2F10%2F30%2FIO%2F</url>
    <content type="text"><![CDATA[一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("b.txt"); &#125;&#125; 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 字符串转换为字节数组 byte[] b = "黑马程序员".getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;输出结果：黑马程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 字符串转换为字节数组 byte[] b = "abcde".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"，true); // 字符串转换为字节数组 byte[] b = "abcde".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是\r\n 。把 以指定是否追加续写了，代码使用演示： 123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write("\r\n".getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 回车符\r和换行符\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\r\n； Unix系统里，每行结尾只有 换行 ，即\n； Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。 ByteArrayOutputStream创建一个空数组，往字节数组内写入数据 构造函数 1OutputStream bOut = new ByteArrayOutputStream(int a) 创建一个大小为n字节的缓冲区 1OutputStream bOut = new ByteArrayOutputStream(); 创建一个32字节（默认大小）的缓冲区 public void write(int w)将指定的字节写入此字节数组输出流。 public void write(byte []b, int off, int len)将指定字节数组中从偏移量 off 开始的 len 个字节写入此字节数组输出流。 public byte[] toByteArray()创建一个新分配的字节数组。数组的大小和当前输出流的大小，内容是当前输出流的拷贝。 （当你把数据写入流以后，要操作流内的数组就可以使用这个方法） 源码 12345678910111213141516171819202122232425protected byte buf[];public ByteArrayOutputStream() &#123; this(32); &#125;public ByteArrayOutputStream(int size) &#123; if (size &lt; 0) &#123; throw new IllegalArgumentException(&quot;Negative initial size: &quot; + size); &#125; buf = new byte[size]; &#125; public synchronized void write(int b) &#123; ensureCapacity(count + 1); buf[count] = (byte) b; count += 1; &#125; public synchronized void write(byte b[], int off, int len) &#123; if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) - b.length &gt; 0)) &#123; throw new IndexOutOfBoundsException(); &#125; ensureCapacity(count + len); System.arraycopy(b, off, buf, count, len); count += len; &#125; 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 构造举例，代码如下： 12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream("b.txt"); &#125;&#125; 读取字节数据(char)和new String(byte[])转换成字符和字符串 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream("read.txt"); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream("read.txt"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 ByteArrayInputStream字节数组输入流字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中。 （看源码可知流内部会有一个数组来接收要读取的数组） 构造函数，a数组为要读取的数组 1ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a); 123ByteArrayInputStream bArray = new ByteArrayInputStream(byte []a, int off, int len) public int read() 从此输入流中读取下一个数据字节。 public int read(byte[] r, int off, int len)将最多 len 个数据字节从此输入流读入字节数组。 123456789protected byte buf[];public ByteArrayInputStream(byte buf[]) &#123; this.buf = buf; this.pos = 0; this.count = buf.length; &#125;public synchronized int read() &#123; return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1; &#125; 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。(1个中文字符 UTF-8 3个字节 GBK 2个字节) 1234567891011//这样每次只能读取到3个字节中的一个public class probilem &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fileInputStream=new FileInputStream(&quot;F:\\test\\test1\\b.txt&quot;); int len=0; while ((len=fileInputStream.read())!=-1)&#123; System.out.println(len); &#125; fileInputStream.close(); &#125;&#125; 所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader("b.txt"); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 每次读取到的有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员序 获取有效的字符改进，代码使用演示： 123456789101112131415161718192021public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter("b.txt"); &#125;&#125; 基本写出数据 创建FileWriter对象，构造函数绑定要写入的目的地 write方法把数据写入到内存缓冲区（字符会转换成字节） flush方法会刷下缓冲区，把内存缓冲区的数据刷新到文件中 释放资源 写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 字符串转换为字符数组 char[] chars = "黑马程序员".toCharArray(); // 写出字符数组 fw.write(chars); // 黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 字符串 String msg = "黑马程序员"; // 写出字符数组 fw.write(msg); //黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(msg,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter("fw.txt"，true); // 写出字符串 fw.write("黑马"); // 写出换行 fw.write("\r\n"); // 写出字符串 fw.write("程序员"); // 关闭资源 fw.close(); &#125;&#125;输出结果:黑马程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 12345678910111213141516171819202122public class HandleException1 &#123; public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter("fw.txt"); // 写出数据 fw.write("黑马程序员"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDK7的处理(扩展知识点了解内容)还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011121314151617public class Execption &#123; public static void main(String[] args) &#123; try(FileInputStream inputStream=new FileInputStream("F:\\test\\test1\\b.txt"); FileOutputStream fileOutputStream=new FileOutputStream("F:\\test\\test1\\a.txt")) &#123; //可能异常的代码 //一次读取一个字节 int len; while ((len=inputStream.read())!=-1)&#123; fileOutputStream.write(len); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 1234&quot;黑马程序员&quot;.toCharArray()//把字符串转换成字符数组new String(chars,0,len)//把字符数组转换成字符串(char)len//把字节转化成字符new String(bytes1)//把字节数组转成字符串 Properties属性集概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 集合和IO之间联系 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 与流相关的方法 public void load(InputStream inStream）：字节输入流，不能读取中文 public void load(Reader reader)：字符输入流，能读取中文 public void store(OutputStream outStream，String comments)：用字节流写入 public void store(Writer writer，String comments)：用字符流写入 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 123456789101112131415161718192021222324252627282930313233343536373839public class prop &#123; public static void main(String[] args) throws IOException &#123; //demo(); //demo2(); demo3(); &#125; public static void demo()&#123; Properties properties=new Properties(); properties.setProperty(&quot;艾斯&quot;,&quot;1&quot;); properties.setProperty(&quot;迪迦&quot;,&quot;2&quot;); properties.setProperty(&quot;泰罗&quot;,&quot;3&quot;); Set&lt;String&gt;set=properties.stringPropertyNames(); for (String s:set)&#123; String value=properties.getProperty(s); System.out.println(s+&quot;=&quot;+value); &#125; &#125; public static void demo2() throws IOException &#123; Properties properties=new Properties(); properties.setProperty(&quot;艾斯&quot;,&quot;1&quot;); properties.setProperty(&quot;迪迦&quot;,&quot;2&quot;); properties.setProperty(&quot;泰罗&quot;,&quot;3&quot;); FileWriter fileWriter=new FileWriter(&quot;F:\\test\\test1\\b.txt&quot;); properties.store(fileWriter,&quot;&quot;); fileWriter.close(); &#125; public static void demo3() throws IOException &#123; Properties properties=new Properties(); FileReader fileReader=new FileReader(&quot;F:\\test\\test1\\b.txt&quot;); properties.load(fileReader); Set&lt;String&gt;set =properties.stringPropertyNames(); for (String s:set)&#123; String value=properties.getProperty(s); System.out.println(s+&quot;=&quot;+value); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvc拦截器与servlet过滤器]]></title>
    <url>%2F2019%2F10%2F29%2Fmvc%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8Eservlet%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器作用 对服务器接受的请求资源和响应给浏览器的资源进行管理 保护servlet 使用 创建一个实现了Filter接口的普通java类 覆写接口中的方法 init方法：服务器启动即执行，资源初始化 doFilter方法：拦截请求的方法，此方法中可以对资源实现管理（需要手动进行放行） destory方法：服务器关闭执行 在web.xml中配置过滤器 12345678910111213&lt;!--配置解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 生命周期：服务器启动到服务器关闭 过滤器流程：客户端发送url请求，服务器接收后在web.xml中查找有无对应的过滤器类，如果满足此拦截条件，那么在过滤器中的doFilter方法中调用filterChain.doFilter(servletRequest,servletResponse) ，执行，否则重定向跳转到错误界面。 拦截器创建类，实现HandlerInterceptor接口，重写需要的方法 preHandle方法：进入Handler方法之前执行。可以用于身份认证、身份授权。比如如果认证没有通过表示用户没有登陆，需要此方法拦截不再往下执行（return false），否则就放行（return true）。 postHandle方法：进入Handler方法之后，返回ModelAndView之前执行。可以看到该方法中有个modelAndView的形参。应用场景：从modelAndView出发：将公用的模型数据（比如菜单导航之类的）在这里传到视图，也可以在这里同一指定视图。 afterCompletion方法：执行Handler完成之后执行。应用场景：统一异常处理，统一日志处理等。 1234567891011121314151617181920public class interceptor1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;我要拦截你，interceptor1&quot;); //request.getRequestDispatcher(&quot;WEB-INF/pages/error.jsp&quot;).forward(request,response); //放行 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;拦截1已经执行了&quot;); //request.getRequestDispatcher(&quot;WEB-INF/pages/error.jsp&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;我最后&quot;); &#125;&#125; 在springmvc.xml中配置拦截器类 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/user/*&quot;/&gt; &lt;bean class=&quot;interceptor.interceptor1&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 区别1、拦截器是基于java的反射机制的，而过滤器是基于函数回调2、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务的前世今生]]></title>
    <url>%2F2019%2F10%2F26%2F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%2F</url>
    <content type="text"><![CDATA[数据库的事务概念事务：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据量不变 事务的隔离级别 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别（隔离级别从小到大安全性越来越高，但是效率越来越低） read uncommitted：读未提交 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle） 产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认） 产生的问题：幻读 serializable：串行化 可以解决所有的问题 数据库设置隔离级别： * set global transaction isolation level 级别字符串;12345set global transaction isolation level read uncommitted;start transaction;-- 转账操作update account set balance = balance - 500 where id = 1;update account set balance = balance + 500 where id = 2; 这种情况下事务1更新了update，事务2查询就看到变化，如果此时事务1选择回滚，事务2的数据又会回到原来的状态 12345set global transaction isolation level read committed;start transaction;-- 转账操作update account set balance = balance - 500 where id = 1;update account set balance = balance + 500 where id = 2; 这种情况下事务1更新了，事务2并不会看到变化，只有当事务1commit后，事务2才会查询发现变化(解决了脏读)，但是这是在事务2中2次的查询会查询到不同的数据，即虚读（向领导汇报工作，开始说变了1，结果一会变成了2，你不就不好交差了吗） 12345set global transaction isolation level repeatable read;start transaction;-- 转账操作update account set balance = balance - 500 where id = 1;update account set balance = balance + 500 where id = 2; 这种情况下即便事务1commit了，事务2依然是不变的（解决了虚读），只有当事务2也commit了之后在查询才能看到变化 操作 开启事务： start transaction; 回滚：rollback; 提交：commit; 例子 1234567891011121314151617181920212223242526CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000);SELECT * FROM account;UPDATE account SET balance = 1000;-- 张三给李四转账 500 元 -- 0. 开启事务START TRANSACTION;-- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;;-- 2. 李四账户 +500-- 出错了...UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;; -- 发现执行没有问题，提交事务COMMIT; -- 发现出问题了，回滚事务ROLLBACK; jdbc的事务操作 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务，在执行sql之前开启事务 提交事务：commit() ，当所有sql都执行完提交事务 回滚事务：rollback() ，在catch中回滚事务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125;&#125; spring的事务Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久话化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了 这里都是用到jdbc来进行持久化的 实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚 基于xml的事务 导包 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt;&lt;/dependency&gt; 创建数据库表和实体类 在配置文件中配置业务层和持久层对 注意这里dao中注入了datesource，用的是JdbcDaoSupport（抽取了jdbcTemplate中的重复代码，导入包即可用） 12345678public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId); return accounts.isEmpty()?null:accounts.get(0); &#125;&#125; 源码：这是一部分，通过dateSource构造一个jdbcTemplate 1234567public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; this.jdbcTemplate = this.createJdbcTemplate(dataSource); this.initTemplateConfig(); &#125; &#125; 1234567891011121314151617&lt;!-- 配置业务层--&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置账户的持久层--&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 配置步骤 配置事务管理器 1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 配置事务的通知引用事务管理器 1&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;/tx:advice&gt; 配置 AOP 切入点表达式 建立事务通知和切入点表达式的对应关系 1234567&lt;!-- 配置aop--&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式--&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 配置事务的属性（是在事务的通知tx:advice标签的内部）也包括对service层哪个接口中的方法进行事务 123456789101112131415&lt;!-- 配置事务的通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 配置事务的属性 isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。 propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。 read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。 timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。 rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 基于注解的事务 导包 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置spring创建容器时要扫描的包 12&lt;!-- 配置spring创建容器时要扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 配置事务管理器 1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 123456789101112&lt;!-- 配置JdbcTemplate--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 开启spring对注解事务的支持 12&lt;!-- 开启spring对注解事务的支持--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 在需要事务支持的地方使用@Transactional注解 1234//需要的是读写型事务配置@Transactional(propagation= Propagation.REQUIRED,readOnly=false)@Overridepublic void transfer(String sourceName, String targetName, Float money) &#123; 基于纯注解的事务不要xml文件，通过几个config配置类即可 jdbcConfig.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=1234 和数据库相关的配置类 1234567891011121314151617181920212223242526272829303132333435363738public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; /** * 创建JdbcTemplate * @param dataSource * @return */ @Bean(name=&quot;jdbcTemplate&quot;) public JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name=&quot;dataSource&quot;) public DataSource createDataSource()&#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(username); ds.setPassword(password); return ds; &#125;&#125; 和事务相关的配置类 123456789101112public class TransactionConfig &#123; /** * 用于创建事务管理器对象 * @param dataSource * @return */ @Bean(name=&quot;transactionManager&quot;) public PlatformTransactionManager createTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; spring的配置类，相当于bean.xml @EnableTransactionManagement类似于开启对事务注解的支持 1234567@Configuration@ComponentScan(&quot;com.itheima&quot;)@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;)@PropertySource(&quot;jdbcConfig.properties&quot;)@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2019%2F10%2F19%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println("num=" + num); System.out.println("over"); &#125;&#125; 上述程序执行过程图解： 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println("over"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException("哥们，角标越界了~~~"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read("a.txt"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read("a.txt"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; if (!path.equals("b.txt")) &#123; throw new IOException(); &#125; &#125;&#125; 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read("b.txt"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read("a.txt"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println("不管程序怎样，这里都将会被执行。"); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot入门]]></title>
    <url>%2F2019%2F10%2F17%2Fspring%20boot%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[spring boot诞生的背景 在spring boot出现以前，使用spring框架的程序员是这样配置web应用环境的，需要大量的xml配置 随着web项目集成软件的不断增多，xml配置也不断的增多，xml配置文件也在不断地增多，项目的依赖管理也越发的复杂。spring框架也因此饱受争议，配置文件难以理解且容易出错 xml配置文件不但复杂，而且绝大部分属于模板配置，也就是说有80%以上的配置是不断重复的。也就是说在这个web项目里面这样配置，挪到另一个项目里面这部分配置仍然相同 举一个例子:自己接电线与标准化插座Spring Boot的配置方式，就像是插头插座，就是这个标准。你第三方开源类库想接入进来，你就做一个starter的适配。spring MVC方式就像是手动接电线，很灵活，但是不同的人接出来的效果千差万别，而且很容易出错。Spring boot虽然灵活性不如Spring MVC的方式，你也不太清楚插座里面的线路是什么样，但就是方便易用 spring boot 改变了什么 Spring Boot 的目标不在于为已解决的问题领域提供新的解决方案，而是为平台带来另一种新的开发体验，从而简化对这些已有技术的使用 使配置变简单 使监控变简单 使部署变简单 使开发变简单 Spring Boot主要特性 遵循“约定优于配置”的原则，简化配置 可以完全脱离XML配置文件,采用注解配置和java Config 内嵌Servlet容器，应用可用jar包执行：java -jar 快速完成项目搭建、整合第三方类库，方便易用 提供了starter POM, 能够非常方便的进行包管理, 简化包管理配置 与Spring cloud天然集成，spring boot是目前java体系内实现微服务最佳方案 Spring Boot集成第三方类库的步骤 通过maven引入springboot-XXXX-starter 修改ymal或properties全局统一配置文件 加入一个Java Config。这个属于个性化配置，如果使用通用配置，这一步不需要。 核心概念Spring Boot 、 Spring MVC 、Spring对比Spring 框架 Spring框架最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果你能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。 Spring MVC Spring MVC提供了一种友好的方式来开发Web应用程序。 通过使用诸如Dispatcher Servlet，ModelAndView和View Resolver，可以轻松开发Web应用程序 Spring Boot Spring 和 Spring MVC最大的弊病在于存在大量的配置，并且这些配置在不同的项目中具有很高的相似性。从而导致重复配置，繁琐而且杂乱！ Spring Boot期望通过结合自动配置和starters来解决了这个问题。 另外，Spring Boot还提供了一些功能，可以更快地构建可用于生产环境的应用程序 Spring Boot 自动配置Spring和Spring MVC应用程序里面有大量的XML或Java Bean配置。Spring Boot为解决这个问题，提供一种新的解决方案，新的思维方式。 springboot思考的方式：是不是可以更加智能一点，当Spring中加入一些新的jar包，可以自动的配置一些bean。 比如：Spring MVC JAR位于类路径中时，自动配置Dispatcher Servlet。当然，当这些自动的默认配置不符合我们的要求的时候，我们可以修改。 什么是Spring Boot Starter？Spring Boot Starter是一组被依赖第三方类库的集合。 如果你要开发一个web应用程序，就通过包管理工具(如maven)引入spring-boot-starter-web就可以了，而不用分别引入下面这么多依赖类库，spring-boot-starter-web一次性帮你引入下面的这些常用类库。 Spring — spring 核心, beans, context上下文, AOP面向切面 Web MVC — Spring MVC Jackson — JSON数据的序列化与反序列化 Validation — Hibernate参数校验及校验API 嵌入式 Servlet Container — Tomcat 日志框架Logging — logback, slf4j]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[collection,迭代器]]></title>
    <url>%2F2019%2F10%2F16%2Fcollection-%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Collection集合集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add("小李广"); coll.add("扫地僧"); coll.add("石破天"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 扫地僧 是否在集合中"+coll.contains("扫地僧")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除石破天："+coll.remove("石破天")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; Iterator迭代器Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("串串星人"); coll.add("吐槽星人"); coll.add("汪星人"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("小河神"); coll.add("老河神"); coll.add("神婆"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 for循环与迭代器的对比: ***** 效率上各有各的优势: &gt; ArrayList对随机访问比较快，而for循环中使用的get()方法，采用的即是随机访问的方法，因此在ArrayList里for循环快。 &gt; LinkedList则是顺序访问比较快，Iterator中的next()方法采用的是顺序访问方法，因此在LinkedList里使用Iterator较快。 &gt; 主要还是要依据集合的数据结构不同的判断。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解开发]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[注解开发增删改查解释一下，原来mapper.xml里的namespace不用写，因为本身就在IUserDao接口，rusultType不用因为泛型内说明了返回类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert(&quot;insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)&quot;) void saveUser(User user); /** * 更新用户 * @param user */ @Update(&quot;update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;) void updateUser(User user); /** * 删除用户 * @param userId */ @Delete(&quot;delete from user where id=#&#123;id&#125; &quot;) void deleteUser(Integer userId); /** * 根据id查询用户 * @param userId * @return */ @Select(&quot;select * from user where id=#&#123;id&#125; &quot;) User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select(&quot;select * from user where username like #&#123;username&#125; &quot;) List&lt;User&gt; findUserByName(String username);&#125; 注解开发多表查询一对一（多对一） @One 注解（一对一） 代替了标签，是多表查询的关键，在注解中用来指定子查询返回单一对象 select 指定用来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled 123456789101112131415161718192021222324public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * @return */ @Select(&quot;select * from account&quot;) @Results(id=&quot;accountMap&quot;,value = &#123; @Result(id=true,column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;uid&quot;,property = &quot;uid&quot;), @Result(column = &quot;money&quot;,property = &quot;money&quot;), //这个注解是引入主表 FetchType(加载时机) EAGER(立即加载) @Result(property = &quot;user&quot;,column = &quot;uid&quot;,one=@One(select=&quot;com.itheima.dao.IUserDao.findById&quot;,fetchType= FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll(); /** * 根据用户id查询账户信息 * @param userId * @return */ @Select(&quot;select * from account where uid = #&#123;userId&#125;&quot;) List&lt;Account&gt; findAccountByUid(Integer userId);&#125; 一对多 @Many 注解（多对一） 代替了标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合 fetchType = FetchType.LAZY延迟加载 1234567891011121314151617181920212223242526272829303132333435363738public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) @Results(id=&quot;userMap&quot;,value=&#123; @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;userName&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;), @Result(property = &quot;accounts&quot;,column = &quot;id&quot;, many = @Many(select = &quot;com.itheima.dao.IAccountDao.findAccountByUid&quot;, fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * @param userId * @return */ @Select(&quot;select * from user where id=#&#123;id&#125; &quot;) @ResultMap(&quot;userMap&quot;) User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select(&quot;select * from user where username like #&#123;username&#125; &quot;) @ResultMap(&quot;userMap&quot;) List&lt;User&gt; findUserByName(String username);&#125;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟加载]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[延迟加载的概念就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速 度要快。 坏处： 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗 时间，所以可能造成用户等待时间变长，造成用户体验下降。 一对多，多对多：通常情况下我们都是采用延迟加载。多对一，一对一：通常情况下我们都是采用立即加载。 一对多案例 在SqlMapConfig.xml中配置setting标签 123456&lt;settings&gt; &lt;!-- 配置全局缓存--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; IUserDao.xml中配置collection标签 property=”accList” : 关联查询的结果集存储在 User 对象的上哪个属性。 ofType=”account” ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名 单单1对多的查询，只需要上面两个属性，下面2个用于延迟加载 1对多查询原理：代理对象通过findAll()的sql语句执行结果封装到rusultMap的嵌套结构中 select 用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 id column 用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一 个字段名了 （根据user的id查询账户） 123456789101112131415161718192021222324&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.itheima.dao.IAccountDao.findAccountByUid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 1234&lt;!-- 根据用户id查询账户列表 --&gt; &lt;select id=&quot;findAccountByUid&quot; resultType=&quot;account&quot;&gt; select * from account where uid = #&#123;uid&#125; &lt;/select&gt; 测试类 当注释了for循环输出，会发现只执行了一个findAll()的select语句，另一个select并没有执行，这就是延迟加载，你用不到我就我就不给你 123456789@Test public void findAll()&#123; List&lt;Account&gt; accounts = accoutDao.findAll(); for (Account account:accounts) &#123; System.out.println(&quot;每一个account的信息&quot;); System.out.println(account); System.out.println(account.getUser()); &#125; &#125; 缓存概念 什么是缓存 存在于内存中的临时数据 为什么使用缓存 减少与数据库的交互次数，提高执行效率 什么样的数据能使用缓存，什么样的数据不能使用 适用于缓存： 经常查询并且不经常改变的。 数据的正确与否对最终结果影响不大的不适用于缓存： 经常改变的数据。 数据的正确与否对最终结果影响很大的。如，商品库存，银行汇率，股市牌价。 mybatis中的一级缓存和二级缓存一级缓存 它指的是mybatis中SqlSession对象的缓存。 当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域中。 每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。 当SqlSession对象消失时，mybatis的一级缓存也就消失了。 测试 1234567public void getStudentById() throws Exception &#123; SqlSession sqlSession = factory.openSession(true); // 自动提交事务 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); System.out.println(studentMapper.getStudentById(1)); System.out.println(studentMapper.getStudentById(1)); System.out.println(studentMapper.getStudentById(1)); &#125; 二级缓存 它指的是mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 二级缓存的使用步骤： 第一步：让mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） 第三步：让当前的操作支持二级缓存（在select标签中配置） 12345678910111213141516@Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125; 这里要注意最后一个结果为false，图片没截好，原因如下]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1对1 account类 12345678910//从表实体应该包含一个主表实体的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; IAccountDao接口 12345678public interface IAccountDao &#123; /** * 查询所有账户 * @return */ List&lt;Account&gt; findAll();&#125; AccountDao的mapper 1234567891011121314151617&lt;mapper namespace=&quot;top.zoick.dao.IAccountDao&quot;&gt; &lt;!--定义封装account和user的resultMap--&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt; &lt;!--一对一的关系映射，配置封装user的内容 column中指名从表的外键 property=&quot;user&quot;指的是单个实体类的引用--&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; AccountDao的测试类 123456789@Testpublic void findAll()&#123; List&lt;Account&gt; accounts = accoutDao.findAll(); for (Account account:accounts) &#123; System.out.println(&quot;每一个account的信息&quot;); System.out.println(account); System.out.println(account.getUser()); &#125;&#125; 1对多示例：一个用户可以有多个账户 多对多]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis连接池 动态SQL]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[连接池连接池：存储连接的一个容器 容器：就是一个集合，必须保证线程安全，不能2个线程拿到同一个连接 123456789101112131415161718&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 数据源DataSource分类mybatis连接池提供了3种配置方式： 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。 type属性的值： POOLED 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现 ​ UNPOOLED 采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的 数据源的创建过程在mybatis的XML配置文件中，使用元素来配置数据源 MyBatis在初始化时，解析此文件，根据的type属性来创建相应类型的的数据源DataSource type=”POOLED” ：MyBatis会创建PooledDataSource实例 type=”UNPOOLED” ：MyBatis会创建UnpooledDataSource实例 type=”JNDI”：MyBatis会从JNDI服务上查找DataSource实例，然后返回使用 MyBatis是通过工厂模式来创建数据源DataSource对象的，MyBatis定义了抽象的工厂接 口:org.apache.ibatis.datasource.DataSourceFactory,通过其getDataSource()方法返回数据源DataSource MyBatis创建了DataSource实例后，会将其放到Configuration对象内的Environment对象中， 供以后使用 DataSource什么时候创建Connection对象12345String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;); 前4句都不会导致java.sql.Connection对象的创建，只有当第5句sqlSession.selectList(“SELECT * FROM STUDENTS”)，才会触发MyBatis在底层执行下面这个方法来创建java.sql.Connection对象 12345678910protected void openConnection() throws SQLException &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;Opening JDBC Connection&quot;); &#125; connection = dataSource.getConnection(); if (level != null) &#123; connection.setTransactionIsolation(level.getLevel()); &#125; setDesiredAutoCommit(autoCommmit); &#125; 动态sql标签 我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询 1List&lt;User&gt; findByCondition(User user); 1234567891011&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;userName != null&quot;&gt; and username = #&#123;userName&#125; &lt;/if&gt; &lt;if test=&quot;userSex != null&quot;&gt; and sex = #&#123;userSex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 123456789101112@Test public void testFindByCondiion() throws Exception &#123; User u = new User(); u.setUserName(&quot;aa&quot;);// u.setUserSex(&quot;女&quot;); init(); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findByCondition(u); for (User user : users) &#123; System.out.println(user); &#125; &#125; 标签 传入多个 id 查询用户信息，用下边两个 sql 实现： SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16) SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。 这样我们将如何进行参数的传递？ 1234567891011public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125; &#125; dao接口 1List&lt;User&gt; findInIds(QueryVo vo); dao映射配置 标签用于遍历集合，它的属性： ​ collection:代表要遍历的集合元素，注意编写时不要写#{} ​ open:代表语句的开始部分 ​ close:代表结束部分 ​ item:代表遍历集合的每个元素，生成的变量名 ​ sperator:代表分隔符 12345678910111213&lt;!-- 查询所有用户在 id 的集合之中 --&gt; &lt;select id=&quot;findInIds&quot; resultType=&quot;user&quot; parameterType=&quot;queryvo&quot;&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;id in ( &quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt; &lt;!--item要和下面的#&#123;uid&#125;保持一致，应该是传过来一个ids集合，#获取到里面的值，与item对应，在放入collection集合中--&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 123456789101112131415@Test public void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(41); ids.add(42); ids.add(43); ids.add(46); ids.add(57); vo.setIds(ids); //6.执行操作 List&lt;User&gt; users = userDao.findInIds(vo); for(User user : users) &#123; System.out.println(user); &#125; 抽取重复sql 123456789&lt;!--抽取重复的sql语句--&gt;&lt;sql id=&quot;defaultUser&quot;&gt; select * from user&lt;/sql&gt;&lt;!--配置查询所有 其中id不能乱写必须是dao接口中的方法 resultType写的是实体类的全路径--&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; &lt;include refid=&quot;defaultUser&quot;/&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatisCRUD]]></title>
    <url>%2F2019%2F10%2F14%2FmybatisCRUD%2F</url>
    <content type="text"><![CDATA[基本的CRUD代码接口类代码 1234567891011121314151617181920212223242526//用户持久层接口public interface IUserDao &#123; //查询所有 List&lt;User&gt; findAll(); //保存用户 void saveUser(User user); //更新 void updateUser(User user); //删除 void deleteUser(Integer userId); User findById(Integer userId); //模糊查询 List&lt;User&gt;findByName(String username); //查询总用户数 int findTotal(); //根据queryvo中的条件查询用火狐 List&lt;User&gt; findUserByVo(QueryVo vo);&#125; mapper代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.zoick.dao.IUserDao&quot;&gt; &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;top.zoick.domain.User&quot;&gt; &lt;!--主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--配置查询所有 其中id不能乱写必须是dao接口中的方法 resultType写的是实体类的全路径--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; &lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt; &lt;!--select id as userId,username as userName,address as userAddress ,sex as userSex, birthday as userBirthday from user--&gt; select * from user&lt;/select&gt; &lt;!--保存用户--&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;top.zoick.domain.User&quot;&gt; &lt;!--配置插入操作后，获取插入数据的id--&gt; &lt;!--keyProperty对应实体类属性名:id，keyColumn对应于数据库:id resultType为数据类型，order为在这条insert sql语句执行前还是执行后做--&gt; &lt;selectKey keyProperty=&quot;userId&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user (username,address,sex,birthday) values (#&#123;userName&#125;,#&#123;userAddress&#125;,#&#123;userSex&#125;,#&#123;userBirthday&#125;) &lt;/insert&gt; &lt;!--更新用户--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;usER&quot;&gt; update user set username=#&#123;userName&#125;,address=#&#123;userAddress&#125;,sex=#&#123;userSex&#125;,birthday=#&#123;userBirthday&#125; where id=#&#123;userId&#125; &lt;/update&gt; &lt;!--删除用户--&gt; &lt;!--当参数值为基本类型或者基本类型包装类时，SQL语句中的占位符可以随意写--&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt; delete from user where id = #&#123;anyzhanweifu&#125; &lt;/delete&gt; &lt;!--根据id查询用户--&gt; &lt;select id=&quot;findByID&quot; parameterType=&quot;INT&quot; resultMap=&quot;userMap&quot;&gt; select * from user where id = #&#123;uuuuuuid&#125; &lt;/select&gt; &lt;!--根据名称模糊查询--&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;String&quot; resultMap=&quot;userMap&quot;&gt; select * from user where username like #&#123;namenamenamename&#125; &lt;!--select * from user where username like &apos;%$&#123;value&#125;%&apos;--&gt; &lt;/select&gt; &lt;!--查询记录的总用户条数--&gt; &lt;select id=&quot;findTotal&quot; resultType=&quot;Integer&quot;&gt; select count(id) from user &lt;/select&gt; &lt;!--根据QueryVo的条件查询用户--&gt; &lt;select id=&quot;findUserByVo&quot; parameterType=&quot;top.zoick.domain.QueryVo&quot; resultMap=&quot;userMap&quot;&gt; select * from user where username like #&#123;user.username&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class MybatisTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建SqlSessionFactory工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.使用工厂生产SqlSession对象 sqlSession = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destory() throws IOException &#123; //提交事务 sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 * * @throws IOException */ @Test public void testFindALl() throws Exception &#123; //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存操作 */ @Test public void testSave() throws Exception &#123; User user = new User(); user.setUserName(&quot;modify user&quot;); user.setUserAddress(&quot;天津&quot;); user.setUserBirthday(new Date()); user.setUserSex(&quot;男&quot;); System.out.println(&quot;保存操作之前：&quot; + user); //5.使用代理对象执行方法 userDao.saveUser(user); System.out.println(&quot;保存操作之后：&quot; + user); &#125; /** * 测试更新操作 */ @Test public void testUpdate() throws Exception &#123; User user = new User(); user.setUserId(51); user.setUserName(&quot;mybatis updateUser&quot;); user.setUserAddress(&quot;天津1&quot;); user.setUserBirthday(new Date()); user.setUserSex(&quot;男&quot;); //5.使用代理对象执行方法 userDao.updateUser(user); &#125; /** * 测试删除 */ @Test public void testDelete() throws Exception &#123; //5.执行删除方法 userDao.deleteUser(51); &#125; /** * 测试根据id查询用户 */ @Test public void testFindById() throws Exception &#123; //5.执行查询一个 User user = userDao.findByID(42); System.out.println(user); &#125; /** * 测试名称模糊查询用户信息 */ @Test public void testFindByName() throws Exception &#123; //5.执行模糊查询 List&lt;User&gt; user = userDao.findByName(&quot;%彭%&quot;);// List&lt;User&gt; user = userDao.findByName(&quot;彭&quot;); System.out.println(user); &#125; /** * 测试查询用户条数 */ @Test public void testFindTotal() throws Exception &#123; init(); //执行查询总记录条数 Integer number = userDao.findTotal(); System.out.println(&quot;总记录条数为：&quot; + number); &#125; /** * 测试使用QueryVo作为查询条件 */ @Test public void testFindUserByVo() throws Exception &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName(&quot;%彭%&quot;); vo.setUser(user); List&lt;User&gt; users = userDao.findUserByVo(vo); for (User u : users) &#123; System.out.println(u); &#125; &#125;&#125; 注意点数据库表名和实体类属性名不一致1.起别名 12345&lt;!--配置查询所有 其中id不能乱写必须是dao接口中的方法 resultType写的是实体类的全路径--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;top.zoick.domain.User&quot;&gt; &lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt; select id as userId,username as userName,address as userAddress ,sex as userSex, birthday as userBirthday from user &lt;/select&gt; 2.配置查询结果的列名和实体类的属性名的对应关系 123456789101112131415 &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;top.zoick.domain.User&quot;&gt; &lt;!--主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;bithday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt;再在查询的sql语句的xml中加入配置 &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; 配置别名作用：mapper.xml里面例如parameterType=””就不用写全限定类名，写别名即可 1.使用typeAliases配置别名 12345&lt;!--使用typeAliases配置别名，他只能配置domain中类的别名--&gt; &lt;typeAliases&gt; &lt;!--typeAlias用于配置别名，type属性指定的是实体类中的全限定类名。alias属性指定别名，当指定了别名后不在区分大小写--&gt; &lt;typeAlias type=&quot;top.zoick.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; 2.使用package配置别名 1234&lt;typeAliases&gt; &lt;!--用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt; &lt;package name=&quot;top.zoick.domain&quot;/&gt;&lt;/typeAliases&gt; OGNL表达式Object Graphic Navigation Language对象 图 导航 语言它是通过对象的取值方法来获取数据。·在写法上把get给省略了比如:我们获取用户的名称 类中的写法:user.getUsername, OGNL表达式写法:user.usernamemybatis中为什么能直接写username,而不用user.呢: 因为在parameterType中已经提供了属性所属的类, 所以此时不需要写对象名]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static,instanceof,转型]]></title>
    <url>%2F2019%2F09%2F28%2Fstatic-instanceof-%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[static关键字静态变量和静态方法static最基本的用法 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来 被static修饰的变量、被static修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。JDK把不同的静态资源放在了不同的类中而不把所有静态资源放在一个类里面，很多人可能想当然认为当然要这么做，但是是否想过为什么要这么做呢？个人认为主要有三个好处： 1、不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样就很清晰了 2、避免重名。不同的类之间有重名的静态变量名、静态方法名也是很正常的，如果所有的都放在一起不可避免的一个问题就是名字重复，这时候怎么办？分类放置就好了。 3、避免静态资源类无限膨胀，这很好理解。 OK，再微微深入一下，也是有些人容易混淆的一个问题：静态方法能不能引用非静态资源？静态方法里面能不能引用静态资源？非静态方法里面能不能引用静态资源？比如就以这段代码为例，是否有错？ 1234567891 public class A2 &#123;3 private int i = 1;4 5 public static void main(String[] args)6 &#123;7 i = 1;8 &#125;9 &#125; 当然有错，在第7行的地方。不妨这么思考这个问题： 静态资源属于类，但是是独立于类存在的。从JVM的类加载机制的角度讲，静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的。类的初始化早于类的new，比如Class.forName(“xxx”)方法，就是初始化了一个类，但是并没有new它，只是加载这个类的静态资源罢了。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的；但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。所以上面的几个问题答案就很明确了： 1、静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。 2、静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。 3、非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。 静态块静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，静态块里面的代码只执行一次，且只在初始化类的时候执行。静态块很简单，不过提三个小细节： 1234567891011121314151617181920 1 public class A 2 &#123; 3 private static int a = B(); 4 5 static 6 &#123; 7 System.out.println(&quot;Enter A.static block&quot;); 8 &#125; 9 10 public static void main(String[] args)11 &#123;12 new A();13 &#125;14 15 public static int B()16 &#123;17 System.out.println(&quot;Enter A.B()&quot;);18 return 1;19 &#125;20 &#125; 12Enter A.B()Enter A.static block 出第一个结论：静态资源的加载顺序是严格按照静态资源的定义顺序来加载的。 12345678910 1 public class A 2 &#123; 3 static 4 &#123; 5 c = 3; 6 System.out.println(c); 7 &#125; 8 9 private static int c;10 &#125; 这段代码的第6行是有错误的“Cannot reference a field before it is defined”。从这个例子得出第二个结论：静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问 最后一个小例子： 123456789101112 1 public class A 2 &#123; 3 static 4 &#123; 5 System.out.println(&quot;A.static block&quot;); 6 &#125; 7 8 public A() 9 &#123;10 System.out.println(&quot;A.constructor()&quot;);11 &#125;12 &#125; 123456789101112131415161718 1 public class B extends A 2 &#123; 3 static 4 &#123; 5 System.out.println(&quot;B.static block&quot;); 6 &#125; 7 8 public B() 9 &#123;10 System.out.println(&quot;B.constructor()&quot;);11 &#125;12 13 public static void main(String[] args)14 &#123;15 new B();16 new B();17 &#125;18 &#125; 123456A.static blockB.static blockA.constructor()B.constructor()A.constructor()B.constructor() 这个例子得出第三个结论：静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次 这一部分转自https://www.cnblogs.com/swisszhang/p/9892992.html]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring mvc基础]]></title>
    <url>%2F2019%2F09%2F28%2Fspring%20mvc%2F</url>
    <content type="text"><![CDATA[概念spring mvc负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） springmvc基本组件及流程分析处理器映射器HandlerMapping,处理器适配器HandlAdapter,视图解析器ViewResolver称为SpringMVC三大组件.在bean.xml中声明&lt;mvc:annotation-driven conversion-service=”conversionService”/&gt;标签相当于自动配置了处理器映射器和处理器适配，视图解析器需要自己配置 12345 &lt;!-- 配置视图解析器,用于解析项目跳转到的文件的位置 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 前端控制器(核心控制器)DispatcherServlet:用户请求最先达到的控制器,前端控制器调用其他组件处理请求,是MVC架构中的C,是整个流程控制的核心.其存在降低了组件间的耦合性. 处理器映射器HandlerMapping:负责根据用户请求找到处理器. 处理器适配器HandlAdapter: 对处理器进行执行.这是一种适配器模式的应用 处理器Handler:具体的业务方法. 视图解析器ViewResolver: 负责将处理结果生成视图. ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址,再生成View视图对象,最后对View进行渲染将处理结果通过页面展示给用户 请求参数绑定概念：拿到客户端发出请求的请求参数的过程叫做请求参数的绑定 基本数据类型和字符串类型 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) 1&lt;a href=&quot;account/findAccount?accountId=10&amp;accountName=zhangsan&quot;&gt;查询账户&lt;/a&gt; 12345@RequestMapping(&quot;/findAccount&quot;) public String findAccount(Integer accountId,String accountName) &#123; System.out.println(&quot;查询了账户。。。。&quot;+accountId+&quot;,&quot;+accountName); return &quot;success&quot;; &#125; 实体类型（JavaBean） 参数也要保持一致 1234567public class User implements Serializable&#123; private String uname; private Integer age; private Date date; private User user; ... 123456@RequestMapping(&quot;/saveAccount&quot;)public String saveAccount(Account account)&#123; System.out.println(&quot;执行了...&quot;); System.out.println(account); return &quot;success&quot;;&#125; 12345678&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; 金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;user.uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; 集合数据类型（List、map集合等） 1234567891011public class Account implements Serializable&#123; private String username; private String password; private Double money; // private User user; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; ... 123456789101112&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; 金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot; /&gt;&lt;br/&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].age&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; 大体流程：uname,age封装到user对象，再把user添加到list集合中 常用注解基本的参数绑定：请求中的value值会传递给控制器方法的参数 1&lt;a href=&quot;account/findAccount?name=哈哈&quot;&gt;查询账户&lt;/a&gt; 12345678910// 控制器类@Controller@RequestMapping(path = &quot;/account&quot;)public class HelloController &#123; @RequestMapping(path = &quot;/findAccount&quot;) public void findAccount(String name) &#123; System.out.println(name); &#125;&#125; RequestParam注解 把请求中的指定名称的参数传递给控制器中的形参赋值 ,本来如果是name直接可以获取到，现在为username，与name不一样时，就要用到这个注解 name: value属性的别名,指定请求参数的名称 required: 指定该请求参数是否必须的,默认为true 1&lt;a href=&quot;testRequestParam?name=哈哈&quot;&gt;测试requestParam注解&lt;/a&gt; 123456@RequestMapping(&quot;/testRequestParam&quot;)public String handlerMethod(@RequestParam(name=&quot;name&quot;) String username) &#123; System.out.println(&quot;执行了...&quot;); System.out.println(username); return &quot;success&quot;;&#125; RequestBody注解 用于获取请求体的内容（注意：get方法不可以） 123456@RequestMapping(path=&quot;/hello&quot;) public String sayHello(@RequestBody String body) &#123; System.out.println(&quot;aaaa&quot;); System.out.println(body); return &quot;success&quot;; &#125; PathVariable注解 拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 。 这里就可以将10-&gt;sid-&gt;id 1&lt;a href=&quot;testPathVariable/10&quot;&gt;测试&lt;/a&gt; 123456@RequestMapping(value=&quot;/testPathVariable/&#123;sid&#125;&quot;)public String testPathVariable(@PathVariable(name=&quot;sid&quot;) String id)&#123; System.out.println(&quot;执行了...&quot;); System.out.println(id); return &quot;success&quot;;&#125; RequestHeader注解 获取指定请求头的值 value：请求头的名称 1234@RequestMapping(path=&quot;/hello&quot;) public String sayHello(@RequestHeader(value=&quot;Accept&quot;) String header) &#123; System.out.println(header); return &quot;success&quot;; &#125; CookieValue注解 ：用于获取指定cookie的名称的值 1234@RequestMapping(path=&quot;/hello&quot;) public String sayHello(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) &#123; System.out.println(cookieValue); return &quot;success&quot;; &#125; ModelAttribute注解 出现在方法上：表示当前方法会在控制器方法执行前先执行。 出现在参数上：获取指定的数据给参数赋值。 方式1：有返回值，这里uname和age会从表单那获得，数据会变，age不是20，data数据则会从模拟的数据库中去取 12345&lt;form action=&quot;anno/testModelAttribute&quot; method=&quot;post&quot;&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt; 12345678910111213141516@RequestMapping(value=&quot;/testModelAttribute&quot;) public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user)&#123; System.out.println(&quot;testModelAttribute执行了...&quot;); System.out.println(user); return &quot;success&quot;; &#125; @ModelAttribute public User showUser(String uname)&#123; System.out.println(&quot;showUser执行了...&quot;); // 通过用户查询数据库（模拟） User user = new User(); user.setUname(uname); user.setAge(20); user.setDate(new Date()); return user; &#125; 方式2：无返回值，将user存入map，再通过这个注解取得user内容 1234567891011121314151617@RequestMapping(value=&quot;/testModelAttribute&quot;) public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user)&#123; System.out.println(&quot;testModelAttribute执行了...&quot;); System.out.println(user); return &quot;success&quot;; &#125; @ModelAttribute public void showUser(String uname, Map&lt;String,User&gt; map)&#123; System.out.println(&quot;showUser执行了...&quot;); // 通过用户查询数据库（模拟） User user = new User(); user.setUname(uname); user.setAge(20); user.setDate(new Date()); map.put(&quot;abc&quot;,user); &#125; SessionAttributes注解 用于多次执行控制器方法间的参数共享 ，也就是session，之所以不用request方法是为了降低与servlet api之间的耦合度 1234567891011121314151617181920212223242526272829303132333435 @RequestMapping(path=&quot;/updateUser&quot;) public String updateUser(@ModelAttribute(value=&quot;abc&quot;) User user) &#123; System.out.println(user); return &quot;success&quot;; &#125; @Controller @RequestMapping(path=&quot;/user&quot;) @SessionAttributes(value= &#123;&quot;username&quot;,&quot;password&quot;,&quot;age&quot;&#125;,types= &#123;String.class,Integer.class&#125;) // 把数据存入到session域对象中 public class HelloController &#123; /** * 向session中存入值 * @return */ @RequestMapping(path=&quot;/save&quot;) public String save(Model model) &#123; System.out.println(&quot;向session域中保存数据&quot;); model.addAttribute(&quot;username&quot;, &quot;root&quot;); model.addAttribute(&quot;password&quot;, &quot;123&quot;); model.addAttribute(&quot;age&quot;, 20); return &quot;success&quot;; &#125; /** * 从session中获取值 * @return */ @RequestMapping(path=&quot;/find&quot;) public String find(ModelMap modelMap) &#123; String username = (String) modelMap.get(&quot;username&quot;); String password = (String) modelMap.get(&quot;password&quot;); Integer age = (Integer) modelMap.get(&quot;age&quot;); System.out.println(username + &quot; : &quot;+password +&quot; : &quot;+age); return &quot;success&quot;; &#125; 响应数据和结果视图 返回字符串 Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址 123456@RequestMapping(value=&quot;/hello&quot;) public String sayHello() &#123; System.out.println(&quot;Hello SpringMVC!!&quot;); // 跳转到XX页面 return &quot;success&quot;; &#125; 返回值是void 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到 可以使用请求转发或者重定向跳转到指定的页面 1234567891011@RequestMapping(value=&quot;/initAdd&quot;) public void initAdd(HttpServletRequest request,HttpServletResponse response) throws Exception &#123; System.out.println(&quot;请求转发或者重定向&quot;); // 请求转发 // request.getRequestDispatcher(&quot;/WEB-INF/pages/add.jsp&quot;).forward(request, response); // 重定向 // response.sendRedirect(request.getContextPath()+&quot;/add2.jsp&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); // 直接响应数据 response.getWriter().print(&quot;你好&quot;); return; &#125; 返回值是ModelAndView对象 ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图 model可以存储对象，view可以跳转页面 123456789101112131415@RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView()&#123; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); System.out.println(&quot;testModelAndView方法执行了...&quot;); // 模拟从数据库中查询出User对象 User user = new User(); user.setUsername(&quot;小凤&quot;); user.setPassword(&quot;456&quot;); user.setAge(30); // 把user对象存储到mv对象中，也会把user对象存入到request对象 mv.addObject(&quot;user&quot;,user); // 跳转到哪个页面 mv.setViewName(&quot;success&quot;); return mv; foward和redirect 123456@RequestMapping(&quot;/delete&quot;) public String delete() throws Exception &#123; System.out.println(&quot;delete方法执行了...&quot;); // return &quot;forward:/WEB-INF/pages/success.jsp&quot;; return &quot;forward:/user/findAll&quot;; &#125; 123456@RequestMapping(&quot;/count&quot;) public String count() throws Exception &#123; System.out.println(&quot;count方法执行了...&quot;); return &quot;redirect:/add.jsp&quot;; // return &quot;redirect:/user/findAll&quot;; &#125; ResponseBody响应json数据 DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而 不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 mvc:resources标签配置不过滤 location元素表示webapp目录下的包下的所有文件 mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b 1234&lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/&quot; /&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/&quot;/&gt; 使用@RequestBody获取请求体数据 1234@RequestMapping(&quot;/testJson&quot;) public void testJson(@RequestBody String body) &#123; System.out.println(body); &#125; 12345678910111213141516$(function () &#123; $(&quot;#btn&quot;).click(function () &#123; //alert(&quot;hello btn&quot;); $.ajax(&#123; // 编写json格式，设置属性和值 url:&quot;user/testAjax&quot;, contentType:&quot;application/json;charset=UTF-8&quot;, data:&apos;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&apos;, dataType:&quot;json&quot;, type:&quot;post&quot;, success:function(data) &#123; &#125; &#125;); &#125;); &#125;); 使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应 12345678910@RequestMapping(&quot;/testAjax&quot;) public @ResponseBody User testAjax(@RequestBody User user) &#123; System.out.println(&quot;响应ajax&quot;); //客户端发送请求，传的是json格式的数据，后端把数据封装到user对象中 System.out.println(user); //做响应 user.setAge(20); user.setUsername(&quot;haha&quot;); return user; &#125; 12345678910111213141516171819$(function () &#123; $(&quot;#btn&quot;).click(function () &#123; //alert(&quot;hello btn&quot;); $.ajax(&#123; // 编写json格式，设置属性和值 url:&quot;user/testAjax&quot;, contentType:&quot;application/json;charset=UTF-8&quot;, data:&apos;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&apos;, dataType:&quot;json&quot;, type:&quot;post&quot;, success:function(data) &#123; //data服务器响应的json数据，进行解析 alert(data); alert(data.usrname); alert(data.age); &#125; &#125;); &#125;); &#125;); 异常处理异常处理思路 异常处理步骤 controller类 123456789101112131415@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/testException&quot;) public String testException()throws Exception&#123; System.out.println(&quot;异常处理&quot;); try &#123; int i=1/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new myexception(&quot;出现异常&quot;); &#125; return &quot;success&quot;; &#125;&#125; 自定义异常类 123456789101112131415public class myexception extends Exception &#123; private String message; public myexception(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器 1234567891011121314151617181920public class myexceptionResolver implements HandlerExceptionResolver &#123; public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) &#123; //获取异常对象 myexception s=null; //instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例 //obj instanceof Class //其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。 if (ex instanceof myexception)&#123; s=(myexception) ex; &#125;else &#123; s=new myexception(&quot;程序在维护&quot;); &#125; //创建ModelAndView对象 ModelAndView mv=new ModelAndView(); mv.addObject(&quot;errormsg&quot;, s.getMessage()); mv.setViewName(&quot;error&quot;); return mv; &#125;&#125; 配置异常处理器 1&lt;bean id=&quot;myexceptionResolver&quot; class=&quot;cn.itcast.exception.myexceptionResolver&quot;&gt;&lt;/bean&gt; 拦截器 概念 SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链 中的拦截器会按着定义的顺序执行 拦截器和过滤器的功能比较类似，有区别 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术，拦截器是SpringMVC框架独有的 过滤器配置了/*，可以拦截任何资源，拦截器只会对控制器中的方法进行拦截 拦截器也是AOP思想的一种实现方式 ，想要自定义拦截器，需要实现HandlerInterceptor接口 使用步骤 创建类，实现HandlerInterceptor接口，重写需要的方法 1234567891011121314151617181920 public class interceptor1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;我要拦截你，interceptor1&quot;); //request.getRequestDispatcher(&quot;WEB-INF/pages/error.jsp&quot;).forward(request,response); //放行 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;拦截1已经执行了&quot;); //request.getRequestDispatcher(&quot;WEB-INF/pages/error.jsp&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;我TM最后&quot;); &#125;&#125; 在springmvc.xml中配置拦截器类 123456789&lt;!-- 配置拦截器的作用范围 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;&lt;!-- 用于指定排除的 url--&gt; &lt;bean id=&quot;handlerInterceptorDemo1&quot; class=&quot;com.itheima.web.interceptor.HandlerInterceptorDemo1&quot;&gt; &lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; HandlerInterceptor中的方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法， return false不放行，不会执行controller中的方法 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示 postHandle方法是在JSP执行后执行 request或者response不能再跳转页面了]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务进阶]]></title>
    <url>%2F2019%2F09%2F23%2F%E4%BA%8B%E5%8A%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一个没有加@Transactional注解的方法，去调用一个加了@Transactional的方法，会不会产生事务？ @Transactional： 对接口加上@Transactional注解,表示对该接口的所有实现类进行事务控制 对类加上@Transactional注解,表示对类中的所有方法进行事务控制 对具体某一方法加以@Transactional注解,表示对具体方法进行事务控制 一个@Transactional的方法 12345678@Transactionalpublic void deleteAllAndAddOneTransactional(Customer customer) &#123; customerRepository.deleteAll(); if (&quot;Yang&quot;.equals(customer.getFirstName())) &#123; throw new RuntimeException(); &#125; customerRepository.save(customer);&#125; 方法内先去执行deleteAll()，删除表中全部数据；然后执行save()保存数据。 这两个方法中间，会判断传进来的firstName是不是等于“Yang”，是，则抛异常，用于模拟两个数据库操作之间可能发生的异常场景。 如果没有加@Transactional注解，那么这两个操作就不在一个事务里面，不具有原子性。如果deleteAll之后抛异常，那么就会导致只删除不新增。 而加了@Transactional之后，这两个动作在一个事务里头，具有原子性，要么全部成功，要么全部失败。如果deleteAll之后抛异常，则事务回滚，恢复原先被删除的数据。 问题登场，这种情况下 12345678910111213public void deleteAllAndAddOne(Customer customer) &#123;System.out.println("go into deleteAllAndAddOne");deleteAllAndAddOneTransactional(customer);&#125;@Transactionalpublic void deleteAllAndAddOneTransactional(Customer customer) &#123;customerRepository.deleteAll();if ("Yang".equals(customer.getFirstName())) &#123;throw new RuntimeException();&#125;customerRepository.save(customer);&#125; 其实Spring的@Transactional，跟Spring AOP一样，都是利用了动态代理。 我们写了一个类，里面写了一个加了@Transactional注解的方法，这原本平淡无奇，什么用也没有，就像这样： 关键在于，Spring在检查到@Transactional注解之后，给这个对象生成了一个代理对象proxy： 代理对象的methodB，会先开启事务（beginTransaction），然后再去执行原先对象target的methodB，如果抛异常，则回滚（rollBack），如果一切顺利，则提交（commit）。 而最后注入Spring容器的，也正是这个带有事务逻辑的代理对象。所以我们调用methodB时会产生事务。 现在，我们写了一个新方法，methodA，里头去调用methodB： 由于methodA没有加@Transactional注解，所以代理对象里面，直接就是target.methodA()，直接调用了原来对象的methodA。 这下就很清晰了，代理对象的methodA，去调用原来对象的methodA，原来对象的methodA，再去调用原来对象的methodB，而原来对象的methodB，是不具有事务的。事务只存在于代理对象的methodB. 所以整个方法也就没有事务了。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP]]></title>
    <url>%2F2019%2F09%2F22%2FAOP%2F</url>
    <content type="text"><![CDATA[AOP相关概念Joinpoint(连接点): 被拦截到的方法. Pointcut(切入点): 我们对其进行增强的方法. Advice(通知/增强): 对切入点进行的增强操作 ​ 包括前置通知,后置通知,异常通知,最终通知,环绕通知 Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 Aspect(切面): 是切入点和通知的结合 使用XML配置AOP 在bean.xml中引入约束并将通知类注入Spring容器中 使用&lt;aop:config&gt;标签声明AOP配置,所有关于AOP配置的代码都写在&lt;aop:config&gt;标签内 使用&lt;aop:aspect&gt;标签配置切面,其属性如下 id: 指定切面的id ref: 引用通知类的id 使用&lt;aop:pointcut&gt;标签配置切入点表达式,指定对哪些方法进行增强,其属性如下 使用&lt;aop:xxx&gt;标签配置对应类型的通知方法 其属性如下: method: 指定通知类中的增强方法名.ponitcut-ref: 指定切入点的表达式的idpoinitcut: 指定切入点表达式其中pointcut-ref和pointref属性只能有其中一个 具体的通知类型: aop:before：配置前置通知,指定的增强方法在切入点方法之前执行.aop:after-returning：配置后置通知,指定的增强方法在切入点方法正常执行之后执行.aop:afetr-throwing：配置异常通知,指定的增强方法在切入点方法产生异常后执行.aop:after：配置最终通知,无论切入点方法执行时是否发生异常,指定的增强方法都会最后执行.aop:around： 配置环绕通知,可以在代码中手动控制增强代码的执行时机. 1234567891011121314151617181920212223242526272829&lt;!-- 配置Logger类，以后相当于事务控制类 --&gt;&lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行 &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot; &gt;&lt;/aop:before&gt;--&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;--&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;--&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;--&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 环绕通知 前置通知,后置通知,异常通知,最终通知的执行顺序 Spring是基于动态代理对方法进行增强的,前置通知,后置通知,异常通知,最终通知在增强方法中的执行时机如下: 类似于动态代理 123456789101112131415161718// 增强方法@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; Object rtValue = null; try &#123; // 执行前置通知 // 执行原方法 rtValue = method.invoke(accountService, args); // 执行后置通知 return rtValue; &#125; catch (Exception e) &#123; // 执行异常通知 &#125; finally &#123; // 执行最终通知 &#125;&#125; 环绕通知允许我们更自由地控制增强代码执行的时机 Spring框架为我们提供一个接口ProceedingJoinPoint,它的实例对象可以作为环绕通知方法的参数,通过参数控制被增强方法的执行时机. ProceedingJoinPoint对象的getArgs()方法返回被拦截的参数ProceedingJoinPoint对象的proceed()方法执行被拦截的方法 123456789101112131415// 环绕通知方法,返回Object类型public Object printLogAround(ProceedingJoinPoint pjp) &#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); printLogBefore(); // 执行前置通知 rtValue = pjp.proceed(args);// 执行被拦截方法 printLogAfterReturn(); // 执行后置通知 &#125;catch(Throwable e) &#123; printLogAfterThrowing(); // 执行异常通知 &#125;finally &#123; printLogAfter(); // 执行最终通知 &#125; return rtValue;&#125; spring中对AOP的注解用于声明切面的注解 @Aspect: 声明当前类为通知类,该类定义了一个切面.相当于xml配置中的&lt;aop:aspect&gt;标签 12345@Component(&quot;logger&quot;)@Aspectpublic class Logger &#123; // ...&#125; 用于声明通知的注解@Before: 声明该方法为前置通知.相当于xml配置中的aop:before标签@AfterReturning: 声明该方法为后置通知.相当于xml配置中的aop:after-returning标签@AfterThrowing: 声明该方法为异常通知.相当于xml配置中的aop:after-throwing标签@After: 声明该方法为最终通知.相当于xml配置中的aop:after标签@Around: 声明该方法为环绕通知.相当于xml配置中的aop:around标签属性: ​ value: 用于指定切入点表达式或切入点表达式的引用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component(&quot;logger&quot;)@Aspect //表示当前类是一个通知类public class Logger &#123; // 配置前置通知 @Before(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogBefore()&#123; System.out.println(&quot;前置通知Logger类中的printLogBefore方法开始记录日志了。。。&quot;); &#125; // 配置后置通知 @AfterReturning(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfterReturning()&#123; System.out.println(&quot;后置通知Logger类中的printLogAfterReturning方法开始记录日志了。。。&quot;); &#125; // 配置异常通知 @AfterThrowing(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfterThrowing()&#123; System.out.println(&quot;异常通知Logger类中的printLogAfterThrowing方法开始记录日志了。。。&quot;); &#125; // 配置最终通知 @After(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfter()&#123; System.out.println(&quot;最终通知Logger类中的printLogAfter方法开始记录日志了。。。&quot;); &#125; // 配置环绕通知 @Around(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs(); printLogBefore(); // 执行前置通知 rtValue = pjp.proceed(args); // 执行切入点方法 printLogAfterReturning(); // 执行后置通知 return rtValue; &#125;catch (Throwable t)&#123; printLogAfterThrowing(); // 执行异常通知 throw new RuntimeException(t); &#125;finally &#123; printLogAfter(); // 执行最终通知 &#125; &#125;&#125; 用于指定切入点表达式的注解 @Pointcut: 指定切入点表达式,其属性如下: value: 指定表达式的内容 @Pointcut注解没有id属性,通过调用被注解的方法获取切入点表达式. 1234567891011121314151617181920212223242526@Component(&quot;logger&quot;)@Aspect //表示当前类是一个通知类public class Logger &#123; // 配置切入点表达式 @Pointcut(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) private void pt1()&#123;&#125; // 通过调用被注解的方法获取切入点表达式 @Before(&quot;pt1()&quot;) public void printLogBefore()&#123; System.out.println(&quot;前置通知Logger类中的printLogBefore方法开始记录日志了。。。&quot;); &#125; // 通过调用被注解的方法获取切入点表达式 @AfterReturning(&quot;pt1()&quot;) public void printLogAfterReturning()&#123; System.out.println(&quot;后置通知Logger类中的printLogAfterReturning方法开始记录日志了。。。&quot;); &#125; // 通过调用被注解的方法获取切入点表达式 @AfterThrowing(&quot;pt1()&quot;) public void printLogAfterThrowing()&#123; System.out.println(&quot;异常通知Logger类中的printLogAfterThrowing方法开始记录日志了。。。&quot;); &#125;&#125; 纯注解配置AOP1234567@Configuration@ComponentScan(basePackages=&quot;cn.maoritian&quot;)@EnableAspectJAutoProxy // 允许AOPpublic class SpringConfiguration &#123; // 具体配置 //...&#125; 参考链接https://blog.csdn.net/ncepu_Chen/article/details/94510298#SpringAOP_159]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是泛型泛型：把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 相关术语： ArrayList：E为类型参数变量 ArrayList：实际类型参数 整个ArrayList为泛型类型 整个ArrayList为参数化的类型 为什么需要泛型没有泛型的情况下： Collection、Map集合对元素的类型是没有任何限制的。本来我的Collection集合装载的是全部的Dog对象，但是外边把Cat对象存储到集合中，是没有任何语法错误的。 把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是Object。因此在get()的时候，返回的是Object。外边获取该对象，还需要强制转换 有泛型的情况下： 程序简洁（不用强制转换） 程序健壮（只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常） 可读性和稳定性（在编写集合的时候，就限定了类型） Example 1234567891011//创建集合对象ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);//遍历,由于明确了类型.我们可以增强forfor (String s : list) &#123; System.out.println(s);&#125; 泛型类 泛型方法泛型类泛型类：泛型定义在类上，用户使用该类的时候，才把类型明确下来 基本格式： 123456789101112131415/* 1:把泛型定义在类上 2:类型变量定义在类上,方法中也可以使用 */public class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125; 用户想要使用哪种类型，就在创建的时候指定类型。使用的时候，该类就会自动转换成用户想要使用的类型了。 123456789101112131415161718public static void main(String[] args) &#123; //创建对象并指定元素类型 ObjectTool&lt;String&gt; tool = new ObjectTool&lt;&gt;(); tool.setObj(new String(&quot;xxx&quot;)); String s = tool.getObj(); System.out.println(s); //创建对象并指定元素类型 ObjectTool&lt;Integer&gt; objectTool = new ObjectTool&lt;&gt;(); /** * 如果我在这个对象里传入的是String类型的,它在编译时期就通过不了了. */ objectTool.setObj(10); int i = objectTool.getObj(); System.out.println(i);&#125; 泛型方法在类上定义的泛型在方法上也能用，那泛型方法的适用情况是什么呢 小题大做：我就想在一个方法上使用泛型，又不要考虑其他的，把整个类都泛型不是有点多余了吗 基本格式： 12345//定义泛型方法..public &lt;T&gt; void show(T t) &#123; System.out.println(t);&#125; 12345678910public static void main(String[] args) &#123; //创建对象 ObjectTool tool = new ObjectTool(); //调用方法,传入的参数是什么类型,返回值就是什么类型 tool.show(&quot;hello&quot;); tool.show(12); tool.show(12.5);&#125; 泛型类的子类泛型类本质上还是一个类，可以被继承 子类明确泛型类的类型参数变量 子类不明确泛型类的类型参数变量 明确类型参数变量1234567/* 把泛型定义在接口上 */public interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125; 1234567891011/** * 子类明确泛型类的类型参数变量: */public class InterImpl implements Inter&lt;String&gt; &#123; @Override public void show(String s) &#123; System.out.println(s); &#125;&#125; 不明确类型参数变量 当子类不明确泛型类的类型参数变量时，外界使用子类的时候，也需要传递类型参数变量进来，在实现类上需要定义出类型参数变量 12345678910public static void main(String[] args) &#123; //测试第一种情况 //Inter&lt;String&gt; i = new InterImpl(); //i.show(&quot;hello&quot;); //第二种情况测试 Inter&lt;String&gt; ii = new InterImpl&lt;&gt;(); ii.show(&quot;100&quot;);&#125; 类型通配符12345678public void test(List list)&#123; for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125;&#125; 像这个遍历集合list是可以的，但是会有警告，没有明确类型 12345678public void test(List&lt;Object&gt; list)&#123; for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125;&#125; 这样行不行呢？只能遍历装载Object类型的集合 那怎么办呢，就用到我们的类型通配符了 12345678public void test(List&lt;?&gt; list)&#123; for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125;&#125; ?号通配符表示可以匹配任意类型，任意的Java类都可以匹配….. 现在非常值得注意的是，当我们使用?号通配符的时候：就只能调对象与类型无关的方法，不能调用对象与类型有关的方法。 也就是说直到我们在这遍历才知道集合元素具体的类型，现在是不知道的，不能使用类似add()的方法，往里面加元素， 通配符上限1List&lt;? extends Number&gt; 上面的代码表示的是：List集合装载的元素只能是Number的子类或自身 123456789101112131415public static void main(String[] args) &#123; //List集合装载的是Integer，可以调用该方法 List&lt;Integer&gt; integer = new ArrayList&lt;&gt;(); test(integer); //List集合装载的是String，在编译时期就报错了 List&lt;String&gt; strings = new ArrayList&lt;&gt;(); test(strings);&#125;public static void test(List&lt;? extends Number&gt; list) &#123; &#125; 通配符和泛型方法大多时候，我们都可以使用泛型方法来代替通配符的….. 123456789//使用通配符public static void test(List&lt;?&gt; list) &#123;&#125;//使用泛型方法public &lt;T&gt; void test2(List&lt;T&gt; t) &#123; &#125; 原则： 如果参数之间的类型有依赖关系，或者返回值是与参数之间有依赖关系的。那么就使用泛型方法 如果没有依赖关系的，就使用通配符，通配符会灵活一些. 类型擦除类型擦除就是虚拟机对泛型其实一无所知，所有的工作都是编译器做的 我们编写的泛型类 1234567891011121314public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125; 虚拟机执行的代码： 1234567891011121314public class Pair &#123; private Object first; private Object last; public Pair(Object first, Object last) &#123; this.first = first; this.last = last; &#125; public Object getFirst() &#123; return first; &#125; public Object getLast() &#123; return last; &#125;&#125; 所以编译器干了2件事： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 我们使用泛型时 123Pair&lt;String&gt; p = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);String first = p.getFirst();String last = p.getLast(); 虚拟机的视角： 123Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;);String first = (String) p.getFirst();String last = (String) p.getLast(); 所以编译器真的牛批，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。 也因为这样，泛型的局限就出来 不能是基本数据类型 不能取得带泛型的class Pair&lt;String&gt; p1 = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;); Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456); Class c1 = p1.getClass(); Class c2 = p2.getClass(); System.out.println(c1==c2); // true System.out.println(c1==Pair.class); // truePair是一个泛型类 编译器把都看作是Object，我们对Pair&lt;String&gt;和Pair&lt;Integer&gt;类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。 换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair&lt;Object&gt;。 不能实例化类型 123456789public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair() &#123; // Compile error: first = new T(); last = new T(); &#125;&#125; ​ 因为擦除，first = new T()， last = new T()都变成了first = new Object(); last = new Object();那你创建new Pair()和new Pair()就都是Object，显然编译器不会让你这么干的 泛型的应用只写一个抽象DAO，别的DAO只要继承该抽象DAO，就有对应的方法了。 抽象DAO 1234567891011121314151617181920212223242526272829303132333435public abstract class BaseDao&lt;T&gt; &#123; //模拟hibernate.... private Session session; private Class clazz; //哪个子类调的这个方法，得到的class就是子类处理的类型（非常重要） public BaseDao()&#123; Class clazz = this.getClass(); //拿到的是子类 ParameterizedType pt = (ParameterizedType) clazz.getGenericSuperclass(); //BaseDao&lt;Category&gt; clazz = (Class) pt.getActualTypeArguments()[0]; System.out.println(clazz); &#125; public void add(T t)&#123; session.save(t); &#125; public T find(String id)&#123; return (T) session.get(clazz, id); &#125; public void update(T t)&#123; session.update(t); &#125; public void delete(String id)&#123; T t = (T) session.get(clazz, id); session.delete(t); &#125; &#125; 123public class CategoryDao extends BaseDao&lt;Category&gt; &#123;&#125; 1234public class BookDao extends BaseDao&lt;Book&gt; &#123;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习Spring的AOP之前，有必要对动态代理有所了解（本文全部参考最后的参考文章链接） 静态代理 为现有每个类编写一个对应的代理类，并且实现相同的接口 在代理对象中通过构造器塞入目标对象，实现相同方法并进行增强。这样，我们只需要代理对象，原对象可以不用了 缺点：每个类都需要一个代理，如果是成百上千的类，岂不是得要一堆代理类，系统臃肿。 动态代理对象创建原理 在创建实例对象之前会创建一个Class对象，而Class对象是Class类的实例，Class类是描述所有类的 所以如果我们能拿到代理Class对象，从而通过反射创建对象实例，不就可以不写代理类吗 Class对象 包含有类的全部信息，构造器，方法等，那我们怎么才能获取这些信息？ 接口，因为代理类和目标对象都实现了相同的接口，从接口那我们可以获取要的全部信息。问题又来了，接口不能 实例化，那怎么办？这就进入正题了 动态代理jdk提供了 java.lang.reflect.Proxy类和 java.lang.reflect.InnovationHandler接口来帮助我们 Proxy有个静态方法，proxy.getProxyClass(ClassLoader,interfaces)，通过传入类加载器和接口，返回Class对象 这个方法会从传入的接口Class，复制一份，并且加了个构造器，这样这个新的Class对象可以创建对象了。 一句话，proProxyClass()方法以Class对象造Class对象 下图为第一阶段方案，后面会越来越简单 在获得构造器后，通过反射创造代理实例 在创建Class对象时，需要传入InnocationHandler。在调用代理对象的方法时，会自动调用InnocationHandler的invoke方法 12Object invoke(Object proxy,Method method,Object[] args) 在代理实例上处理方法调用并返回结果 怎么调用呢？ 原理：如下图，每个代理对象内部都由一个 InvocationHandler，且在执行内部方法时都会调用handler.invoke()方法 inInvocationHandler接收三个参数 proxy，代理后的实例对象。 method，当前执行的方法。 args，当前方法的参数。 仔细看上图，inInvocationHandler的invoke()方法并没有写入目标对象，所以需要我们每次都new一个目标对象。 但是我们每次都是先new一个目标对象，然后去执行目标对象的方法，这样会带来一个问题：来一个目标对象就要new一个，这谁顶得住，所以有了下面的优化1(也就是把类的实例化过程提取出来，便利了一点，本质没变) 优化2，不用getProxyClass()，用Proxy.newProxyInstance，直接把中间得到代理class对象给隐藏了 12345678910111213141516171819202122232425262728293031323334353637383940414243public IAccountService getAccountService() &#123; return (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 添加事务的支持 * * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(&quot;test&quot;.equals(method.getName()))&#123; return method.invoke(accountService,args); &#125; Object rtValue = null; try &#123; //1.开启事务 txManager.beginTransaction(); //2.执行操作 rtValue = method.invoke(accountService, args); //3.提交事务 txManager.commit(); //4.返回结果 return rtValue; &#125; catch (Exception e) &#123; //5.回滚操作 txManager.rollback(); throw new RuntimeException(e); &#125; finally &#123; //6.释放连接 txManager.release(); &#125; &#125; &#125;); &#125;&#125; 说白了一个返回代理class对象，一个返回代理对象 总的流程 ​ 参考链接 https://www.zhihu.com/question/20794107/answer/658139129]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入]]></title>
    <url>%2F2019%2F09%2F16%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[依赖注入概念依赖注入(Dependency Injection)是spring框架核心ioc的具体实现. 通过控制反转,我们把创建对象托管给了spring,但是代码中不可能消除所有依赖,例如:业务层仍然会调用持久层的方法,因此业务层类中应包含持久化层的实现类对象.我们等待框架通过配置的方式将持久层对象传入业务层,而不是直接在代码中new某个具体的持久化层实现类,这种方式称为依赖注入. 注入方法使用构造函数注入&lt;constructor-arg&gt;用来定义构造函数的参数,其属性可大致分为两类 寻找要赋值的字段 index：指定参数在构造函数参数列表的索引位置 name：指定参数在构造函数中的数据类型 type：指定参数在构造函数中的变量名,最常用的属性 给字段赋值 value：给基本数据类型和String类型赋值 ref：给其它Bean类型的字段赋值 1234567891011121314151617public class AccountServiceImpl implements IAccountService &#123; //如果是经常变化的数据,并不适用于注入的方式 private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 123456789&lt;!-- 使用Date类的无参构造函数创建Date对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;myname&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- birthday字段为已经注册的bean对象,其id为now --&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 使用set注入在类中提供需要注入成员属性的set方法,创建对象只调用要赋值属性的set方法 &lt;property&gt;,用来定义要调用set方法的成员. 其主要属性可大致分为两类: 指定要调用set方法赋值的成员字段 name：要调用set方法赋值的成员字段 指定赋给字段的值 value：给基本数据类型和String类型赋值 ref：给其它Bean类型的字段赋值 123456789101112131415161718192021public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 123456789&lt;!-- 使用Date类的无参构造函数创建Date对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;myname&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;!-- birthday字段为已经注册的bean对象,其id为now --&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 集合注入集合字段及其对应的标签按照集合的结构分为两类： 只有键的结构: 数组字段：&lt;array&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 List字段：&lt;list&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 Set字段：&lt;set&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 其中&lt;array&gt;,&lt;list&gt;,&lt;set&gt;标签之间可以互相替换使用. 键值对的结构: Map字段： &lt;map&gt;标签表示集合,&lt;entry&gt;标签表示集合内的键值对,其key属性表示键,value属性表示值 Properties字段：&lt;props&gt;标签表示集合,&lt;prop&gt;标签表示键值对,其key属性表示键,标签内的内容表示值. 下面使用set方法注入各种集合字段 12345678910111213141516171819202122232425262728293031323334public class AccountServiceImpl implements IAccountService &#123; // 集合字段 private String[] myArray; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; // 集合字段的set方法 public void setMyStrs(String[] myArray) &#123; this.myArray = myArray; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myArray)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl3&quot;&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;array&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot;&gt; &lt;value&gt;value2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;myProps&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;value1&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;value2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ApplicationContext]]></title>
    <url>%2F2019%2F09%2F16%2Fspring%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[概述 ApplicationContext是spring的容器接口，通过idea我们来看一下其继承关系 BeanFactory和ApplicatonContext区别BeanFactory才是spring的顶层接口，ApplicatonContext是其子接口，主要区别 ApplicationContext：只要一读取配置文件，默认情况下就会创建对象（立即加载） 12345ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml");IAcountService acountService=(IAcountService)ac.getBean("IAcountService");System.out.println(acountService);结果：在执行完ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml");就输出了“对象被加载了”，即读取完配置文件对象就被加载 BeanFactory什么时候要用对象才创建（延迟加载） 123456789public IAcountService() &#123; System.out.println("对象加载了");&#125; Resource resource = new ClassPathResource("bean.xml");BeanFactory beanFactory=new XmlBeanFactory(resource);IAcountService acountService1=(IAcountService)beanFactory.getBean("IAcountService");System.out.println(acountService1);结果：执行System.out.println(acountService1);才输出了“对象被加载了” ApplicationContext接口3个实现类 ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件 AnnotationConfigApplicationContext：读取注解创建容器 ClassPathXmlApplicationContext基本使用 123456public class client &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAcountService acountService1=(IAcountService) ac.getBean(&quot;IAcountService&quot;); &#125;&#125; AnnotationConfigApplicationContext基本使用 123456789101112@Configuration//相当于原来的bean.xml@ComponentScan(basePackages = &quot;com.xjh&quot;)//相当于&lt;context:component-scan&gt;&lt;/&gt;public class springConfig &#123; @Bean(name = &quot;IAcountService&quot;) public IAcountService getBean()&#123; return new IAcountService(); &#125;&#125;ApplicationContext ac=new AnnotationConfigApplicationContext(springConfig.class);IAcountService acountService=(IAcountService)ac.getBean(&quot;IAcountService&quot;)System.out.println(acountService);]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化序列化和反序列化的概念序列化：把对象转换成字节序列的过程 反序列化：把字节序列转换成对象的过程 什么时候使用序列化 对象序列化可以实现分布式对象。主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制“，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 序列化可以将内存中的类写入文件或数据库中。比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。 对象、文件、数据，有许多不同的格式，很难统一传输和保存。序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件 （上面也就存储在文件上用过，其余的没试过，参考的网上不错的总结，以后用到再补充） 主要用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中 在网络上传送对象的字节序列（当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象） 点进Serializable接口看一下 一个问题点进Serializable接口看一下 12public interface Serializable &#123;&#125; 里面啥都没有，它是一个空接口，仅仅是一个标识，用来告诉jvm进行序列化，真正的序列化操作不是由他来完成的 类 ObjectInputStream ObjectOutputStream1public final void writeObject(Object x) throws IOException 序列化一个对象，并将它发送到输出流 12public final Object readObject() throws IOException, ClassNotFoundException从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型 123456789101112131415161718192021public class ObjectOut &#123; public static void main(String[] args) throws IOException &#123; byte[] a; Phone phone1 = new Phone(&quot;小米&quot;); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(phone1); a=byteArrayOutputStream.toByteArray(); objectOutputStream.flush(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(a)); try &#123; Phone phone2=(Phone) objectInputStream.readObject(); System.out.printf(phone2.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 作为构造函数可以是byteArrayOutputStream，也可以是fileOutPutStream，因为还没看源码，实际感觉ObjectOutputStream是借助于其他流来写入和读取 transient和static修饰的变量不会被序列化 关于serialversionUID变量如果自己没有声明一个serialVersionUID变量，默认会自动生成一个serialVersionUID，但是推荐自己写一个，因为默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常。 serialVersionUID作用：用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialVersionUID与当前类当中的serialVersionUID一致，那么该对象才能被反序列化成功。 serialVersionUID的工作机制： 序列化时serialVersionUID会被写入到序列化的文件中去 反序列化时JVM会把传来的字节流中的serialVersionUID于本地相应实体类的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常。 参考文档 https://www.jianshu.com/p/664ef87f5fdb https://baijiahao.baidu.com/s?id=1633305649182361563&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2019%2F09%2F09%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final关键字final关键字基本用法 final修饰类 当一个类用final修饰时，这个类就不能被继承了。所以在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。 final修饰方法 如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的 final修饰变量 final成员变量表示常量，只能被赋值一次，赋值后值不再改变 先来个很常见的题目引入 1234567891011public class Test &#123; public static void main(String[] args) &#123; String a = &quot;hello2&quot;; final String b = &quot;hello&quot;; String d = &quot;hello&quot;; String c = b + 2; String e = d + 2; System.out.println((a == c)); System.out.println((a == e)); &#125; &#125; ​ 分析：final变量是基本数据类型以及String类型时 ，如果在编译器就知道其确切值，编译器就会把它当作常量来看，所以b会直接以hello来替代。常量字符串的“+”操作，编译阶段直接会合成为一个字符串。在编译期间，这种拼接会被优化，编译器直接帮你拼好 ，如string str=”ja”+”va”，在编译阶段会直接合并成语句String str=”java”，于是会去常量池中查找是否存在”java” ，从而进行创建或引用，这里的c即为“hello”+2，也就是“hello2”，所以a和c指向的是同一个hello2，而a和e则是不同对象，为什么呢，一开始我也不知道，在查阅相关博客后，对常量池等知识有了了解，下面对String创建的变量进行详细解析。 new String都是在堆上创建字符串对象。 其实这里常量池中也会有一个“abcd”的字符串，当new时，会拷贝一份该字符串存放到堆中，于是y指向了堆中的那个“abcd”字符串 。 1234567String s = new String(&quot;abc&quot;);String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); System.out.println(s == s1);System.out.println(s == s2);System.out.println(s1 == s2); 这里在详细分析以下这两行代码： 首先在常量池中创建abc对象，然后new关键字会在堆里再创建一个对象，在堆里的这个对象则是在栈中的s1所指向的 当轮到s2时，首先同样会在常量池中看有没有abc，这里已经有了，则不用自己创建。然后new自己创建一个在堆中的对象，s2指向这个对象 所以虽然s1和s2指向的最终内容都是abc，但它们是2个不同的对象，因为指向的是不同堆对象 通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。 再来个经典例子： 12345678910111213141516 1 String s1 = &quot;Hello&quot;; 2 String s2 = &quot;Hello&quot;; 3 String s3 = &quot;Hel&quot; + &quot;lo&quot;; 4 String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;); 5 String s5 = new String(&quot;Hello&quot;); 6 String s6 = s5.intern(); 7 String s7 = &quot;H&quot;; 8 String s8 = &quot;ello&quot;; 9 String s9 = s7 + s8;10 11 System.out.println(s1 == s2); // true12 System.out.println(s1 == s3); // true13 System.out.println(s1 == s4); // false14 System.out.println(s1 == s9); // false15 System.out.println(s4 == s5); // false16 System.out.println(s1 == s6); // true s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。 s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。 s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同 s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同 s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。 s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。 注意：只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中 常量池 Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 ​ 所谓静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：*字面量(Literal)和符号引用量**(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名 字段名称和描述符 方法名称和描述符 ​ 而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 常量池的好处 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。 （1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。 （2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 参考博客：https://www.cnblogs.com/lizhangyong/p/8909329.html ​ https://www.cnblogs.com/xiaoxi/p/6392154.html]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpServletRequest,HttpServletResponse]]></title>
    <url>%2F2019%2F09%2F08%2FHttpServlet%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[HttpServletRequestHttpServletRequest 对象是一个专门用来存储HTTP 请求信息的对象 HttpServletRequest对象的由来 浏览器发送的http请求既要存储又要保证完整性，Servlet的解决方案就是创建一个对象进行存储，每接受一个请求，服务器就要创建一个对象进行存储 HttpServletRequest对象中存储请求信息，服务器调用servlet时将request对象作为参数传给Servlet方法 HttpServletRequest常用方法 getMethod（）获取请求方法 getRequestUrl（ ）获取完整请求路径` String getServletPath（）返回调用的请求的 URL 的一部分（拦截器就用到了） String getParameter(String name) 以字符串形式返回请求参数的值 HttpSession getSession() 返回与该请求关联的当前 session 会话 Object getAttribute(String name) 以对象形式返回已命名属性的值 HTTP请求格式请求行 请求头 请求空行 请求体： 如有POST请求 那么数据体 在Form Data里 HttpServletResponseHttpServletResponse常用方法 void setContentType(String type) 设置被发送到客户端的响应的内容类型，一般printwiter会用到 PrintWriter getWriter() throws IOException 服务器输出字符数据到浏览器，这个方法是其父接口ServletResponse的方法 ServletOutputStream getOutputStream() throws IOException 服务器输出字节数据到浏览器，这个方法也是其父接口ServletResponse的方法 HTTP响应体格式响应行：协议/版本 响应状态码 状态码描述 123451xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急...2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。 响应头：键值对形式 ，例如Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 响应空行 响应体：传输的数据 验证码部分代码12345678910111213141516171819202122232425262728@Componentpublic class LoginFilter extends GenericFilter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse resp=(HttpServletResponse)servletResponse; if (&quot;POST&quot;.equalsIgnoreCase(req.getMethod())&amp;&amp;&quot;/doLogin&quot;.equals(req.getServletPath()))&#123; String code = req.getParameter(&quot;code&quot;); String verify_code =(String) req.getSession().getAttribute(&quot;verify_code&quot;); if (code==null||&quot;&quot;.equals(code)||!verify_code.toLowerCase().equals(code.toLowerCase()))&#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); //RespBean.error(&quot;验证码错误&quot;))是一个对象，RestController=controller+responsebody把对象转换成json字符串输出 //ObjectMapper是jackson的李哥类，用来json和对象的相互转化 out.write(new ObjectMapper().writeValueAsString(RespBean.error(&quot;验证码错误&quot;))); out.flush(); out.close(); return; &#125;else &#123; filterChain.doFilter(req,resp); &#125; &#125;else &#123; filterChain.doFilter(req,resp); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器作用 对服务器接受的资源和响应给浏览器的资源进行管理 保护servlet 使用 创建一个实现Filter接口的普通java类 覆写接口的方法 init方法：服务器启动即执行，资源初始化 doFilter方法：拦截请求，在此方法中对资源实现管理 要手动对资源放行：chain.doFilter(request,response) destroy方法：服务器关闭 在web.xml配置过滤器（是服务器在使用过滤器） url-patten：/*表示拦截所有请求。 ​ url-patten：*.do 表示所有以.do结尾的请求。一般用来进行模块拦截。 ​ url-patten：/ts 表示拦截指定url的请求，针对某个servlet拦截，保护servlet 过滤器生命周期：服务器启动到关闭。执行机制浏览器发起请求到服务器，服务器接到请求后，根据url在web.xml中找到对应的过滤器执行doFilter方法，该方法对此次请求进行处理后如果符合则放行，放行后还有其他符合要求的进行过滤，找到执行对应的servlet进行处理。servlet对请求处理完毕后，service方法结束。还需继续返回相应的doFilter检修执行 验证码拦截器12345678910111213141516171819202122232425262728@Componentpublic class LoginFilter extends GenericFilter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse resp=(HttpServletResponse)servletResponse; if (&quot;POST&quot;.equalsIgnoreCase(req.getMethod())&amp;&amp;&quot;/doLogin&quot;.equals(req.getServletPath()))&#123; String code = req.getParameter(&quot;code&quot;); String verify_code =(String) req.getSession().getAttribute(&quot;verify_code&quot;); if (code==null||&quot;&quot;.equals(code)||!verify_code.toLowerCase().equals(code.toLowerCase()))&#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); //RespBean.error(&quot;验证码错误&quot;))是一个对象，RestController=controller+responsebody把对象转换成json字符串输出 //ObjectMapper是jackson的李哥类，用来json和对象的相互转化 out.write(new ObjectMapper().writeValueAsString(RespBean.error(&quot;验证码错误&quot;))); out.flush(); out.close(); return; &#125;else &#123; filterChain.doFilter(req,resp); &#125; &#125;else &#123; filterChain.doFilter(req,resp); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和session]]></title>
    <url>%2F2019%2F09%2F08%2FCookie%2F</url>
    <content type="text"><![CDATA[CookieCookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息 。简单例子就是淘宝等账户几天内不用重复登陆。 识别返回用户包括三个步骤： 服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上，以备将来使用。 当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户 cookie设置过程： 客户端发送一个http请求到服务器端 服务器端发送一个http响应到客户端，其中包含Set-Cookie头部 客户端发送一个http请求到服务器端，其中包含Cookie头部 服务器端发送一个http响应到客户端 这里给一个Cookie响应头例子 1234567HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=runoob.comConnection: closeContent-Type: text/html Set-Cookie中包含了键值对、一个 GMT 日期、一个路径和一个域 。 使用： 创建一个Cookie对象，cookie 名称和 cookie 值都是字符串 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 设置最大生命周期（以秒为单位） 1cookie.setMaxAge(60*60*24); 发送Cookie到HTTP响应头 1response.addCookie(cookie); 代码示例 123456Cookie cookie=new Cookie(&quot;name&quot;,request.getParameter(&quot;name&quot;));Cookie url=new Cookie(&quot;url&quot;,request.getParameter(&quot;url&quot;));cookie.setMaxAge(60*60*24);url.setMaxAge(60*60*24);response.addCookie(cookie);response.addCookie(url); 特点： 这是浏览器端的数据存储技术 数据声明是在服务器 2种存储 临时存储：数据存储在浏览器运行内存中，关了就没了 ​ 定时存储：到期之后才会没得 SessionSession是另一种记录浏览器状态的机制，Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务把用户的信息，以某种形式记录在服务器，这就是Session 如图，浏览器中只有jessionId的键值对，cookie对象中也只有jessionid，用户信息均存在服务器中，用户下次发送请求中会携带jessionId，服务器会识别。 对比可知，cookie直接以 [{user:xavier},{gender:man}]的格式放在客户端cookie上的，而session是用[{“JsessionId:xxxx”}]的格式放在客户端cookie，然后在再次访问的时候运用读取JessionId的值即(xxxx)的方式在服务器域对象里面找到对应的数据，既 [{user:xavier},{gender:man}]。 特点： 存储在服务器 服务器进行创建 依赖Cookie技术 一次会话 默认存储时间30分钟 使用： 创建session对象/获取session对象 HttpSession hs=request.getSession() 这么理解：如果创建了session，那么在浏览器中会有JSESSIONID，那么就会返回session对象 如果没有创建，那么新建一个 设置session存储时间 hs.invalidate( ) 存储数据 hs.setAttribute(String name,Object value) 获取数据 hs.getAttribute(String name) 使用情景 ​ 用户登陆时将用户信息存入session中，供该用户的其他请求使用 注意 ​ JESSIONID是在浏览器中，关闭浏览器就没得了 ​ 存储和获取是在不同请求，即http://aa http://bb这样不同请求，但存储要先于获取 作用域 ​ 一次会话（即可以多次请求，主要session没失效） 代码示例 1234567891011protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); //获取请求信息 String name=&quot;张三&quot;; //处理消息 //创建session对象 HttpSession ps=request.getSession(); System.out.println(ps.getId()); ps.setAttribute(&quot;name&quot;,name);&#125; 12345678response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);//获取请求信息String name=&quot;张三&quot;;//处理消息//创建session对象HttpSession ps=request.getSession();System.out.println(&quot;session2&quot;+ps.getId());System.out.println(&quot;session2&quot;+ps.getAttribute(&quot;name&quot;));]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和session]]></title>
    <url>%2F2019%2F09%2F08%2Fsession%E5%92%8CCookie%2F</url>
    <content type="text"><![CDATA[CookieCookie 是存储在客户端计算机上的文本文件（本地的），并保留了各种跟踪信息 。简单例子就是淘宝等账户几天内不用重复登陆。（用户登陆信息） 识别返回用户包括三个步骤 服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上，以备将来使用。 当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户 cookie设置过程 客户端发送一个http请求到服务器端 服务器端发送一个http响应到客户端，其中包含Set-Cookie头部 客户端发送一个http请求到服务器端，其中包含Cookie头部 服务器端发送一个http响应到客户端 这里给一个Cookie响应头例子 1234567HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=runoob.comConnection: closeContent-Type: text/html Set-Cookie中包含了键值对、一个 GMT 日期、一个路径和一个域 。 使用 创建一个Cookie对象，cookie 名称和 cookie 值都是字符串 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 设置最大生命周期（以秒为单位） 1cookie.setMaxAge(60*60*24); 发送Cookie到HTTP响应头 1response.addCookie(cookie); 代码示例123456Cookie cookie=new Cookie(&quot;name&quot;,request.getParameter(&quot;name&quot;));Cookie url=new Cookie(&quot;url&quot;,request.getParameter(&quot;url&quot;));cookie.setMaxAge(60*60*24);url.setMaxAge(60*60*24);response.addCookie(cookie);response.addCookie(url); 特点 这是浏览器端的数据存储技术 数据声明是在服务器 2种存储 临时存储：数据存储在浏览器运行内存中，关了就没了 ​ 定时存储：到期之后才会没得 SessionSession是另一种记录浏览器状态的机制，Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务把用户的信息，以某种形式记录在服务器，这就是Session 简单例子：购物的时候不用登陆是cookie，购物车里的信息是session，因为购物车的东西都是保存在服务器的 原理用户第一次访问服务器，服务器会创建一个Session对象给用户，并将该session对象的JESSIONID（一个标识，可以理解为session id）使用Cookie技术存储到浏览器中，利用该标识用户服务器就可以鉴别客户端请求（购物车） 特点 存储在服务器 服务器进行创建 依赖Cookie技术 一次会话 默认存储时间30分钟 使用 创建session对象/获取session对象 HttpSession hs=request.getSession()这么理解：如果创建了session，那么在浏览器中会有JSESSIONID，那么就会返回session对象 设置session存储时间 hs.invalidate( ) 存储数据 hs.setAttribute(String name,Object value) 获取数据 hs.getAttribute(String name) 注意 JESSIONID是在浏览器中，关闭浏览器就没得了 存储和获取是在不同请求，但存储要先于获取 作用域：一次会话（即可以多次请求，主要session没失效），购物车你换台电脑应该保存着，但登陆信息则没有了 验证码部分代码示例12345678910@GetMapping(&quot;/verify&quot;) public void verification(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; VerificationCode code = new VerificationCode(); BufferedImage image = code.getImage(); String text = code.getText(); HttpSession session = req.getSession(); session.setAttribute(&quot;verify_code&quot;,text); //以流的方式将验证码发送到前端 VerificationCode.output(image,resp.getOutputStream()); &#125;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java装箱与拆箱]]></title>
    <url>%2F2019%2F09%2F05%2Fjava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[包装类：基本数据类型使用方便，但没有对应方法来操作这些数据，因而使用一个类，在类中定义操作数据的方法，这些类叫做包装类 简单来说，java装箱就是基本数据类型转换成包装类类型，拆箱就是包装类类型转换成基本数据类型 对应关系如下 基本数据类型 包装类 byte Byte boolean Boolean short Short int Integer float Float double Double char Character 装箱与拆箱静态方法 1234//返回保存指定int的值的Integer对象Integer in1=Integer.valueof(1);//返回保存指定String的值的Integer对象Integer in2=Integer.valueof(&quot;1&quot;); 看一下Interger.valueof源码： 1231 public static Integer valueOf(int i) &#123;2 return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];3 &#125; 它会首先判断i的大小：如果i小于-128或者大于等于128，就创建一个Integer对象，否则执行SMALL_VALUES[i + 128] 。注意这里i如果小于-128或者大于等于128，就会创建不同对象，而处于中间的都会创建同一个对象。 总结来说装箱即valueof( )方法就是会返回Interger类型的对象 Interger构造函数 123Integer in1=new Integer(1);//这里只能是基本类型的字符串Integer in1=new Integer(&quot;1&quot;); 源码 1234567891 private final int value;2 3 public Integer(int value) &#123;4 this.value = value;5 &#125;6 //这里的String必须是基本类型的字符串，100可以，a就不行7 public Integer(String string) throws NumberFormatException &#123;8 this(parseInt(string));9 &#125; 下面看看SMALL_VALUES[i + 128]是什么东西 11 private static final Integer[] SMALL_VALUES = new Integer[256]; 就是说-128-128之间256个数是提前就定义好的，存放256个Integer数在SMALL_VALUES数组中，需要的时候从里面拿，只不过都是同一个对象。 拆箱的intvalue( )源码 接着看看intValue函数,就是返回value值 12341 @Override2 public int intValue() &#123;3 return value;4 &#125; 自动装箱与拆箱123451 //自动装箱2 Integer total = 99;3 4 //自定拆箱5 int totalprim = total; 自动装箱：直接把int类型的整数赋值包装类 自动拆箱：包装类无法直接参与运算，可以自动转换为基本数据类型 123Interger total=99实际上执行了Interger total =Interger.valueof(99);int totalprim = total 实际上执行了int totalprim =total.intvalue( ); 装箱拆箱作用 将基本数据类型放入集合类中 12list.add(1);//自动装箱list.add(new Integer(1));list.get(1);//自动拆箱list.get(0).intvalue(); 包装类型和基本数据类型比较 包装类型运算 1234Integer i = 10;Integer j = 20; System.out.println(i+j); (i+j)即为(Interger.invalue(i)+interger.invalue(j)) 最后给出一道面试题 12345678910111213141516public void testAutoBox2() &#123; //1 int a = 100; Integer b = 100; System.out.println(a == b); //2 Integer c = 100; Integer d = 100; System.out.println(c == d); //3 c = 200; d = 200; System.out.println(c == d);&#125; 结果为 True True false 。在-127，127内的数据同基本数据类型一样存放在常量池，无论多少个值为100，100的地址都是一样的。200&gt;127,此时会在堆建对象，自然是2个对象，不一样。 字符串和基本类型的相互转换基本类型-&gt;字符串 基本类型的值+” “ 包装类的静态方法toString(参数)，不是Object类的toString() String类的静态方法valueof(参数) 123456789int i1=100;String s1=i1+&quot;&quot;;System.out.println(s1+200);//100200这里是字符串的加String s2=Integer.toString(100);System.out.println(s2+200);String s3=String.valueOf(100);System.out.println(s3+200); 字符串-&gt;基本类型 使用包装类的静态方法parsexxx(“字符串”)； ​ Integer类：static int parseInt(String s) ​ Double类：static double parseDouble(String s) 12int i=Integer.parseInt(s1);System.out.println(i);]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex]]></title>
    <url>%2F2019%2F09%2F04%2FLaTex%2F</url>
    <content type="text"><![CDATA[LaTex[TOC] LaTex预备知识第一个LaTex文档123456\documentclass&#123;article&#125; \begin&#123;document&#125;First document. This is a simple example, with no extra parameters or packages included.\end&#123;document&#125; 第一行说明文档类型，在\begin{document} \end{document}标签之间编写文档的文本。 article 排版科技期刊、短报告、程序文档、邀请函等。 report 排版多章节的长报告、短篇的书籍、博士论文等。 book 排版书籍。 slides 排版幻灯片。 序言123456\documentclass[12pt, letterpaper]&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125; \title&#123;First document&#125;\author&#123;Hubert Farnsworth \thanks&#123;funded by the ShareLaTeX team&#125;&#125;\date&#123;February 2014&#125; 在\begin{document}命令之前输入的文本称为前导码。在序言中，您可以定义要编写的文档类型和语言，加载您需要的额外包，并设置几个参数 。 下面对各部分进行说明： \documentclass[12pt, letterpaper]{article} ：在示例中，额外参数设置字体大小（12pt）和纸张大小（letterpaper）。默认大小为10pt。纸张尺寸默认为A4 \usepackage[utf8]{inputenc} ：如果不是特别需要其他编码，将此行添加到前导码中 接下来的三行是自我描述的 。如果要让标题显示，可以通过\maketitle来达到 斜体 粗体 下划线斜体：\textit{ } 粗体：\textbf{ } 下划线：\underline{ } 换行 分页 水平空格 垂直空格换行(新的一行会顶格开始) \\ \newline \hfile \break 分页 \newpage：在图片插入后换页，即图片依然可以正常显示，文本换页 \clearpage：在图片显示前换页，即图片和文本也会换页 水平空格 \hspace{ }：填指定长度空白 \hfill：填空白到行最后 垂直空格 \vspace{ }：填指定长度空白 \vfill：填空白到页面底部 段落新段落 空一行 段末 \par 1234This is the text in first paragraph. This is the text in first paragraph. This is the text in first paragraph. \parThis is the text in second paragraph. This is the text in second paragraph. This is the text in second paragraph. 居中 左对齐 右对齐左对齐示例 1234567\begin&#123;flushleft&#125;``LaTeX is a document preparation system and document markup language. LaTeX uses the TeX typesetting program for formatting its output, and is itself written in the TeX macro language. LaTeX is not the name of a particular editing program, but refers to the encoding or tagging conventions that are used in LaTeX documents&quot;.\end&#123;flushleft&#125; 图片插入图片 Latex无法自行管理图像，因此我们需要使用graphicx包 \usepackage{graphicx} \graphicspath{ {./images/} } \includegraphics{universe} universe为图片名 图片大小和旋转1\ includegraphics [ width = 3cm，height = 4cm ] &#123;lion-logo &#125; 长宽 1\ includegraphics [ width = \ textwidth ] &#123;universe &#125; 图片和文本等宽 1\ includegraphics [ scale = 1.2，angle = 45 ] &#123;lion-logo &#125; 缩放并旋转 1234567\begin&#123;document&#125; Overleaf is a great professional tool to edit online, share and backup your \LaTeX&#123;&#125; projects. Also offers a rather large help documentation. \includegraphics[scale=1.2, angle=45]&#123;lion-logo&#125; 123456\begin&#123;document&#125; The universe is immense and it seems to be homogeneous, in a large scale, everywhere we look at. \includegraphics[width=\textwidth]&#123;universe&#125; 图片与文字的组合123456In the next example the figure will be positioned right below this sentence. \begin&#123;figure&#125;[h]\includegraphics[width=8cm]&#123;Plot&#125;\end&#123;figure&#125; 该figure环境用于将图片显示为文档中的浮动元素 ，LaTex会自动对图片进行定位 h 正常位置 T 位于页面顶部 b 位于页面底部 文本包裹图片，适合图片较小的情况下 12345678910111213141516171819202122232425262728293031\begin&#123;wrapfigure&#125;&#123;r&#125;&#123;0.25\textwidth&#125; %this figure will be at the right \centering \includegraphics[width=0.25\textwidth]&#123;mesh&#125;\end&#123;wrapfigure&#125; There are several ways to plot a function of two variables, depending on the information you are interested in. For instance, if you want to see the mesh of a function so it easier to see the derivative you can use a plot like the one on the left. \begin&#123;wrapfigure&#125;&#123;l&#125;&#123;0.25\textwidth&#125; \centering \includegraphics[width=0.25\textwidth]&#123;contour&#125;\end&#123;wrapfigure&#125; On the other side, if you are only interested oncertain values you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, like the one on the left. On the other side, if you are only interested on certain values you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, like the one on the left. 要实现如下图效果，需要先导入包wrapfig，即 \usepackage{wrapfig} 通过命令定义wrapfigure环境\begin{wrapfigure}{l}{0.25\textwidth} \end{wrapfigure} \centering 将使图片居中 {l}：定义图片的对齐方式 {0.25\textwidth}：图片相对于文本的宽度 效果图 数学表达式数学表达式的写入模式有2种：inline mode ，display mode 。第一个用于编写作为文本一部分的公式。第二个用于编写不属于文本或段落的表达式 。 inline mode(行内模式)：用这些分隔符之一：\( \)，$ $或\begin{math} \end{math} display mode (行内模式）：\[ \], $$ $$, \begin{displaymath} \end{displaymath} or \begin{equation} \end{equation} 有编号 \begin{equation} \end{equation} (没试过) 无编号 章节\section{}标记新部分的开头，在括号内设置标题，部分编号是自动的，可以禁用 。在左大括号前添加*即可去掉编号 1234567891011121314\section&#123;Introduction&#125; This is the first section. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam lobortisfacilisis sem. Nullam nec mi et neque pharetra sollicitudin. Praesent imperdietmi nec ante. Donec ullamcorper, felis non sodales... \section&#123;Second Section&#125; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam lobortis facilisissem. Nullam nec mi et neque pharetra sollicitudin. Praesent imperdiet mi necante... ​ 页眉和页脚同时有很多样式，这里用本人喜欢的风格 \usepackage{fancyhdr} 导入包 \fancyhf 清除页眉和页脚，否则将出现默认“普通”页面样式的元素。 \rhead{ } 右上角页眉 \lhead{ } 左上角页眉 \rfoot{ } 页脚 { }内推荐写 \thepage这样可以自动写入页数 12345678910111213141516\documentclass&#123;article&#125;\usepackage[english]&#123;babel&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage&#123;fancyhdr&#125;\pagestyle&#123;fancy&#125;\fancyhf&#123;&#125;\rhead&#123;Overleaf&#125;\lhead&#123;\LaTeX&#123;&#125; tutorials&#125;\rfoot&#123; \thepage&#125;\begin&#123;document&#125;\section&#123;First Section&#125;\end&#123;document&#125; 参考文献overleaf上有多种参考文献格式，这里使用常见的方式，详细步骤如下： 新建.bib文件，里面存放引用文献的信息 在谷歌学术或百度学术中找到相应文献的 “ 引用 ”功能，然后在导入链接那点击 “ BibTex ”。复制其中的内容至新建立的.bib文件 相关命令 \usepackage{biblatex} 导入包biblatex。 \addbibresource{sample.bib} 导入bibtex数据文件sample.bib，此文件包含有关每个引用的书籍，文章等信息。 \cite{einstein} 此命令在文档中插入引用[1]，在这种情况下，对应于参考书目中的元素，“einstein”是对应于sample.bib中的条目的关键字。 \printbibliography` 打印引用的参考文献列表，默认标题是文章文档类的“参考文献”和书籍和报告的“参考书目”。 1234567891011121314\documentclass&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage[english]&#123;babel&#125; \usepackage&#123;biblatex&#125;\addbibresource&#123;sample.bib&#125; \begin&#123;document&#125;Let&apos;s cite! The Einstein&apos;s journal paper \cite&#123;einstein&#125; and the Dirac&apos;s book \cite&#123;dirac&#125; are physics related items. \printbibliography \end&#123;document&#125;]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
</search>
