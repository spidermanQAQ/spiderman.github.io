<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AOP]]></title>
    <url>%2F2019%2F09%2F22%2FAOP%2F</url>
    <content type="text"><![CDATA[AOP相关概念Joinpoint(连接点): 被拦截到的方法. Pointcut(切入点): 我们对其进行增强的方法. Advice(通知/增强): 对切入点进行的增强操作 ​ 包括前置通知,后置通知,异常通知,最终通知,环绕通知 Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 Aspect(切面): 是切入点和通知的结合 使用XML配置AOP 在bean.xml中引入约束并将通知类注入Spring容器中 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--通知类--&gt; &lt;bean id=&quot;logger&quot; class=&quot;cn.maoritian.utils.Logger&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 使用&lt;aop:config&gt;标签声明AOP配置,所有关于AOP配置的代码都写在&lt;aop:config&gt;标签内 123&lt;aop:config&gt; &lt;!-- AOP配置的代码都写在此处 --&gt;&lt;/aop:config&gt; 使用&lt;aop:aspect&gt;标签配置切面,其属性如下 id: 指定切面的id ref: 引用通知类的id 12345&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!--配置通知的类型要写在此处--&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 使用&lt;aop:pointcut&gt;标签配置切入点表达式,指定对哪些方法进行增强,其属性如下 12345&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:pointcut expression=&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot; id=&quot;pt1&quot;&gt;&lt;/aop:pointcut&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 使用&lt;aop:xxx&gt;标签配置对应类型的通知方法 其属性如下: method: 指定通知类中的增强方法名.ponitcut-ref: 指定切入点的表达式的idpoinitcut: 指定切入点表达式其中pointcut-ref和pointref属性只能有其中一个 具体的通知类型: aop:before：配置前置通知,指定的增强方法在切入点方法之前执行.aop:after-returning：配置后置通知,指定的增强方法在切入点方法正常执行之后执行.aop:afetr-throwing：配置异常通知,指定的增强方法在切入点方法产生异常后执行.aop:after：配置最终通知,无论切入点方法执行时是否发生异常,指定的增强方法都会最后执行.aop:around： 配置环绕通知,可以在代码中手动控制增强代码的执行时机. 12345678910111213&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!--指定切入点表达式--&gt; &lt;aop:pointcut expression=&quot;execution(* cn,maoritian.service.impl.*.*(..))&quot; id=&quot;pt1&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置各种类型的通知--&gt; &lt;aop:before method=&quot;printLogBefore&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=&quot;printLogAfterReturning&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;printLogAfterThrowing&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:after method=&quot;printLogAfter&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt; &lt;!--环绕通知一般单独使用--&gt; &lt;!-- &lt;aop:around method=&quot;printLogAround&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; --&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 环绕通知 前置通知,后置通知,异常通知,最终通知的执行顺序 Spring是基于动态代理对方法进行增强的,前置通知,后置通知,异常通知,最终通知在增强方法中的执行时机如下: 123456789101112131415161718// 增强方法@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; Object rtValue = null; try &#123; // 执行前置通知 // 执行原方法 rtValue = method.invoke(accountService, args); // 执行后置通知 return rtValue; &#125; catch (Exception e) &#123; // 执行异常通知 &#125; finally &#123; // 执行最终通知 &#125;&#125; 环绕通知允许我们更自由地控制增强代码执行的时机 Spring框架为我们提供一个接口ProceedingJoinPoint,它的实例对象可以作为环绕通知方法的参数,通过参数控制被增强方法的执行时机. ProceedingJoinPoint对象的getArgs()方法返回被拦截的参数ProceedingJoinPoint对象的proceed()方法执行被拦截的方法 123456789101112131415// 环绕通知方法,返回Object类型public Object printLogAround(ProceedingJoinPoint pjp) &#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); printLogBefore(); // 执行前置通知 rtValue = pjp.proceed(args);// 执行被拦截方法 printLogAfterReturn(); // 执行后置通知 &#125;catch(Throwable e) &#123; printLogAfterThrowing(); // 执行异常通知 &#125;finally &#123; printLogAfter(); // 执行最终通知 &#125; return rtValue;&#125; spring中对AOP的注解用于声明切面的注解 @Aspect: 声明当前类为通知类,该类定义了一个切面.相当于xml配置中的&lt;aop:aspect&gt;标签 12345@Component(&quot;logger&quot;)@Aspectpublic class Logger &#123; // ...&#125; 用于声明通知的注解@Before: 声明该方法为前置通知.相当于xml配置中的aop:before标签@AfterReturning: 声明该方法为后置通知.相当于xml配置中的aop:after-returning标签@AfterThrowing: 声明该方法为异常通知.相当于xml配置中的aop:after-throwing标签@After: 声明该方法为最终通知.相当于xml配置中的aop:after标签@Around: 声明该方法为环绕通知.相当于xml配置中的aop:around标签属性: ​ value: 用于指定切入点表达式或切入点表达式的引用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component(&quot;logger&quot;)@Aspect //表示当前类是一个通知类public class Logger &#123; // 配置前置通知 @Before(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogBefore()&#123; System.out.println(&quot;前置通知Logger类中的printLogBefore方法开始记录日志了。。。&quot;); &#125; // 配置后置通知 @AfterReturning(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfterReturning()&#123; System.out.println(&quot;后置通知Logger类中的printLogAfterReturning方法开始记录日志了。。。&quot;); &#125; // 配置异常通知 @AfterThrowing(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfterThrowing()&#123; System.out.println(&quot;异常通知Logger类中的printLogAfterThrowing方法开始记录日志了。。。&quot;); &#125; // 配置最终通知 @After(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfter()&#123; System.out.println(&quot;最终通知Logger类中的printLogAfter方法开始记录日志了。。。&quot;); &#125; // 配置环绕通知 @Around(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs(); printLogBefore(); // 执行前置通知 rtValue = pjp.proceed(args); // 执行切入点方法 printLogAfterReturning(); // 执行后置通知 return rtValue; &#125;catch (Throwable t)&#123; printLogAfterThrowing(); // 执行异常通知 throw new RuntimeException(t); &#125;finally &#123; printLogAfter(); // 执行最终通知 &#125; &#125;&#125; 用于指定切入点表达式的注解 @Pointcut: 指定切入点表达式,其属性如下: value: 指定表达式的内容 @Pointcut注解没有id属性,通过调用被注解的方法获取切入点表达式. 1234567891011121314151617181920212223242526@Component(&quot;logger&quot;)@Aspect //表示当前类是一个通知类public class Logger &#123; // 配置切入点表达式 @Pointcut(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) private void pt1()&#123;&#125; // 通过调用被注解的方法获取切入点表达式 @Before(&quot;pt1()&quot;) public void printLogBefore()&#123; System.out.println(&quot;前置通知Logger类中的printLogBefore方法开始记录日志了。。。&quot;); &#125; // 通过调用被注解的方法获取切入点表达式 @AfterReturning(&quot;pt1()&quot;) public void printLogAfterReturning()&#123; System.out.println(&quot;后置通知Logger类中的printLogAfterReturning方法开始记录日志了。。。&quot;); &#125; // 通过调用被注解的方法获取切入点表达式 @AfterThrowing(&quot;pt1()&quot;) public void printLogAfterThrowing()&#123; System.out.println(&quot;异常通知Logger类中的printLogAfterThrowing方法开始记录日志了。。。&quot;); &#125;&#125; 纯注解配置AOP1234567@Configuration@ComponentScan(basePackages=&quot;cn.maoritian&quot;)@EnableAspectJAutoProxy // 允许AOPpublic class SpringConfiguration &#123; // 具体配置 //...&#125; 参考链接https://blog.csdn.net/ncepu_Chen/article/details/94510298#SpringAOP_159]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习Spring的AOP之前，有必要对动态代理有所了解（本文全部参考最后的参考文章链接） 1.静态代理代理模式上，基本上有Subject角色，RealSubject角色，Proxy角色。其中：Subject角色负责定义RealSubject和Proxy角色应该实现的接口；RealSubject角色用来真正完成业务服务功能；Proxy角色负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。 上面的这幅代理结构图是典型的静态的代理模式： ​ 当在代码阶段规定这种代理关系，Proxy类通过编译器编译成class文件，当系统运行时，此class已经存在了。这种静态的代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于Proxy和RealSubject的功能 本质上是相同的，Proxy只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。 为了解决这个问题，就有了动态地创建Proxy的想法：在运行状态中，需要代理的地方，根据Subject 和RealSubject，动态地创建一个Proxy，用完之后，就会销毁，这样就可以避免了Proxy 角色的class在系统中冗杂的问题了。 2.动态代理InvocationHandler角色的由来 仔细思考代理模式中的代理Proxy角色。Proxy角色在执行代理业务的时候，无非是在调用真正业务之前或者之后做一些“额外”业务。 有上图可以看出，代理类处理的逻辑很简单：在调用某个方法前及方法后做一些额外的业务。换一种思路就是：在触发（invoke）真实角色的方法之前或者之后做一些额外的业务。那么，为了构造出具有通用性和简单性的代理类，可以将所有的触发真实角色动作交给一个触发的管理器，让这个管理器统一地管理触发。这种管理器就是Invocation Handler。 在静态代理中，代理Proxy中的方法，都指定了调用了特定的realSubject中的对应的方法： 在上面的静态代理模式下，Proxy所做的事情，无非是调用在不同的request时，调用触发realSubject对应的方法；更抽象点看，Proxy所作的事情；在Java中 方法（Method）也是作为一个对象来看待了， 动态代理工作的基本模式就是将自己的方法功能的实现交给 InvocationHandler角色，外界对Proxy角色中的每一个方法的调用，Proxy角色都会交给InvocationHandler来处理，而InvocationHandler则调用具体对象角色的方法。 在这种模式之中：代理Proxy 和RealSubject 应该实现相同的功能，这一点相当重要。（我这里说的功能，可以理解为某个类的public方法） 在面向对象的编程之中，如果我们想要约定Proxy 和RealSubject可以实现相同的功能，有两种方式： a.一个比较直观的方式，就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口。 ​ b.还有比较隐晦的方式，就是通过继承。因为如果Proxy 继承自RealSubject，这样Proxy则拥有了RealSubject的功能， Proxy还可以通过重写RealSubject中的方法，来实现多态。 其中JDK中提供的创建动态代理的机制，是以a 这种思路设计的，而cglib 则是以b思路设计的。 JDK的动态代理创建机制—-通过接口 比如现在想为RealSubject这个类创建一个动态代理对象，JDK主要会做以下工作： 1. 获取 RealSubject上的所有接口列表； 2. 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX ； 3. 根据需要实现的接口信息，在代码中动态创建 该Proxy类的字节码； 4 . 将对应的字节码转换为对应的class 对象； 5. 创建InvocationHandler 实例handler，用来处理Proxy所有方法调用； 6. Proxy 的class对象 以创建的handler对象为参数，实例化一个proxy对象 JDK通过 java.lang.reflect.Proxy包来支持动态代理，一般情况下，我们使用下面的newProxyInstance方法 12static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。 loder，选用的类加载器 。 interfaces，被代理的类所实现的接口，这个接口可以是多个。 h，绑定代理类的一个方法。 而对于InvocationHandler，我们需要实现下列的invoke方法： 在调用代理对象中的每一个方法时，在代码内部，都是直接调用了InvocationHandler 的invoke方法，而invoke方法根据代理类传递给自己的method参数来区分是什么方法。 12Object invoke(Object proxy,Method method,Object[] args) 在代理实例上处理方法调用并返回结果。 InvocationHandler作用就是，当代理对象的原本方法被调用的时候，会绑定执行一个方法，这个方法就是InvocationHandler里面定义的内容，同时会替代原本方法的结果返回。 InvocationHandler接收三个参数 proxy，代理后的实例对象。 method，对象被调用方法。 args，调用时的参数。 讲的有点抽象，下面通过一个实例来演示一下吧： JDK动态代理示例 现在定义两个接口Vehicle和Rechargable，Vehicle表示交通工具类，有drive()方法；Rechargable接口表示可充电的（工具），有recharge() 方法；定义一个实现两个接口的类ElectricCar 通过下面的代码片段，来为ElectricCar创建动态代理类： 123456789101112131415161718192021222324252627282930package com.foo.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Test &#123; public static void main(String[] args) &#123; ElectricCar car = new ElectricCar(); // 1.获取对应的ClassLoader ClassLoader classLoader = car.getClass().getClassLoader(); // 2.获取ElectricCar 所实现的所有接口 Class[] interfaces = car.getClass().getInterfaces(); // 3.设置一个来自代理传过来的方法调用请求处理器，处理所有的代理对象上的方法调用 InvocationHandler handler = new InvocationHandlerImpl(car); /* 4.根据上面提供的信息，创建代理对象 在这个过程中，这部分是反射的知识 a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码 b.然后根据相应的字节码转换成对应的class， c.然后调用newInstance()创建实例 */ Object o = Proxy.newProxyInstance(classLoader, interfaces, handler); Vehicle vehicle = (Vehicle) o; vehicle.drive(); Rechargable rechargeable = (Rechargable) o; rechargeable.recharge(); &#125; &#125; 12345678package com.foo.proxy; /** * 交通工具接口 * @author louluan */ public interface Vehicle &#123; public void drive(); &#125; 123456789package com.foo.proxy; /** * 可充电设备接口 * @author louluan */ public interface Rechargable &#123; public void recharge(); &#125; 123456789101112131415161718package com.foo.proxy; /** * 电能车类，实现Rechargable，Vehicle接口 * @author louluan */ public class ElectricCar implements Rechargable, Vehicle &#123; @Override public void drive() &#123; System.out.println(&quot;Electric Car is Moving silently...&quot;); &#125; @Override public void recharge() &#123; System.out.println(&quot;Electric Car is Recharging...&quot;); &#125; &#125; 123456789101112131415161718192021222324package com.foo.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class InvocationHandlerImpl implements InvocationHandler &#123; private ElectricCar car; public InvocationHandlerImpl(ElectricCar car) &#123; this.car=car; &#125; @Override public Object invoke(Object paramObject, Method paramMethod, Object[] paramArrayOfObject) throws Throwable &#123; System.out.println(&quot;You are going to invoke &quot;+paramMethod.getName()+&quot; ...&quot;); paramMethod.invoke(car, null); System.out.println(paramMethod.getName()+&quot; invocation Has Been finished...&quot;); return null; &#125; &#125; 12345678910111213141516IProducer proxyProducer=(IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() &#123; //作用：执行被代理对象的任何接口方法都会经过该方法 //proxy:代理对象的引用 //method:当前执行的方法 //args:执行当前方法所需的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //提供增强的代码 Object returnValue=null; //1.获取方法执行的参数 Float money=(Float)args[0]; //2.判断当前方法是不是销售 if (&quot;saleProduct&quot;.equals(method.getName()))&#123; returnValue=method.invoke(producer,money*0.8f); &#125; return returnValue; &#125; cglib 生成动态代理类的机制—-通过类继承： JDK中提供的生成动态代理类的机制有个鲜明的特点是： 某个类必须有实现的接口，而生成的代理类也只能代理某个类接口定义的方法，比如：如果上面例子的ElectricCar实现了继承自两个接口的方法外，另外实现了方法bee() ,则在产生的动态代理类中不会有这个方法了！更极端的情况是：如果某个类没有实现接口，那么这个类就不能同JDK产生动态代理了！ ​ 幸好我们有cglib。“CGLIB（Code Generation Library），是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。” cglib 创建某个类A的动态代理类的模式是： 1. 查找A上的所有非final的public类型的方法定义； 2. 将这些方法的定义转换成字节码； 3. 将组成的字节码转换成相应的代理的class对象； 4. 实现MethodInterceptor接口，用来处理对代理类上所有方法的请求（这个接口和JDK动态代理InvocationHandler的功能和角色是一样的） 一个有趣的例子：定义一个Programmer类，一个Hacker类 123456789101112package samples; /** * 程序猿类 * @author louluan */ public class Programmer &#123; public void code() &#123; System.out.println(&quot;I&apos;m a Programmer,Just Coding.....&quot;); &#125; &#125; 1234567891011121314151617181920package samples; import java.lang.reflect.Method; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; /* * 实现了方法拦截器接口 */ public class Hacker implements MethodInterceptor &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;**** I am a hacker,Let&apos;s see what the poor programmer is doing Now...&quot;); proxy.invokeSuper(obj, args); System.out.println(&quot;**** Oh,what a poor programmer.....&quot;); return null; &#125; &#125; 123456789101112131415161718192021package samples; import net.sf.cglib.proxy.Enhancer; public class Test &#123; public static void main(String[] args) &#123; Programmer progammer = new Programmer(); Hacker hacker = new Hacker(); //cglib 中加强器，用来创建动态代理 Enhancer enhancer = new Enhancer(); //设置要创建动态代理的类 enhancer.setSuperclass(progammer.getClass()); // 设置回调，这里相当于是对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实行intercept()方法进行拦截 enhancer.setCallback(hacker); Programmer proxy =(Programmer)enhancer.create(); proxy.code(); &#125; &#125; 12345678910111213141516171819202122232425Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() &#123; /** * 执行北地阿里对象的任何方法都会经过该方法 * @param proxy * @param method * @param args * 以上三个参数和基于接口的动态代理中invoke方法的参数是一样的 * @param methodProxy ：当前执行方法的代理对象 * @return * @throws Throwable */ public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //提供增强的代码 Object returnValue = null; //1.获取方法执行的参数 Float money = (Float) args[0]; //2.判断当前方法是不是销售 if (&quot;saleProduct&quot;.equals(method.getName())) &#123; returnValue = method.invoke(producer, money * 0.8f); &#125; return returnValue; &#125; &#125;); 参考链接https://www.cnblogs.com/rinack/p/7742682.html]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring03]]></title>
    <url>%2F2019%2F09%2F16%2Fspring03%2F</url>
    <content type="text"><![CDATA[依赖注入概念依赖注入(Dependency Injection)是spring框架核心ioc的具体实现. 通过控制反转,我们把创建对象托管给了spring,但是代码中不可能消除所有依赖,例如:业务层仍然会调用持久层的方法,因此业务层类中应包含持久化层的实现类对象.我们等待框架通过配置的方式将持久层对象传入业务层,而不是直接在代码中new某个具体的持久化层实现类,这种方式称为依赖注入. 注入方法使用构造函数注入&lt;constructor-arg&gt;用来定义构造函数的参数,其属性可大致分为两类 寻找要赋值的字段 index：指定参数在构造函数参数列表的索引位置 name：指定参数在构造函数中的数据类型 type：指定参数在构造函数中的变量名,最常用的属性 给字段赋值 value：给基本数据类型和String类型赋值 ref：给其它Bean类型的字段赋值 1234567891011121314151617public class AccountServiceImpl implements IAccountService &#123; //如果是经常变化的数据,并不适用于注入的方式 private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 123456789&lt;!-- 使用Date类的无参构造函数创建Date对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;myname&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- birthday字段为已经注册的bean对象,其id为now --&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 使用set注入在类中提供需要注入成员属性的set方法,创建对象只调用要赋值属性的set方法 &lt;property&gt;,用来定义要调用set方法的成员. 其主要属性可大致分为两类: 指定要调用set方法赋值的成员字段 name：要调用set方法赋值的成员字段 指定赋给字段的值 value：给基本数据类型和String类型赋值 ref：给其它Bean类型的字段赋值 123456789101112131415161718192021public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 123456789&lt;!-- 使用Date类的无参构造函数创建Date对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;myname&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;!-- birthday字段为已经注册的bean对象,其id为now --&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 集合注入集合字段及其对应的标签按照集合的结构分为两类： 只有键的结构: 数组字段：&lt;array&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 List字段：&lt;list&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 Set字段：&lt;set&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 其中&lt;array&gt;,&lt;list&gt;,&lt;set&gt;标签之间可以互相替换使用. 键值对的结构: Map字段： &lt;map&gt;标签表示集合,&lt;entry&gt;标签表示集合内的键值对,其key属性表示键,value属性表示值 Properties字段：&lt;props&gt;标签表示集合,&lt;prop&gt;标签表示键值对,其key属性表示键,标签内的内容表示值. 下面使用set方法注入各种集合字段 12345678910111213141516171819202122232425262728293031323334public class AccountServiceImpl implements IAccountService &#123; // 集合字段 private String[] myArray; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; // 集合字段的set方法 public void setMyStrs(String[] myArray) &#123; this.myArray = myArray; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myArray)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl3&quot;&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;array&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot;&gt; &lt;value&gt;value2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;myProps&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;value1&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;value2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 02]]></title>
    <url>%2F2019%2F09%2F16%2Fspring-02%2F</url>
    <content type="text"><![CDATA[使用XML配置文件实现IOC使用配置文件实现IOC,要将托管给spring的类写进bean.xml配置文件中. 简单实例 创建maven项目,配置其pom.xml 12345678&lt;dependencies&gt; &lt;!-- 引入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置bean: 在类的根路径下的resource目录下创建bean.xml文件,把对象的创建交给spring来管理.每个&lt;bean&gt;标签对应一个类,其class属性为该类的全类名,id属性为该类的id,在spring配置中,通过id获取类的对象 123456789&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--把对象的创建交给spring来管理--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 在表现层文件Client.java中通过容器创建对象.通过核心容器的getBean()方法获取具体对象. 1234567891011public class Client &#123; public static void main(String[] args) &#123; // 获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); // 根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;); // 执行as的具体方法 // ... &#125;&#125; 我们常用的容器有三种: ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件 AnnotationConfigApplicationContext：读取注解创建容器 bean标签 作用: 配置托管给spring的对象,默认情况下调用类的无参构造函数,若果没有无参构造函数则不能创建成功 属性： id: 指定对象在容器中的标识,将其作为参数传入getBean()方法可以获取获取对应对象. class: 指定类的全类名,默认情况下调用无参构造函数 scope: 指定对象的作用范围,可选值如下 init-method：指定类中的初始化方法名称,在对象创建成功之后执行 destroy-method：指定类中销毁方法名称 bean的作用范围和生命周期 单例对象: scope=”singleton” 作用范围: 每个应用只有一个该对象的实例,它的作用范围就是整个应用 生命周期: 单例对象的创建与销毁 和 容器的创建与销毁时机一致 对象出生: 当应用加载,创建容器时,对象就被创建 对象活着: 只要容器存在,对象一直活着 对象死亡: 当应用卸载,销毁容器时,对象就被销毁 多例对象: scope=&quot;prototype&quot; ​ 作用范围: 每次访问对象时,都会重新创建对象实例. ​ 生命周期: 多例对象的创建与销毁时机不受容器控制 ​ 对象出生: 当使用对象时,创建新的对象实例 ​ 对象活着: 只要对象在使用中,就一直活着 ​ 对象死亡: 当对象长时间不用时,被 java 的垃圾回收器回收了 实例化bean的三种方式 使用默认无参构造函数创建对象: 默认情况下会根据默认无参构造函数来创建类对象 12&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt; 使用静态工厂的方法创建对象 1234&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.factory.StaticFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; 使用实例工厂的方法创建对象 123456&lt;bean id=&quot;instancFactory&quot; class=&quot;cn.maoritian.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 01]]></title>
    <url>%2F2019%2F09%2F16%2Fspring-01%2F</url>
    <content type="text"><![CDATA[spring学习IOC的概念及作用程序的耦合和解耦耦合性：对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调 用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差。 解决程序耦合的思路以jdbc为例，是通过反射来注册驱动的，即Class.forName(“com.mysql.jdbc.Driver”） 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar包，依然可以编译。同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。解决这个问题就要使用配置文件配置。 工厂模式解耦可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 控制反转-Inversion Of Control由于我们是很多对象，肯定要找个集合来存。在应用加载时，创建一个 Map，用于存放三层对象。 我们把这个 map 称之为容器。工厂就是负责给我们从容器中获取指定对象的类。 我们在获取对象时，都是采用 new 的方式，是主动的，如下图 现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象，是被动的。 IOC：将创建对象的权力交给框架，可以削减代码间的依赖。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化序列化和反序列化的概念序列化：把对象转换成字节序列的过程 反序列化：把字节序列转换成对象的过程 什么时候使用序列化 对象序列化可以实现分布式对象。主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制“，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 序列化可以将内存中的类写入文件或数据库中。比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。 对象、文件、数据，有许多不同的格式，很难统一传输和保存。序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件 （上面也就存储在文件上用过，其余的没试过，参考的网上不错的总结，以后用到再补充） 主要用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中 在网络上传送对象的字节序列（当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象） 点进Serializable接口看一下 一个问题点进Serializable接口看一下 里面啥都没有，它是一个空接口，仅仅是一个标识，用来告诉jvm进行序列化，真正的序列化操作不是由他来完成的 demo123456789101112131415161718192021public class person implements Serializable &#123; private static final long serialVersionUID = 1L； private String name; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) throws Exception &#123; Serialization(); person per3=DestroySerialization(); System.out.println(per3.toString()); &#125; private static void Serialization() throws IOException &#123; person per1=new person(); per1.setName(&quot;小李&quot;); per1.setAge(&quot;19&quot;); ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream(new File(&quot;d:/flyPig.txt&quot;))); os.writeObject(per1); System.out.println(&quot;序列化成功&quot;); os.close(); &#125; private static person DestroySerialization() throws Exception&#123; ObjectInputStream is=new ObjectInputStream(new FileInputStream(new File(&quot;d:/flyPig.txt&quot;))); person per2=(person) is.readObject(); System.out.println(&quot;反序列化成功&quot;); return per2; &#125;&#125; 运行结果： transient和static修饰的变量不会被序列化 关于serialversionUID变量如果自己没有声明一个serialVersionUID变量，默认会自动生成一个serialVersionUID，但是推荐自己写一个，因为默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常。 serialVersionUID作用：用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialVersionUID与当前类当中的serialVersionUID一致，那么该对象才能被反序列化成功。 serialVersionUID的工作机制： 序列化时serialVersionUID会被写入到序列化的文件中去 反序列化时JVM会把传来的字节流中的serialVersionUID于本地相应实体类的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常。 参考文档 https://www.jianshu.com/p/664ef87f5fdb https://baijiahao.baidu.com/s?id=1633305649182361563&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2019%2F09%2F09%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final关键字final关键字基本用法 final修饰类 当一个类用final修饰时，这个类就不能被继承了。所以在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。 final修饰方法 如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的 final修饰变量 final成员变量表示常量，只能被赋值一次，赋值后值不再改变 先来个很常见的题目引入 1234567891011public class Test &#123; public static void main(String[] args) &#123; String a = &quot;hello2&quot;; final String b = &quot;hello&quot;; String d = &quot;hello&quot;; String c = b + 2; String e = d + 2; System.out.println((a == c)); System.out.println((a == e)); &#125; &#125; ​ 分析：final变量是基本数据类型以及String类型时 ，如果在编译器就知道其确切值，编译器就会把它当作常量来看，所以b会直接以hello来替代。常量字符串的“+”操作，编译阶段直接会合成为一个字符串。在编译期间，这种拼接会被优化，编译器直接帮你拼好 ，如string str=”ja”+”va”，在编译阶段会直接合并成语句String str=”java”，于是会去常量池中查找是否存在”java” ，从而进行创建或引用，这里的c即为“hello”+2，也就是“hello2”，所以a和c指向的是同一个hello2，而a和e则是不同对象，为什么呢，一开始我也不知道，在查阅相关博客后，对常量池等知识有了了解，下面对String创建的变量进行详细解析。 new String都是在堆上创建字符串对象。 其实这里常量池中也会有一个“abcd”的字符串，当new时，会拷贝一份该字符串存放到堆中，于是y指向了堆中的那个“abcd”字符串 。 1234567String s = new String(&quot;abc&quot;);String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); System.out.println(s == s1);System.out.println(s == s2);System.out.println(s1 == s2); 这里在详细分析以下这两行代码： 首先在常量池中创建abc对象，然后new关键字会在堆里再创建一个对象，在堆里的这个对象则是在栈中的s1所指向的 当轮到s2时，首先同样会在常量池中看有没有abc，这里已经有了，则不用自己创建。然后new自己创建一个在堆中的对象，s2指向这个对象 所以虽然s1和s2指向的最终内容都是abc，但它们是2个不同的对象，因为指向的是不同堆对象 通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。 再来个经典例子： 12345678910111213141516 1 String s1 = &quot;Hello&quot;; 2 String s2 = &quot;Hello&quot;; 3 String s3 = &quot;Hel&quot; + &quot;lo&quot;; 4 String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;); 5 String s5 = new String(&quot;Hello&quot;); 6 String s6 = s5.intern(); 7 String s7 = &quot;H&quot;; 8 String s8 = &quot;ello&quot;; 9 String s9 = s7 + s8;10 11 System.out.println(s1 == s2); // true12 System.out.println(s1 == s3); // true13 System.out.println(s1 == s4); // false14 System.out.println(s1 == s9); // false15 System.out.println(s4 == s5); // false16 System.out.println(s1 == s6); // true s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。 s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。 s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同 s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同 s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。 s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。 注意：只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中 常量池 Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 ​ 所谓静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：*字面量(Literal)和符号引用量**(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名 字段名称和描述符 方法名称和描述符 ​ 而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 常量池的好处 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。 （1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。 （2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 参考博客：https://www.cnblogs.com/lizhangyong/p/8909329.html ​ https://www.cnblogs.com/xiaoxi/p/6392154.html]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response]]></title>
    <url>%2F2019%2F09%2F08%2Fresponse%2F</url>
    <content type="text"><![CDATA[response 请求消息：客户端发送给服务器的数据 数据格式： 请求行 请求头 请求空行 请求体 响应消息服务器端发给客户端的数据 响应行 响应头 响应空行 响应体 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 状态码都是3位数字 分类： 1xx：服务器接受客户端信息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功 3xx：重定向 代表:304 重定向 客户端向服务器请求a，服务器a说在c那，告诉客户端，客户端再去请求服务器c ![](https://xjhpic-1259639342.cos.ap-chengdu.myqcloud.com/response.png) ​ 304 访问缓存：浏览器a向服务器请求a.png,服务器给，并在本地有缓存，当第二次请求时，服务器对浏览器回应304去访问自己的缓存。 4. 4xx：客户端错误。代表：404 （请求路径不对） 1. 404：路径没有对应资源 2. 405：请求方式没有对应的doxx方法 5. 5xx：服务器错误 响应头 格式：头名称：值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-Type：服务器告诉客户端义什么格式打开响应体数据 in-line：默认值在当前页面内打开 attachment：以附件形式打开响应体.文件下载 响应体：传输的数据 response功能 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name，String value) 设置响应体： 获取输出流 字符输出流：PrintWriter getwriter（） 字节输出流：ServletOutputStream getOutOutputStream() 使用输出流：将数据输出到客户端 案例 完成重定向 重定向：资源跳转的方式 代码实现 12response.setStatus(302);response.setHeader(&quot;location&quot;, &quot;/demo/responsedemo2&quot;); 1response.sendRedirect(&quot;/demo/responsedemo2&quot;); 转发特点： 1.转发地址路径不变 2.转发只能访问当前服务器下的资源 3.转发是一次请求，可以使用request对象来共享数据 重定向特点： 1.地址栏发生变化 2.重定向可以访问其他站点（服务器）的资源 3.重定向是2次请求，不能使用request对象来共享数据 foward和redirect区别 路径写法： 相对路径：通过相对路径不可以确定唯一资源 ./index.html不以/开头，以.开头 找到当前与目标资源之间的相对位置关系 ./:当前目录 ../：后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 判断定义的路径给谁用 给客户端用，需要加虚拟目录 给服务器用：不需要加 2.服务器输出字符数据到浏览器 ​ 步骤：1.获取字符数据 ​ 2.输出数据 ​ 注意乱码问题：PrintWriter pw=response.getWriter();默认编码方式是ISO-8859-1 Writer类的常用方法 void write(int n)：写入单个字符 void write(byte b[])：写入一个字符数组 void write(byte b[],int off,int len)：从字节数组中起始于偏移量off处取len个字符 123456//告诉浏览器服务器的编码方式，建议浏览器使用该编码解码（浏览器默认gbk）response.setHeader(&quot;content-type&quot;,&quot;text/html;charset= utf-8&quot;);//获取字符数据PrintWriter pw=response.getWriter();//输出数据pw.write(&quot;你好啊&quot;); 3.输出字节数据到浏览器（一般输出图片） ServletOutputStream类提供了将二进制数据写入响应的流 getBytes()返回默认编码的字节数组 OutputStream类的常用方法 void write(int n)：写入单个字节 void write(byte b[])：写入一个字节数组 void write(byte b[],int off,int len)：从字节数组中起始于偏移量off处取len个字节 1234//获取字符数据ServletOutputStream pw=response.getOutputStream();//输出数据pw.write(&quot;你好&quot;.getBytes());]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器作用： 对服务器接受的资源和响应给浏览器的资源进行管理 保护servlet 使用： 创建一个实现Filter接口的普通java类 覆写接口的方法 init方法：服务器启动即执行，资源初始化 doFilter方法：拦截请求，在此方法中对资源实现管理 要手动对资源放行：chain.doFilter(request,response) destroy方法：服务器关闭 在web.xml配置过滤器（是服务器在使用过滤器） ​ url-patten：/*表示拦截所有请求。 ​ url-patten：*.do 表示所有以.do结尾的请求。一般用来进行模块拦截。 ​ url-patten：/ts 表示拦截指定url的请求，针对某个servlet拦截，保护servlet 过滤器生命周期：服务器启动到关闭。 总结：过滤器程序员声明和配置，服务器根据请求中的url信息调用。 执行机制：浏览器发起请求到服务器，服务器接到请求后，根据url在web.xml中找到对应的过滤器执行doFilter方法，该方法对此次请求进行处理后如果符合则放行，放行后还有其他符合要求的进行过滤，找到执行对应的servlet进行处理。servlet对请求处理完毕后，service方法结束。还需继续返回相应的doFilter检修执行 案例：统一编码格式设置 ​ session管理 ​ 权限管理 ​ 资源管理 123456789101112131415161718/* * 在过滤器类前使用@WebFilter()注释 * filterName:名称 * urlPatterns:过滤器作用url地址 * initParams:初始化参数，以WebInitParam()形式存入 * */@WebFilter(filterName = &quot;filterusers&quot;,urlPatterns =&quot;/demo/*&quot;, initParams =&#123;@WebInitParam(name=&quot;ip&quot;,value = &quot;192.168.*.*&quot;)&#125; )public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); if (session.getAttribute(&quot;user&quot;)==null) &#123; response.sendRedirect(); &#125; else //放行 filterChain.doFilter(request,response);]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session]]></title>
    <url>%2F2019%2F09%2F08%2FSession%2F</url>
    <content type="text"><![CDATA[SessionSession是另一种记录浏览器状态的机制，Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务把用户的信息，以某种形式记录在服务器，这就是Session 问题：一个用户的不同请求处理的数据共享怎么办 解决：Session 原理：用户第一次访问服务器，服务器会创建一个Session对象给用户，并将该session对象的JESSIONID使用Cookie技术存储到浏览器中，保证用户的其他请求能够获取到同一个session对象，也保证不同请求能够共享数据 12345678910111213141516171819202122232425Request URL: http://localhost:8089/loginRequest Method: POSTStatus Code: 200 Remote Address: [::1]:8089Referrer Policy: no-referrer-when-downgradeContent-Length: 57Content-Type: text/html;charset=UTF-8Date: Mon, 26 Nov 2018 01:11:19 GMTSet-Cookie: UserName=3444444444444444Set-Cookie: UserPassword=23423424Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Connection: keep-aliveContent-Length: 40Content-Type: application/x-www-form-urlencodedCookie: Webstorm-66e715af=5d7e1fa0-a9e9-4c01-9c16-aaff75cf10f7; JSESSIONID=2AF4A84C2F8FC452F54C77D3092B2E1B; UserName=3444444444444444; UserPassword=23423424Host: localhost:8089Origin: http://localhost:8089Referer: http://localhost:8089/Login.jspUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/69.0.3497.100 Safari/537.36 特点： 存储在服务器 服务器进行创建 依赖Cookie技术 一次会话 默认存储时间30分钟 使用： 创建session对象/获取session对象 HttpSession hs=request.getSession() 这么理解：如果创建了session，那么在浏览器中会有JSESSIONID，那么就会返回session对象 如果没有创建，那么新建一个 设置session存储时间 hs.invalidate( ) 存储数据 hs.setAttribute(String name,Object value) 获取数据 hs.getAttribute(String name) 使用情景：用户登陆时将用户信息存入session中，供该用户的其他请求使用 注意：*JESSIONID是在浏览器中，关闭浏览器就没得了 ​ *存储和获取是在不同请求，即http://aa http://bb这样不同请求，但存储要先于获取 作用域：一次会话（即可以多次请求，主要session没失效） 代码示例 1234567891011protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); //获取请求信息 String name=&quot;张三&quot;; //处理消息 //创建session对象 HttpSession ps=request.getSession(); System.out.println(ps.getId()); ps.setAttribute(&quot;name&quot;,name);&#125; 12345678response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);//获取请求信息String name=&quot;张三&quot;;//处理消息//创建session对象HttpSession ps=request.getSession();System.out.println(&quot;session2&quot;+ps.getId());System.out.println(&quot;session2&quot;+ps.getAttribute(&quot;name&quot;)); session1存数据，session2读数据，但是是一个用户]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie]]></title>
    <url>%2F2019%2F09%2F08%2FCookie%2F</url>
    <content type="text"><![CDATA[Cookie设置CookieCookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息 。简单例子就是淘宝等账户几天内不用重复登陆。 识别返回用户包括三个步骤： 服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上，以备将来使用。 当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户 这里给一个Cookie响应头例子，来自于菜鸟 1234567HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=runoob.comConnection: closeContent-Type: text/html Set-Cookie中包含了键值对、一个 GMT 日期、一个路径和一个域 。在到期之后浏览器便会”忘记”Cookie。expire翻译有去世的意思，补充英语单词，哈哈。 特点： 这是浏览器端的数据存储技术 数据声明是在服务器 2种存储 临时存储：数据存储在浏览器运行内存中，关了就没了 ​ 定时存储：到期之后才会没得 使用： 创建一个Cookie对象，cookie 名称和 cookie 值都是字符串 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 设置最大生命周期（以秒为单位） 1cookie.setMaxAge(60*60*24); 发送Cookie到HTTP响应头 1response.addCookie(cookie); 代码示例 123456Cookie cookie=new Cookie(&quot;name&quot;,request.getParameter(&quot;name&quot;));Cookie url=new Cookie(&quot;url&quot;,request.getParameter(&quot;url&quot;));cookie.setMaxAge(60*60*24);url.setMaxAge(60*60*24);response.addCookie(cookie);response.addCookie(url);]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java装箱与拆箱]]></title>
    <url>%2F2019%2F09%2F05%2Fjava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[java自动装箱与拆箱简单来说，java装箱就是基本数据类型转换成包装类类型，拆箱就是包装类类型转换成基本数据类型 对应关系如下 基本数据类型 包装类 byte Byte boolean Boolean short Short int Integer float Float double Double char Character 举个简单例子 123451 //自动装箱2 Integer total = 99;3 4 //自定拆箱5 int totalprim = total; 解析一下 ，Interger total=99实际上执行了Interger total =Interger.value(99); ​ int totalprim = total 实际上执行了int totalprim =total.invalue( ); 看一下Interger.value源码： 1231 public static Integer valueOf(int i) &#123;2 return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];3 &#125; 它会首先判断i的大小：如果i小于-128或者大于等于128，就创建一个Integer对象，否则执行SMALL_VALUES[i + 128] 。注意这里i如果小于-128或者大于等于128，就会创建不同对象，而处于中间的都会创建同一个对象。 Interger构造函数如下 1234567891 private final int value;2 3 public Integer(int value) &#123;4 this.value = value;5 &#125;6 7 public Integer(String string) throws NumberFormatException &#123;8 this(parseInt(string));9 &#125; 下面看看SMALL_VALUES[i + 128]是什么东西： 11 private static final Integer[] SMALL_VALUES = new Integer[256]; 总结来说装箱即valueof( )方法就是会返回Interger类型的对象 接着看看intValue函数,就是返回value值 12341 @Override2 public int intValue() &#123;3 return value;4 &#125; 那具体装箱拆箱有哪些用呢，见下 将基本数据类型放入集合类中(集合部分还没学，下面是网上相关代码) 1234List&lt;Integer&gt; li = new ArrayList&lt;&gt;();for (int i = 1; i &lt; 50; i ++)&#123; li.add(i);&#125; 这里li.add(i)就用到了自动装箱即为li.add(Interger.valueof(i); 包装类型和基本数据类型比较 包装类型运算 1234Integer i = 10;Integer j = 20; System.out.println(i+j); (i+j)即为(Interger.invalue(i)+interger,invalue(j)) 最后给出一道面试题 12345678910111213141516public void testAutoBox2() &#123; //1 int a = 100; Integer b = 100; System.out.println(a == b); //2 Integer c = 100; Integer d = 100; System.out.println(c == d); //3 c = 200; d = 200; System.out.println(c == d);&#125; 结果为 True True false 原因就是100 200值的不同，见上所述。 当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象 。 （缓存部分就不详细说了，本人还没看，哈哈） （因本人较菜，这里记录下对象相关的知识） java中引用型数据包括有数组，对象以及接口。对象创建后存放的是地址，成员变量则是直接存放。 Point p1=new Point(5,15);]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex]]></title>
    <url>%2F2019%2F09%2F04%2FLaTex%2F</url>
    <content type="text"><![CDATA[LaTex[TOC] LaTex预备知识第一个LaTex文档123456\documentclass&#123;article&#125; \begin&#123;document&#125;First document. This is a simple example, with no extra parameters or packages included.\end&#123;document&#125; 第一行说明文档类型，在\begin{document} \end{document}标签之间编写文档的文本。 article 排版科技期刊、短报告、程序文档、邀请函等。 report 排版多章节的长报告、短篇的书籍、博士论文等。 book 排版书籍。 slides 排版幻灯片。 序言123456\documentclass[12pt, letterpaper]&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125; \title&#123;First document&#125;\author&#123;Hubert Farnsworth \thanks&#123;funded by the ShareLaTeX team&#125;&#125;\date&#123;February 2014&#125; 在\begin{document}命令之前输入的文本称为前导码。在序言中，您可以定义要编写的文档类型和语言，加载您需要的额外包，并设置几个参数 。 下面对各部分进行说明： \documentclass[12pt, letterpaper]{article} ：在示例中，额外参数设置字体大小（12pt）和纸张大小（letterpaper）。默认大小为10pt。纸张尺寸默认为A4 \usepackage[utf8]{inputenc} ：如果不是特别需要其他编码，将此行添加到前导码中 接下来的三行是自我描述的 。如果要让标题显示，可以通过\maketitle来达到 斜体 粗体 下划线斜体：\textit{ } 粗体：\textbf{ } 下划线：\underline{ } 换行 分页 水平空格 垂直空格换行(新的一行会顶格开始) \\ \newline \hfile \break 分页 \newpage：在图片插入后换页，即图片依然可以正常显示，文本换页 \clearpage：在图片显示前换页，即图片和文本也会换页 水平空格 \hspace{ }：填指定长度空白 \hfill：填空白到行最后 垂直空格 \vspace{ }：填指定长度空白 \vfill：填空白到页面底部 段落新段落 空一行 段末 \par 1234This is the text in first paragraph. This is the text in first paragraph. This is the text in first paragraph. \parThis is the text in second paragraph. This is the text in second paragraph. This is the text in second paragraph. 居中 左对齐 右对齐左对齐示例 1234567\begin&#123;flushleft&#125;``LaTeX is a document preparation system and document markup language. LaTeX uses the TeX typesetting program for formatting its output, and is itself written in the TeX macro language. LaTeX is not the name of a particular editing program, but refers to the encoding or tagging conventions that are used in LaTeX documents&quot;.\end&#123;flushleft&#125; 图片插入图片 Latex无法自行管理图像，因此我们需要使用graphicx包 \usepackage{graphicx} \graphicspath{ {./images/} } \includegraphics{universe} universe为图片名 图片大小和旋转1\ includegraphics [ width = 3cm，height = 4cm ] &#123;lion-logo &#125; 长宽 1\ includegraphics [ width = \ textwidth ] &#123;universe &#125; 图片和文本等宽 1\ includegraphics [ scale = 1.2，angle = 45 ] &#123;lion-logo &#125; 缩放并旋转 1234567\begin&#123;document&#125; Overleaf is a great professional tool to edit online, share and backup your \LaTeX&#123;&#125; projects. Also offers a rather large help documentation. \includegraphics[scale=1.2, angle=45]&#123;lion-logo&#125; 123456\begin&#123;document&#125; The universe is immense and it seems to be homogeneous, in a large scale, everywhere we look at. \includegraphics[width=\textwidth]&#123;universe&#125; 图片与文字的组合123456In the next example the figure will be positioned right below this sentence. \begin&#123;figure&#125;[h]\includegraphics[width=8cm]&#123;Plot&#125;\end&#123;figure&#125; 该figure环境用于将图片显示为文档中的浮动元素 ，LaTex会自动对图片进行定位 h 正常位置 T 位于页面顶部 b 位于页面底部 文本包裹图片，适合图片较小的情况下 12345678910111213141516171819202122232425262728293031\begin&#123;wrapfigure&#125;&#123;r&#125;&#123;0.25\textwidth&#125; %this figure will be at the right \centering \includegraphics[width=0.25\textwidth]&#123;mesh&#125;\end&#123;wrapfigure&#125; There are several ways to plot a function of two variables, depending on the information you are interested in. For instance, if you want to see the mesh of a function so it easier to see the derivative you can use a plot like the one on the left. \begin&#123;wrapfigure&#125;&#123;l&#125;&#123;0.25\textwidth&#125; \centering \includegraphics[width=0.25\textwidth]&#123;contour&#125;\end&#123;wrapfigure&#125; On the other side, if you are only interested oncertain values you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, like the one on the left. On the other side, if you are only interested on certain values you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, like the one on the left. 要实现如下图效果，需要先导入包wrapfig，即 \usepackage{wrapfig} 通过命令定义wrapfigure环境\begin{wrapfigure}{l}{0.25\textwidth} \end{wrapfigure} \centering 将使图片居中 {l}：定义图片的对齐方式 {0.25\textwidth}：图片相对于文本的宽度 效果图 数学表达式数学表达式的写入模式有2种：inline mode ，display mode 。第一个用于编写作为文本一部分的公式。第二个用于编写不属于文本或段落的表达式 。 inline mode(行内模式)：用这些分隔符之一：\( \)，$ $或\begin{math} \end{math} display mode (行内模式）：\[ \], $$ $$, \begin{displaymath} \end{displaymath} or \begin{equation} \end{equation} 有编号 \begin{equation} \end{equation} (没试过) 无编号 章节\section{}标记新部分的开头，在括号内设置标题，部分编号是自动的，可以禁用 。在左大括号前添加*即可去掉编号 1234567891011121314\section&#123;Introduction&#125; This is the first section. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam lobortisfacilisis sem. Nullam nec mi et neque pharetra sollicitudin. Praesent imperdietmi nec ante. Donec ullamcorper, felis non sodales... \section&#123;Second Section&#125; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam lobortis facilisissem. Nullam nec mi et neque pharetra sollicitudin. Praesent imperdiet mi necante... ​ 页眉和页脚同时有很多样式，这里用本人喜欢的风格 \usepackage{fancyhdr} 导入包 \fancyhf 清除页眉和页脚，否则将出现默认“普通”页面样式的元素。 \rhead{ } 右上角页眉 \lhead{ } 左上角页眉 \rfoot{ } 页脚 { }内推荐写 \thepage这样可以自动写入页数 12345678910111213141516\documentclass&#123;article&#125;\usepackage[english]&#123;babel&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage&#123;fancyhdr&#125;\pagestyle&#123;fancy&#125;\fancyhf&#123;&#125;\rhead&#123;Overleaf&#125;\lhead&#123;\LaTeX&#123;&#125; tutorials&#125;\rfoot&#123; \thepage&#125;\begin&#123;document&#125;\section&#123;First Section&#125;\end&#123;document&#125; 参考文献overleaf上有多种参考文献格式，这里使用常见的方式，详细步骤如下： 新建.bib文件，里面存放引用文献的信息 在谷歌学术或百度学术中找到相应文献的 “ 引用 ”功能，然后在导入链接那点击 “ BibTex ”。复制其中的内容至新建立的.bib文件 相关命令 \usepackage{biblatex} 导入包biblatex。 \addbibresource{sample.bib} 导入bibtex数据文件sample.bib，此文件包含有关每个引用的书籍，文章等信息。 \cite{einstein} 此命令在文档中插入引用[1]，在这种情况下，对应于参考书目中的元素，“einstein”是对应于sample.bib中的条目的关键字。 \printbibliography` 打印引用的参考文献列表，默认标题是文章文档类的“参考文献”和书籍和报告的“参考书目”。 1234567891011121314\documentclass&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage[english]&#123;babel&#125; \usepackage&#123;biblatex&#125;\addbibresource&#123;sample.bib&#125; \begin&#123;document&#125;Let&apos;s cite! The Einstein&apos;s journal paper \cite&#123;einstein&#125; and the Dirac&apos;s book \cite&#123;dirac&#125; are physics related items. \printbibliography \end&#123;document&#125;]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker学习（1）]]></title>
    <url>%2F2019%2F07%2F17%2Fdocker1%2F</url>
    <content type="text"><![CDATA[docker学习（1）最近在学docker相关的东西，正好写几篇博客巩记录下。 docker背景一款产品从开发到上线，从操作系统，到运行环境，再到应用配置 。因而当从一台电脑部署到另一台电脑时，环境配置会很麻烦，什么都要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 docker三要素用一张总的架构图来有一个直观的了解。Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 镜像（docker images）Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 容器（container）Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例 。一个镜像可以创建多个容器。 仓库（registery）仓库（Repository）是集中存放镜像文件的场所。 例如dockerhub就是最大的docker仓库。 docker优点docker优点简洁来说就是：“一次封装，多出运行”。用户只要配置好了环境，换到别的电脑上直接部署就完事了，很方便。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[奶奶级next主题的美化教学动态背景的设置执行git clone https://github.com/theme-next/theme-next-three 进入主题的config.yml文件修改three:,enable: true，(可以选择的),例如canvas_nest等，进入_config.yml文件可以看上面的说明，会告诉你需要的依赖，clone下来，设为true即可，当然空格问题要注意哦。 最后hexo clean hexo g hexo s三部曲一下 配置daovoice在线聊天功能进入daovoice官网，注册注册成功后，进入后台控制台，进入到 应用设置--&gt;安装到网站 页面，可以得到一个 app_id 进入themes/next/layout/_partials/head.swig 文件中添加如下代码，位置随意：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件 _config.yml，添加如下代码 : 123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 注意：添加成功后的图标可能和以后加入的例如比例图标重合，此时可以到聊天设置，修改下按钮的位置: 2.3进入themes/next/layout/_partials/head.swig 文件中添加如下代码，位置随意：]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next第一篇教学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
