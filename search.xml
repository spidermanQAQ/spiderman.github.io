<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2019%2F10%2F19%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println("num=" + num); System.out.println("over"); &#125;&#125; 上述程序执行过程图解： 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println("over"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException("哥们，角标越界了~~~"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read("a.txt"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read("a.txt"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; if (!path.equals("b.txt")) &#123; throw new IOException(); &#125; &#125;&#125; 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read("b.txt"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read("a.txt"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println("不管程序怎样，这里都将会被执行。"); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot入门]]></title>
    <url>%2F2019%2F10%2F17%2Fspring%20boot%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[spring boot诞生的背景 在spring boot出现以前，使用spring框架的程序员是这样配置web应用环境的，需要大量的xml配置 随着web项目集成软件的不断增多，xml配置也不断的增多，xml配置文件也在不断地增多，项目的依赖管理也越发的复杂。spring框架也因此饱受争议，配置文件难以理解且容易出错 xml配置文件不但复杂，而且绝大部分属于模板配置，也就是说有80%以上的配置是不断重复的。也就是说在这个web项目里面这样配置，挪到另一个项目里面这部分配置仍然相同 举一个例子:自己接电线与标准化插座Spring Boot的配置方式，就像是插头插座，就是这个标准。你第三方开源类库想接入进来，你就做一个starter的适配。spring MVC方式就像是手动接电线，很灵活，但是不同的人接出来的效果千差万别，而且很容易出错。Spring boot虽然灵活性不如Spring MVC的方式，你也不太清楚插座里面的线路是什么样，但就是方便易用 spring boot 改变了什么 Spring Boot 的目标不在于为已解决的问题领域提供新的解决方案，而是为平台带来另一种新的开发体验，从而简化对这些已有技术的使用 使配置变简单 使监控变简单 使部署变简单 使开发变简单 Spring Boot主要特性 遵循“约定优于配置”的原则，简化配置 可以完全脱离XML配置文件,采用注解配置和java Config 内嵌Servlet容器，应用可用jar包执行：java -jar 快速完成项目搭建、整合第三方类库，方便易用 提供了starter POM, 能够非常方便的进行包管理, 简化包管理配置 与Spring cloud天然集成，spring boot是目前java体系内实现微服务最佳方案 Spring Boot集成第三方类库的步骤 通过maven引入springboot-XXXX-starter 修改ymal或properties全局统一配置文件 加入一个Java Config。这个属于个性化配置，如果使用通用配置，这一步不需要。 核心概念Spring Boot 、 Spring MVC 、Spring对比Spring 框架 Spring框架最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果你能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。 Spring MVC Spring MVC提供了一种友好的方式来开发Web应用程序。 通过使用诸如Dispatcher Servlet，ModelAndView和View Resolver，可以轻松开发Web应用程序 Spring Boot Spring 和 Spring MVC最大的弊病在于存在大量的配置，并且这些配置在不同的项目中具有很高的相似性。从而导致重复配置，繁琐而且杂乱！ Spring Boot期望通过结合自动配置和starters来解决了这个问题。 另外，Spring Boot还提供了一些功能，可以更快地构建可用于生产环境的应用程序 Spring Boot 自动配置Spring和Spring MVC应用程序里面有大量的XML或Java Bean配置。Spring Boot为解决这个问题，提供一种新的解决方案，新的思维方式。 springboot思考的方式：是不是可以更加智能一点，当Spring中加入一些新的jar包，可以自动的配置一些bean。 比如：Spring MVC JAR位于类路径中时，自动配置Dispatcher Servlet。当然，当这些自动的默认配置不符合我们的要求的时候，我们可以修改。 什么是Spring Boot Starter？Spring Boot Starter是一组被依赖第三方类库的集合。 如果你要开发一个web应用程序，就通过包管理工具(如maven)引入spring-boot-starter-web就可以了，而不用分别引入下面这么多依赖类库，spring-boot-starter-web一次性帮你引入下面的这些常用类库。 Spring — spring 核心, beans, context上下文, AOP面向切面 Web MVC — Spring MVC Jackson — JSON数据的序列化与反序列化 Validation — Hibernate参数校验及校验API 嵌入式 Servlet Container — Tomcat 日志框架Logging — logback, slf4j]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[restful接口实现]]></title>
    <url>%2F2019%2F10%2F17%2Frestful%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[collection,迭代器]]></title>
    <url>%2F2019%2F10%2F16%2Fcollection-%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Collection集合集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add("小李广"); coll.add("扫地僧"); coll.add("石破天"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 扫地僧 是否在集合中"+coll.contains("扫地僧")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除石破天："+coll.remove("石破天")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; Iterator迭代器Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("串串星人"); coll.add("吐槽星人"); coll.add("汪星人"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("小河神"); coll.add("老河神"); coll.add("神婆"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 for循环与迭代器的对比: ***** 效率上各有各的优势: &gt; ArrayList对随机访问比较快，而for循环中使用的get()方法，采用的即是随机访问的方法，因此在ArrayList里for循环快。 &gt; LinkedList则是顺序访问比较快，Iterator中的next()方法采用的是顺序访问方法，因此在LinkedList里使用Iterator较快。 &gt; 主要还是要依据集合的数据结构不同的判断。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis原理]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原理分为6块 读取核心配置文件并返回InputStream流对象 根据InputStream流对象解析出Configuration对象，然后创建SqlSessionFactory工厂对象 根据一系列属性从SqlSessionFactory工厂中创建SqlSession 从SqlSession中调用Executor执行数据库操作&amp;&amp;生成具体SQL指令 对执行结果进行二次封装 提交与事务 根据配置文件生成SqlSessionFactory123public static InputStream getResourceAsStream(String resource) throws IOException &#123; return getResourceAsStream((ClassLoader)null, resource);&#125; getResourceAsStream调用下面的方法：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解开发]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[注解开发增删改查解释一下，原来mapper.xml里的namespace不用写，因为本身就在IUserDao接口，rusultType不用因为泛型内说明了返回类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert(&quot;insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)&quot;) void saveUser(User user); /** * 更新用户 * @param user */ @Update(&quot;update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;) void updateUser(User user); /** * 删除用户 * @param userId */ @Delete(&quot;delete from user where id=#&#123;id&#125; &quot;) void deleteUser(Integer userId); /** * 根据id查询用户 * @param userId * @return */ @Select(&quot;select * from user where id=#&#123;id&#125; &quot;) User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select(&quot;select * from user where username like #&#123;username&#125; &quot;) List&lt;User&gt; findUserByName(String username);&#125; 注解开发多表查询一对一（多对一） @One 注解（一对一） 代替了标签，是多表查询的关键，在注解中用来指定子查询返回单一对象 select 指定用来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled 123456789101112131415161718192021222324public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * @return */ @Select(&quot;select * from account&quot;) @Results(id=&quot;accountMap&quot;,value = &#123; @Result(id=true,column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;uid&quot;,property = &quot;uid&quot;), @Result(column = &quot;money&quot;,property = &quot;money&quot;), //这个注解是引入主表 FetchType(加载时机) EAGER(立即加载) @Result(property = &quot;user&quot;,column = &quot;uid&quot;,one=@One(select=&quot;com.itheima.dao.IUserDao.findById&quot;,fetchType= FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll(); /** * 根据用户id查询账户信息 * @param userId * @return */ @Select(&quot;select * from account where uid = #&#123;userId&#125;&quot;) List&lt;Account&gt; findAccountByUid(Integer userId);&#125; 一对多 @Many 注解（多对一） 代替了标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合 fetchType = FetchType.LAZY延迟加载 1234567891011121314151617181920212223242526272829303132333435363738public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) @Results(id=&quot;userMap&quot;,value=&#123; @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;), @Result(column = &quot;username&quot;,property = &quot;userName&quot;), @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;), @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;), @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;), @Result(property = &quot;accounts&quot;,column = &quot;id&quot;, many = @Many(select = &quot;com.itheima.dao.IAccountDao.findAccountByUid&quot;, fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * @param userId * @return */ @Select(&quot;select * from user where id=#&#123;id&#125; &quot;) @ResultMap(&quot;userMap&quot;) User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select(&quot;select * from user where username like #&#123;username&#125; &quot;) @ResultMap(&quot;userMap&quot;) List&lt;User&gt; findUserByName(String username);&#125;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟加载]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[延迟加载的概念就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速 度要快。 坏处： 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗 时间，所以可能造成用户等待时间变长，造成用户体验下降。 一对多，多对多：通常情况下我们都是采用延迟加载。多对一，一对一：通常情况下我们都是采用立即加载。 一对多案例 在SqlMapConfig.xml中配置setting标签 123456&lt;settings&gt; &lt;!-- 配置全局缓存--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; IUserDao.xml中配置collection标签 property=”accList” : 关联查询的结果集存储在 User 对象的上哪个属性。 ofType=”account” ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名 单单1对多的查询，只需要上面两个属性，下面2个用于延迟加载 1对多查询原理：代理对象通过findAll()的sql语句执行结果封装到rusultMap的嵌套结构中 select 用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 id column 用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一 个字段名了 （根据user的id查询账户） 123456789101112131415161718192021222324&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.itheima.dao.IAccountDao.findAccountByUid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 1234&lt;!-- 根据用户id查询账户列表 --&gt; &lt;select id=&quot;findAccountByUid&quot; resultType=&quot;account&quot;&gt; select * from account where uid = #&#123;uid&#125; &lt;/select&gt; 测试类 当注释了for循环输出，会发现只执行了一个findAll()的select语句，另一个select并没有执行，这就是延迟加载，你用不到我就我就不给你 123456789@Test public void findAll()&#123; List&lt;Account&gt; accounts = accoutDao.findAll(); for (Account account:accounts) &#123; System.out.println(&quot;每一个account的信息&quot;); System.out.println(account); System.out.println(account.getUser()); &#125; &#125; 缓存概念 什么是缓存 存在于内存中的临时数据 为什么使用缓存 减少与数据库的交互次数，提高执行效率 什么样的数据能使用缓存，什么样的数据不能使用 适用于缓存： 经常查询并且不经常改变的。 数据的正确与否对最终结果影响不大的不适用于缓存： 经常改变的数据。 数据的正确与否对最终结果影响很大的。如，商品库存，银行汇率，股市牌价。 mybatis中的一级缓存和二级缓存一级缓存 它指的是mybatis中SqlSession对象的缓存。 当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域中。 每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。 当SqlSession对象消失时，mybatis的一级缓存也就消失了。 测试 1234567public void getStudentById() throws Exception &#123; SqlSession sqlSession = factory.openSession(true); // 自动提交事务 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); System.out.println(studentMapper.getStudentById(1)); System.out.println(studentMapper.getStudentById(1)); System.out.println(studentMapper.getStudentById(1)); &#125; 二级缓存 它指的是mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 二级缓存的使用步骤： 第一步：让mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） 第三步：让当前的操作支持二级缓存（在select标签中配置） 12345678910111213141516@Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125; 这里要注意最后一个结果为false，图片没截好，原因如下]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1对1 account类 12345678910//从表实体应该包含一个主表实体的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; IAccountDao接口 12345678public interface IAccountDao &#123; /** * 查询所有账户 * @return */ List&lt;Account&gt; findAll();&#125; AccountDao的mapper 1234567891011121314151617&lt;mapper namespace=&quot;top.zoick.dao.IAccountDao&quot;&gt; &lt;!--定义封装account和user的resultMap--&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt; &lt;!--一对一的关系映射，配置封装user的内容 column中指名从表的外键 property=&quot;user&quot;指的是单个实体类的引用--&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; AccountDao的测试类 123456789@Testpublic void findAll()&#123; List&lt;Account&gt; accounts = accoutDao.findAll(); for (Account account:accounts) &#123; System.out.println(&quot;每一个account的信息&quot;); System.out.println(account); System.out.println(account.getUser()); &#125;&#125; 1对多示例：一个用户可以有多个账户 多对多]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis连接池 动态SQL]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[连接池连接池：存储连接的一个容器 容器：就是一个集合，必须保证线程安全，不能2个线程拿到同一个连接 123456789101112131415161718&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 数据源DataSource分类mybatis连接池提供了3种配置方式： 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。 type属性的值： POOLED 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现 ​ UNPOOLED 采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的 数据源的创建过程在mybatis的XML配置文件中，使用元素来配置数据源 MyBatis在初始化时，解析此文件，根据的type属性来创建相应类型的的数据源DataSource type=”POOLED” ：MyBatis会创建PooledDataSource实例 type=”UNPOOLED” ：MyBatis会创建UnpooledDataSource实例 type=”JNDI”：MyBatis会从JNDI服务上查找DataSource实例，然后返回使用 MyBatis是通过工厂模式来创建数据源DataSource对象的，MyBatis定义了抽象的工厂接 口:org.apache.ibatis.datasource.DataSourceFactory,通过其getDataSource()方法返回数据源DataSource MyBatis创建了DataSource实例后，会将其放到Configuration对象内的Environment对象中， 供以后使用 DataSource什么时候创建Connection对象12345String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;); 前4句都不会导致java.sql.Connection对象的创建，只有当第5句sqlSession.selectList(“SELECT * FROM STUDENTS”)，才会触发MyBatis在底层执行下面这个方法来创建java.sql.Connection对象 12345678910protected void openConnection() throws SQLException &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;Opening JDBC Connection&quot;); &#125; connection = dataSource.getConnection(); if (level != null) &#123; connection.setTransactionIsolation(level.getLevel()); &#125; setDesiredAutoCommit(autoCommmit); &#125; 动态sql标签 我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询 1List&lt;User&gt; findByCondition(User user); 1234567891011&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;userName != null&quot;&gt; and username = #&#123;userName&#125; &lt;/if&gt; &lt;if test=&quot;userSex != null&quot;&gt; and sex = #&#123;userSex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 123456789101112@Test public void testFindByCondiion() throws Exception &#123; User u = new User(); u.setUserName(&quot;aa&quot;);// u.setUserSex(&quot;女&quot;); init(); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findByCondition(u); for (User user : users) &#123; System.out.println(user); &#125; &#125; 标签 传入多个 id 查询用户信息，用下边两个 sql 实现： SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16) SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。 这样我们将如何进行参数的传递？ 1234567891011public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125; &#125; dao接口 1List&lt;User&gt; findInIds(QueryVo vo); dao映射配置 标签用于遍历集合，它的属性： ​ collection:代表要遍历的集合元素，注意编写时不要写#{} ​ open:代表语句的开始部分 ​ close:代表结束部分 ​ item:代表遍历集合的每个元素，生成的变量名 ​ sperator:代表分隔符 12345678910111213&lt;!-- 查询所有用户在 id 的集合之中 --&gt; &lt;select id=&quot;findInIds&quot; resultType=&quot;user&quot; parameterType=&quot;queryvo&quot;&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;id in ( &quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt; &lt;!--item要和下面的#&#123;uid&#125;保持一致，应该是传过来一个ids集合，#获取到里面的值，与item对应，在放入collection集合中--&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 123456789101112131415@Test public void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(41); ids.add(42); ids.add(43); ids.add(46); ids.add(57); vo.setIds(ids); //6.执行操作 List&lt;User&gt; users = userDao.findInIds(vo); for(User user : users) &#123; System.out.println(user); &#125; 抽取重复sql 123456789&lt;!--抽取重复的sql语句--&gt;&lt;sql id=&quot;defaultUser&quot;&gt; select * from user&lt;/sql&gt;&lt;!--配置查询所有 其中id不能乱写必须是dao接口中的方法 resultType写的是实体类的全路径--&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; &lt;include refid=&quot;defaultUser&quot;/&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatisCRUD]]></title>
    <url>%2F2019%2F10%2F14%2FmybatisCRUD%2F</url>
    <content type="text"><![CDATA[基本的CRUD代码接口类代码 1234567891011121314151617181920212223242526//用户持久层接口public interface IUserDao &#123; //查询所有 List&lt;User&gt; findAll(); //保存用户 void saveUser(User user); //更新 void updateUser(User user); //删除 void deleteUser(Integer userId); User findById(Integer userId); //模糊查询 List&lt;User&gt;findByName(String username); //查询总用户数 int findTotal(); //根据queryvo中的条件查询用火狐 List&lt;User&gt; findUserByVo(QueryVo vo);&#125; mapper代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.zoick.dao.IUserDao&quot;&gt; &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;top.zoick.domain.User&quot;&gt; &lt;!--主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--配置查询所有 其中id不能乱写必须是dao接口中的方法 resultType写的是实体类的全路径--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; &lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt; &lt;!--select id as userId,username as userName,address as userAddress ,sex as userSex, birthday as userBirthday from user--&gt; select * from user&lt;/select&gt; &lt;!--保存用户--&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;top.zoick.domain.User&quot;&gt; &lt;!--配置插入操作后，获取插入数据的id--&gt; &lt;!--keyProperty对应实体类属性名:id，keyColumn对应于数据库:id resultType为数据类型，order为在这条insert sql语句执行前还是执行后做--&gt; &lt;selectKey keyProperty=&quot;userId&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user (username,address,sex,birthday) values (#&#123;userName&#125;,#&#123;userAddress&#125;,#&#123;userSex&#125;,#&#123;userBirthday&#125;) &lt;/insert&gt; &lt;!--更新用户--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;usER&quot;&gt; update user set username=#&#123;userName&#125;,address=#&#123;userAddress&#125;,sex=#&#123;userSex&#125;,birthday=#&#123;userBirthday&#125; where id=#&#123;userId&#125; &lt;/update&gt; &lt;!--删除用户--&gt; &lt;!--当参数值为基本类型或者基本类型包装类时，SQL语句中的占位符可以随意写--&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt; delete from user where id = #&#123;anyzhanweifu&#125; &lt;/delete&gt; &lt;!--根据id查询用户--&gt; &lt;select id=&quot;findByID&quot; parameterType=&quot;INT&quot; resultMap=&quot;userMap&quot;&gt; select * from user where id = #&#123;uuuuuuid&#125; &lt;/select&gt; &lt;!--根据名称模糊查询--&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;String&quot; resultMap=&quot;userMap&quot;&gt; select * from user where username like #&#123;namenamenamename&#125; &lt;!--select * from user where username like &apos;%$&#123;value&#125;%&apos;--&gt; &lt;/select&gt; &lt;!--查询记录的总用户条数--&gt; &lt;select id=&quot;findTotal&quot; resultType=&quot;Integer&quot;&gt; select count(id) from user &lt;/select&gt; &lt;!--根据QueryVo的条件查询用户--&gt; &lt;select id=&quot;findUserByVo&quot; parameterType=&quot;top.zoick.domain.QueryVo&quot; resultMap=&quot;userMap&quot;&gt; select * from user where username like #&#123;user.username&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class MybatisTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建SqlSessionFactory工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.使用工厂生产SqlSession对象 sqlSession = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destory() throws IOException &#123; //提交事务 sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 * * @throws IOException */ @Test public void testFindALl() throws Exception &#123; //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存操作 */ @Test public void testSave() throws Exception &#123; User user = new User(); user.setUserName(&quot;modify user&quot;); user.setUserAddress(&quot;天津&quot;); user.setUserBirthday(new Date()); user.setUserSex(&quot;男&quot;); System.out.println(&quot;保存操作之前：&quot; + user); //5.使用代理对象执行方法 userDao.saveUser(user); System.out.println(&quot;保存操作之后：&quot; + user); &#125; /** * 测试更新操作 */ @Test public void testUpdate() throws Exception &#123; User user = new User(); user.setUserId(51); user.setUserName(&quot;mybatis updateUser&quot;); user.setUserAddress(&quot;天津1&quot;); user.setUserBirthday(new Date()); user.setUserSex(&quot;男&quot;); //5.使用代理对象执行方法 userDao.updateUser(user); &#125; /** * 测试删除 */ @Test public void testDelete() throws Exception &#123; //5.执行删除方法 userDao.deleteUser(51); &#125; /** * 测试根据id查询用户 */ @Test public void testFindById() throws Exception &#123; //5.执行查询一个 User user = userDao.findByID(42); System.out.println(user); &#125; /** * 测试名称模糊查询用户信息 */ @Test public void testFindByName() throws Exception &#123; //5.执行模糊查询 List&lt;User&gt; user = userDao.findByName(&quot;%彭%&quot;);// List&lt;User&gt; user = userDao.findByName(&quot;彭&quot;); System.out.println(user); &#125; /** * 测试查询用户条数 */ @Test public void testFindTotal() throws Exception &#123; init(); //执行查询总记录条数 Integer number = userDao.findTotal(); System.out.println(&quot;总记录条数为：&quot; + number); &#125; /** * 测试使用QueryVo作为查询条件 */ @Test public void testFindUserByVo() throws Exception &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName(&quot;%彭%&quot;); vo.setUser(user); List&lt;User&gt; users = userDao.findUserByVo(vo); for (User u : users) &#123; System.out.println(u); &#125; &#125;&#125; 注意点数据库表名和实体类属性名不一致1.起别名 12345&lt;!--配置查询所有 其中id不能乱写必须是dao接口中的方法 resultType写的是实体类的全路径--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;top.zoick.domain.User&quot;&gt; &lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt; select id as userId,username as userName,address as userAddress ,sex as userSex, birthday as userBirthday from user &lt;/select&gt; 2.配置查询结果的列名和实体类的属性名的对应关系 123456789101112131415 &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;top.zoick.domain.User&quot;&gt; &lt;!--主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;bithday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt;再在查询的sql语句的xml中加入配置 &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; 配置别名作用：mapper.xml里面例如parameterType=””就不用写全限定类名，写别名即可 1.使用typeAliases配置别名 12345&lt;!--使用typeAliases配置别名，他只能配置domain中类的别名--&gt; &lt;typeAliases&gt; &lt;!--typeAlias用于配置别名，type属性指定的是实体类中的全限定类名。alias属性指定别名，当指定了别名后不在区分大小写--&gt; &lt;typeAlias type=&quot;top.zoick.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; 2.使用package配置别名 1234&lt;typeAliases&gt; &lt;!--用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt; &lt;package name=&quot;top.zoick.domain&quot;/&gt;&lt;/typeAliases&gt; OGNL表达式Object Graphic Navigation Language对象 图 导航 语言它是通过对象的取值方法来获取数据。·在写法上把get给省略了比如:我们获取用户的名称 类中的写法:user.getUsername, OGNL表达式写法:user.usernamemybatis中为什么能直接写username,而不用user.呢: 因为在parameterType中已经提供了属性所属的类, 所以此时不需要写对象名]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static,instanceof,转型]]></title>
    <url>%2F2019%2F09%2F28%2Fstatic-instanceof-%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[static关键字静态变量和静态方法static最基本的用法 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来 被static修饰的变量、被static修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。JDK把不同的静态资源放在了不同的类中而不把所有静态资源放在一个类里面，很多人可能想当然认为当然要这么做，但是是否想过为什么要这么做呢？个人认为主要有三个好处： 1、不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样就很清晰了 2、避免重名。不同的类之间有重名的静态变量名、静态方法名也是很正常的，如果所有的都放在一起不可避免的一个问题就是名字重复，这时候怎么办？分类放置就好了。 3、避免静态资源类无限膨胀，这很好理解。 OK，再微微深入一下，也是有些人容易混淆的一个问题：静态方法能不能引用非静态资源？静态方法里面能不能引用静态资源？非静态方法里面能不能引用静态资源？比如就以这段代码为例，是否有错？ 1234567891 public class A2 &#123;3 private int i = 1;4 5 public static void main(String[] args)6 &#123;7 i = 1;8 &#125;9 &#125; 当然有错，在第7行的地方。不妨这么思考这个问题： 静态资源属于类，但是是独立于类存在的。从JVM的类加载机制的角度讲，静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的。类的初始化早于类的new，比如Class.forName(“xxx”)方法，就是初始化了一个类，但是并没有new它，只是加载这个类的静态资源罢了。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的；但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。所以上面的几个问题答案就很明确了： 1、静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。 2、静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。 3、非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。 静态块静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，静态块里面的代码只执行一次，且只在初始化类的时候执行。静态块很简单，不过提三个小细节： 1234567891011121314151617181920 1 public class A 2 &#123; 3 private static int a = B(); 4 5 static 6 &#123; 7 System.out.println(&quot;Enter A.static block&quot;); 8 &#125; 9 10 public static void main(String[] args)11 &#123;12 new A();13 &#125;14 15 public static int B()16 &#123;17 System.out.println(&quot;Enter A.B()&quot;);18 return 1;19 &#125;20 &#125; 12Enter A.B()Enter A.static block 出第一个结论：静态资源的加载顺序是严格按照静态资源的定义顺序来加载的。 12345678910 1 public class A 2 &#123; 3 static 4 &#123; 5 c = 3; 6 System.out.println(c); 7 &#125; 8 9 private static int c;10 &#125; 这段代码的第6行是有错误的“Cannot reference a field before it is defined”。从这个例子得出第二个结论：静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问 最后一个小例子： 123456789101112 1 public class A 2 &#123; 3 static 4 &#123; 5 System.out.println(&quot;A.static block&quot;); 6 &#125; 7 8 public A() 9 &#123;10 System.out.println(&quot;A.constructor()&quot;);11 &#125;12 &#125; 123456789101112131415161718 1 public class B extends A 2 &#123; 3 static 4 &#123; 5 System.out.println(&quot;B.static block&quot;); 6 &#125; 7 8 public B() 9 &#123;10 System.out.println(&quot;B.constructor()&quot;);11 &#125;12 13 public static void main(String[] args)14 &#123;15 new B();16 new B();17 &#125;18 &#125; 123456A.static blockB.static blockA.constructor()B.constructor()A.constructor()B.constructor() 这个例子得出第三个结论：静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次 这一部分转自https://www.cnblogs.com/swisszhang/p/9892992.html]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring mvc基础]]></title>
    <url>%2F2019%2F09%2F28%2Fspring%20mvc%2F</url>
    <content type="text"><![CDATA[概念spring mvc负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） springmvc基本组件及流程分析处理器映射器HandlerMapping,处理器适配器HandlAdapter,视图解析器ViewResolver称为SpringMVC三大组件.在bean.xml中声明&lt;mvc:annotation-driven conversion-service=”conversionService”/&gt;标签相当于自动配置了处理器映射器和处理器适配，视图解析器需要自己配置 12345 &lt;!-- 配置视图解析器,用于解析项目跳转到的文件的位置 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 前端控制器(核心控制器)DispatcherServlet:用户请求最先达到的控制器,前端控制器调用其他组件处理请求,是MVC架构中的C,是整个流程控制的核心.其存在降低了组件间的耦合性. 处理器映射器HandlerMapping:负责根据用户请求找到处理器. 处理器适配器HandlAdapter: 对处理器进行执行.这是一种适配器模式的应用 处理器Handler:具体的业务方法. 视图解析器ViewResolver: 负责将处理结果生成视图. ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址,再生成View视图对象,最后对View进行渲染将处理结果通过页面展示给用户 请求参数绑定概念：拿到客户端发出请求的请求参数的过程叫做请求参数的绑定 基本数据类型和字符串类型 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) 1&lt;a href=&quot;account/findAccount?accountId=10&amp;accountName=zhangsan&quot;&gt;查询账户&lt;/a&gt; 12345@RequestMapping(&quot;/findAccount&quot;) public String findAccount(Integer accountId,String accountName) &#123; System.out.println(&quot;查询了账户。。。。&quot;+accountId+&quot;,&quot;+accountName); return &quot;success&quot;; &#125; 实体类型（JavaBean） 参数也要保持一致 1234567public class User implements Serializable&#123; private String uname; private Integer age; private Date date; private User user; ... 123456@RequestMapping(&quot;/saveAccount&quot;)public String saveAccount(Account account)&#123; System.out.println(&quot;执行了...&quot;); System.out.println(account); return &quot;success&quot;;&#125; 12345678&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; 金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;user.uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; 集合数据类型（List、map集合等） 1234567891011public class Account implements Serializable&#123; private String username; private String password; private Double money; // private User user; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; ... 123456789101112&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; 金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;br/&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot; /&gt;&lt;br/&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].age&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; 大体流程：uname,age封装到user对象，再把user添加到list集合中 常用注解基本的参数绑定：请求中的value值会传递给控制器方法的参数 1&lt;a href=&quot;account/findAccount?name=哈哈&quot;&gt;查询账户&lt;/a&gt; 12345678910// 控制器类@Controller@RequestMapping(path = &quot;/account&quot;)public class HelloController &#123; @RequestMapping(path = &quot;/findAccount&quot;) public void findAccount(String name) &#123; System.out.println(name); &#125;&#125; RequestParam注解 把请求中的指定名称的参数传递给控制器中的形参赋值 ,本来如果是name直接可以获取到，现在为username，与name不一样时，就要用到这个注解 name: value属性的别名,指定请求参数的名称 required: 指定该请求参数是否必须的,默认为true 1&lt;a href=&quot;testRequestParam?name=哈哈&quot;&gt;测试requestParam注解&lt;/a&gt; 123456@RequestMapping(&quot;/testRequestParam&quot;)public String handlerMethod(@RequestParam(name=&quot;name&quot;) String username) &#123; System.out.println(&quot;执行了...&quot;); System.out.println(username); return &quot;success&quot;;&#125; RequestBody注解 用于获取请求体的内容（注意：get方法不可以） 123456@RequestMapping(path=&quot;/hello&quot;) public String sayHello(@RequestBody String body) &#123; System.out.println(&quot;aaaa&quot;); System.out.println(body); return &quot;success&quot;; &#125; PathVariable注解 拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 。 这里就可以将10-&gt;sid-&gt;id 1&lt;a href=&quot;testPathVariable/10&quot;&gt;测试&lt;/a&gt; 123456@RequestMapping(value=&quot;/testPathVariable/&#123;sid&#125;&quot;)public String testPathVariable(@PathVariable(name=&quot;sid&quot;) String id)&#123; System.out.println(&quot;执行了...&quot;); System.out.println(id); return &quot;success&quot;;&#125; RequestHeader注解 获取指定请求头的值 value：请求头的名称 1234@RequestMapping(path=&quot;/hello&quot;) public String sayHello(@RequestHeader(value=&quot;Accept&quot;) String header) &#123; System.out.println(header); return &quot;success&quot;; &#125; CookieValue注解 ：用于获取指定cookie的名称的值 1234@RequestMapping(path=&quot;/hello&quot;) public String sayHello(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) &#123; System.out.println(cookieValue); return &quot;success&quot;; &#125; ModelAttribute注解 出现在方法上：表示当前方法会在控制器方法执行前先执行。 出现在参数上：获取指定的数据给参数赋值。 方式1：有返回值，这里uname和age会从表单那获得，数据会变，age不是20，data数据则会从模拟的数据库中去取 12345&lt;form action=&quot;anno/testModelAttribute&quot; method=&quot;post&quot;&gt; 用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;&lt;br/&gt; 用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt; 12345678910111213141516@RequestMapping(value=&quot;/testModelAttribute&quot;) public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user)&#123; System.out.println(&quot;testModelAttribute执行了...&quot;); System.out.println(user); return &quot;success&quot;; &#125; @ModelAttribute public User showUser(String uname)&#123; System.out.println(&quot;showUser执行了...&quot;); // 通过用户查询数据库（模拟） User user = new User(); user.setUname(uname); user.setAge(20); user.setDate(new Date()); return user; &#125; 方式2：无返回值，将user存入map，再通过这个注解取得user内容 1234567891011121314151617@RequestMapping(value=&quot;/testModelAttribute&quot;) public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user)&#123; System.out.println(&quot;testModelAttribute执行了...&quot;); System.out.println(user); return &quot;success&quot;; &#125; @ModelAttribute public void showUser(String uname, Map&lt;String,User&gt; map)&#123; System.out.println(&quot;showUser执行了...&quot;); // 通过用户查询数据库（模拟） User user = new User(); user.setUname(uname); user.setAge(20); user.setDate(new Date()); map.put(&quot;abc&quot;,user); &#125; SessionAttributes注解 用于多次执行控制器方法间的参数共享 ，也就是session，之所以不用request方法是为了降低与servlet api之间的耦合度 1234567891011121314151617181920212223242526272829303132333435 @RequestMapping(path=&quot;/updateUser&quot;) public String updateUser(@ModelAttribute(value=&quot;abc&quot;) User user) &#123; System.out.println(user); return &quot;success&quot;; &#125; @Controller @RequestMapping(path=&quot;/user&quot;) @SessionAttributes(value= &#123;&quot;username&quot;,&quot;password&quot;,&quot;age&quot;&#125;,types= &#123;String.class,Integer.class&#125;) // 把数据存入到session域对象中 public class HelloController &#123; /** * 向session中存入值 * @return */ @RequestMapping(path=&quot;/save&quot;) public String save(Model model) &#123; System.out.println(&quot;向session域中保存数据&quot;); model.addAttribute(&quot;username&quot;, &quot;root&quot;); model.addAttribute(&quot;password&quot;, &quot;123&quot;); model.addAttribute(&quot;age&quot;, 20); return &quot;success&quot;; &#125; /** * 从session中获取值 * @return */ @RequestMapping(path=&quot;/find&quot;) public String find(ModelMap modelMap) &#123; String username = (String) modelMap.get(&quot;username&quot;); String password = (String) modelMap.get(&quot;password&quot;); Integer age = (Integer) modelMap.get(&quot;age&quot;); System.out.println(username + &quot; : &quot;+password +&quot; : &quot;+age); return &quot;success&quot;; &#125; 响应数据和结果视图 返回字符串 Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址 123456@RequestMapping(value=&quot;/hello&quot;) public String sayHello() &#123; System.out.println(&quot;Hello SpringMVC!!&quot;); // 跳转到XX页面 return &quot;success&quot;; &#125; 返回值是void 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到 可以使用请求转发或者重定向跳转到指定的页面 1234567891011@RequestMapping(value=&quot;/initAdd&quot;) public void initAdd(HttpServletRequest request,HttpServletResponse response) throws Exception &#123; System.out.println(&quot;请求转发或者重定向&quot;); // 请求转发 // request.getRequestDispatcher(&quot;/WEB-INF/pages/add.jsp&quot;).forward(request, response); // 重定向 // response.sendRedirect(request.getContextPath()+&quot;/add2.jsp&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); // 直接响应数据 response.getWriter().print(&quot;你好&quot;); return; &#125; 返回值是ModelAndView对象 ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图 model可以存储对象，view可以跳转页面 123456789101112131415@RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView()&#123; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); System.out.println(&quot;testModelAndView方法执行了...&quot;); // 模拟从数据库中查询出User对象 User user = new User(); user.setUsername(&quot;小凤&quot;); user.setPassword(&quot;456&quot;); user.setAge(30); // 把user对象存储到mv对象中，也会把user对象存入到request对象 mv.addObject(&quot;user&quot;,user); // 跳转到哪个页面 mv.setViewName(&quot;success&quot;); return mv; foward和redirect 123456@RequestMapping(&quot;/delete&quot;) public String delete() throws Exception &#123; System.out.println(&quot;delete方法执行了...&quot;); // return &quot;forward:/WEB-INF/pages/success.jsp&quot;; return &quot;forward:/user/findAll&quot;; &#125; 123456@RequestMapping(&quot;/count&quot;) public String count() throws Exception &#123; System.out.println(&quot;count方法执行了...&quot;); return &quot;redirect:/add.jsp&quot;; // return &quot;redirect:/user/findAll&quot;; &#125; ResponseBody响应json数据 DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而 不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 mvc:resources标签配置不过滤 location元素表示webapp目录下的包下的所有文件 mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b 1234&lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/&quot; /&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/&quot;/&gt; 使用@RequestBody获取请求体数据 1234@RequestMapping(&quot;/testJson&quot;) public void testJson(@RequestBody String body) &#123; System.out.println(body); &#125; 12345678910111213141516$(function () &#123; $(&quot;#btn&quot;).click(function () &#123; //alert(&quot;hello btn&quot;); $.ajax(&#123; // 编写json格式，设置属性和值 url:&quot;user/testAjax&quot;, contentType:&quot;application/json;charset=UTF-8&quot;, data:&apos;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&apos;, dataType:&quot;json&quot;, type:&quot;post&quot;, success:function(data) &#123; &#125; &#125;); &#125;); &#125;); 使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应 12345678910@RequestMapping(&quot;/testAjax&quot;) public @ResponseBody User testAjax(@RequestBody User user) &#123; System.out.println(&quot;响应ajax&quot;); //客户端发送请求，传的是json格式的数据，后端把数据封装到user对象中 System.out.println(user); //做响应 user.setAge(20); user.setUsername(&quot;haha&quot;); return user; &#125; 12345678910111213141516171819$(function () &#123; $(&quot;#btn&quot;).click(function () &#123; //alert(&quot;hello btn&quot;); $.ajax(&#123; // 编写json格式，设置属性和值 url:&quot;user/testAjax&quot;, contentType:&quot;application/json;charset=UTF-8&quot;, data:&apos;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&apos;, dataType:&quot;json&quot;, type:&quot;post&quot;, success:function(data) &#123; //data服务器响应的json数据，进行解析 alert(data); alert(data.usrname); alert(data.age); &#125; &#125;); &#125;); &#125;); 异常处理异常处理思路 异常处理步骤 controller类 123456789101112131415@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/testException&quot;) public String testException()throws Exception&#123; System.out.println(&quot;异常处理&quot;); try &#123; int i=1/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new myexception(&quot;出现异常&quot;); &#125; return &quot;success&quot;; &#125;&#125; 自定义异常类 123456789101112131415public class myexception extends Exception &#123; private String message; public myexception(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器 1234567891011121314151617181920public class myexceptionResolver implements HandlerExceptionResolver &#123; public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) &#123; //获取异常对象 myexception s=null; //instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例 //obj instanceof Class //其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。 if (ex instanceof myexception)&#123; s=(myexception) ex; &#125;else &#123; s=new myexception(&quot;程序在维护&quot;); &#125; //创建ModelAndView对象 ModelAndView mv=new ModelAndView(); mv.addObject(&quot;errormsg&quot;, s.getMessage()); mv.setViewName(&quot;error&quot;); return mv; &#125;&#125; 配置异常处理器 1&lt;bean id=&quot;myexceptionResolver&quot; class=&quot;cn.itcast.exception.myexceptionResolver&quot;&gt;&lt;/bean&gt; 拦截器 概念 SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链 中的拦截器会按着定义的顺序执行 拦截器和过滤器的功能比较类似，有区别 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术，拦截器是SpringMVC框架独有的 过滤器配置了/*，可以拦截任何资源，拦截器只会对控制器中的方法进行拦截 拦截器也是AOP思想的一种实现方式 ，想要自定义拦截器，需要实现HandlerInterceptor接口 使用步骤 创建类，实现HandlerInterceptor接口，重写需要的方法 1234567891011121314151617181920 public class interceptor1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;我要拦截你，interceptor1&quot;); //request.getRequestDispatcher(&quot;WEB-INF/pages/error.jsp&quot;).forward(request,response); //放行 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;拦截1已经执行了&quot;); //request.getRequestDispatcher(&quot;WEB-INF/pages/error.jsp&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;我TM最后&quot;); &#125;&#125; 在springmvc.xml中配置拦截器类 123456789&lt;!-- 配置拦截器的作用范围 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;&lt;!-- 用于指定排除的 url--&gt; &lt;bean id=&quot;handlerInterceptorDemo1&quot; class=&quot;com.itheima.web.interceptor.HandlerInterceptorDemo1&quot;&gt; &lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; HandlerInterceptor中的方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法， return false不放行，不会执行controller中的方法 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示 postHandle方法是在JSP执行后执行 request或者response不能再跳转页面了]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务进阶]]></title>
    <url>%2F2019%2F09%2F23%2F%E4%BA%8B%E5%8A%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一个没有加@Transactional注解的方法，去调用一个加了@Transactional的方法，会不会产生事务？ @Transactional： 对接口加上@Transactional注解,表示对该接口的所有实现类进行事务控制 对类加上@Transactional注解,表示对类中的所有方法进行事务控制 对具体某一方法加以@Transactional注解,表示对具体方法进行事务控制 一个@Transactional的方法 12345678@Transactionalpublic void deleteAllAndAddOneTransactional(Customer customer) &#123; customerRepository.deleteAll(); if (&quot;Yang&quot;.equals(customer.getFirstName())) &#123; throw new RuntimeException(); &#125; customerRepository.save(customer);&#125; 方法内先去执行deleteAll()，删除表中全部数据；然后执行save()保存数据。 这两个方法中间，会判断传进来的firstName是不是等于“Yang”，是，则抛异常，用于模拟两个数据库操作之间可能发生的异常场景。 如果没有加@Transactional注解，那么这两个操作就不在一个事务里面，不具有原子性。如果deleteAll之后抛异常，那么就会导致只删除不新增。 而加了@Transactional之后，这两个动作在一个事务里头，具有原子性，要么全部成功，要么全部失败。如果deleteAll之后抛异常，则事务回滚，恢复原先被删除的数据。 问题登场，这种情况下 12345678910111213public void deleteAllAndAddOne(Customer customer) &#123;System.out.println("go into deleteAllAndAddOne");deleteAllAndAddOneTransactional(customer);&#125;@Transactionalpublic void deleteAllAndAddOneTransactional(Customer customer) &#123;customerRepository.deleteAll();if ("Yang".equals(customer.getFirstName())) &#123;throw new RuntimeException();&#125;customerRepository.save(customer);&#125; 其实Spring的@Transactional，跟Spring AOP一样，都是利用了动态代理。 我们写了一个类，里面写了一个加了@Transactional注解的方法，这原本平淡无奇，什么用也没有，就像这样： 关键在于，Spring在检查到@Transactional注解之后，给这个对象生成了一个代理对象proxy： 代理对象的methodB，会先开启事务（beginTransaction），然后再去执行原先对象target的methodB，如果抛异常，则回滚（rollBack），如果一切顺利，则提交（commit）。 而最后注入Spring容器的，也正是这个带有事务逻辑的代理对象。所以我们调用methodB时会产生事务。 现在，我们写了一个新方法，methodA，里头去调用methodB： 由于methodA没有加@Transactional注解，所以代理对象里面，直接就是target.methodA()，直接调用了原来对象的methodA。 这下就很清晰了，代理对象的methodA，去调用原来对象的methodA，原来对象的methodA，再去调用原来对象的methodB，而原来对象的methodB，是不具有事务的。事务只存在于代理对象的methodB. 所以整个方法也就没有事务了。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcTemplate和事务]]></title>
    <url>%2F2019%2F09%2F23%2FjdbcTemplate%E5%92%8C%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[回顾对jdbc的优化历程原生的jdbc123456789101112131415161718try &#123; String sql = &quot;insert into t_dept(deptName) values(&apos;test&apos;);&quot;; Connection con = null; Statement stmt = null; //注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 连接对象 con = DriverManager.getConnection(&quot;jdbc:mysql:///hib_demo&quot;, &quot;root&quot;, &quot;root&quot;); // 执行命令对象 stmt = con.createStatement(); // 执行 stmt.execute(sql); // 关闭 stmt.close(); con.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 进化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 连接数据库的driver，url，username，password通过配置文件来配置，可以增加灵活性 * 当我们需要切换数据库的时候，只需要在配置文件中改以上的信息即可 * * */ private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static &#123; try &#123; //获取配置文件的读入流 InputStream inputStream = UtilsDemo.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(inputStream); //获取配置文件的信息 driver = properties.getProperty(&quot;driver&quot;); url = properties.getProperty(&quot;url&quot;); username = properties.getProperty(&quot;username&quot;); password = properties.getProperty(&quot;password&quot;); //加载驱动类 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,username,password); &#125; public static void release(Connection connection, Statement statement, ResultSet resultSet) &#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 经过上面一层的封装，我们可以在使用的地方直接使用工具类来得到与数据库的连接…那么比原来就方便很多了！但是呢，每次还是需要使用Connection去创建一个Statement对象。并且无论是什么方法，其实就是SQL语句和传递进来的参数不同！ spring的jdbcTemplate首先还是看一下我们原生的JDBC代码：获取Connection是可以抽取出来的，直接使用dataSource来得到Connection就行了。 JdbcTemplate对象在执行sql语句时也需要一个数据源,这个数据源可以使用C3P0或者DBCP,也可以使用Spring的内置数据源DriverManagerDataSource 123456789101112131415161718192021222324252627282930313233343536&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///hib_demo&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxStatements&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot; value=&quot;2&quot;&gt;&lt;/property&gt;&lt;/bean&gt;// IOC容器注入private DataSource dataSource;public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource;&#125;public void save() &#123; try &#123; String sql = &quot;insert into t_dept(deptName) values(&apos;test&apos;);&quot;; Connection con = null; Statement stmt = null; // 连接对象 con = dataSource.getConnection(); // 执行命令对象 stmt = con.createStatement(); // 执行 stmt.execute(sql); // 关闭 stmt.close(); con.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; Spring来提供了JdbcTemplate这么一个类给我们使用！它封装了DataSource，也就是说我们可以在Dao中使用JdbcTemplate就行了。 配置c3p0数据源： 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/数据库名&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;用户名&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;密码&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 创建JdbcTemplate对象，向JdbcTemplate的构造方法传入数据源创建对象 123 &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 使用JdbcTemplate实现增删改 JdbcTemplate的增删改操作使用其update(&quot;SQL语句&quot;, 参数...)方法 12345678public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2.根据id获取JdbcTemplate对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(&quot;jdbcTemplate&quot;); //3.执行增加操作 jt.update(&quot;insert into account(name,money)values(?,?)&quot;,&quot;名字&quot;,5000);&#125; 12345678public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2.根据id获取JdbcTemplate对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(&quot;jdbcTemplate&quot;); //3.执行删除操作 jt.update(&quot;delete from account where id = ?&quot;,6);&#125; jdbcTemplate的query（）JdbcTemplate的查询操作使用其query()方法,其参数如下： String sql: SQL语句 RowMapper&lt;T&gt; rowMapper: 指定如何将查询结果ResultSet对象转换为T对象. @Nullable Object... args: SQL语句的参数 查询所有和一条记录 1234public List&lt;Account&gt; findAllAccounts() &#123; List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); return accounts;&#125; 1234public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where id = ?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return accounts.isEmpty() ? null : accounts.get(0);&#125; 在Dao层使用JdbcTemplate在DAO层使用JdbcTemplate,需要给DAO注入JdbcTemplate对象. 1234567891011121314151617181920212223public class AccountDaoImpl implements IAccountDao &#123; private JdbcTemplate jdbcTemplate; // JdbcTemplate对象 // JdbcTemplate对象的set方法 public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; // DAO层方法 @Override public Account findAccountById(Integer id) &#123; // 实现... &#125; // DAO层方法 @Override public Account findAccountByName(String name) &#123; // 实现... &#125; // 其它DAO层方法...&#125; Dao层中继承JdbcDaoSupport类在实际项目中,我们会创建许多DAO对象,若每个DAO对象都注入一个JdbcTemplate对象,会造成代码冗余. 实际的项目中我们可以让DAO对象继承Spring内置的JdbcDaoSupport类.在JdbcDaoSupport类中定义了JdbcTemplate和DataSource成员属性,在实际编程中,只需要向其注入DataSource成员即可,DataSource的set方法中会注入JdbcTemplate对象.DAO的实现类中调用父类的getJdbcTemplate()方法获得JdbcTemplate()对象. JdbcDaoSupport类的源代码如下: 123456789101112131415161718192021222324252627282930313233343536373839public abstract class JdbcDaoSupport extends DaoSupport &#123; @Nullable private JdbcTemplate jdbcTemplate; // 定义JdbcTemplate成员变量 public JdbcDaoSupport() &#123; &#125; // DataSource的set方法,注入DataSource时调用createJdbcTemplate方法注入JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; this.jdbcTemplate = this.createJdbcTemplate(dataSource); this.initTemplateConfig(); &#125; &#125; // 创建JdbcTemplate,用来被setDataSource()调用注入JdbcTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; // JdbcTemplate的get方法,子类通过该方法获得JdbcTemplate对象 @Nullable public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125; @Nullable public final DataSource getDataSource() &#123; return this.jdbcTemplate != null ? this.jdbcTemplate.getDataSource() : null; &#125; public final void setJdbcTemplate(@Nullable JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; this.initTemplateConfig(); &#125; // ...&#125; 在bean.xml中,我们只要为DAO对象注入DataSource对象即可,让JdbcDaoSupport自动调用JdbcTemplate的set方法注入JdbcTemplate 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/数据库名&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;用户名&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;密码&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置账户的持久层--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt; &lt;!--不用我们手动配置JdbcTemplate成员了--&gt; &lt;!--&lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在实现DAO接口时,我们通过super.getJdbcTemplate()方法获得JdbcTemplate对象. 即JdbcDaoSupport的DataSource的set方法会子啊注入dataSource时调用createJDbcTemplate方法，最后通过getJdbcTemplate方法得到jdbcTemplate对象 123456789101112131415161718192021222324252627public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; //调用继承自父类的getJdbcTemplate()方法获得JdbcTemplate对象 List&lt;Account&gt; list = getJdbcTemplate().query(&quot;select * from account whereid = ? &quot;, new AccountRowMapper(), id); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; //调用继承自父类的getJdbcTemplate()方法获得JdbcTemplate对象 List&lt;Account&gt; accounts = getJdbcTemplate().query(&quot;select * from account wherename = ? &quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (accounts.isEmpty()) &#123; return null; &#125; else if (accounts.size() &gt; 1) &#123; throw new RuntimeException(&quot;结果集不唯一，不是只有一个账户对象&quot;); &#125; return accounts.get(0); &#125; @Override public void updateAccount(Account account) &#123; //调用继承自父类的getJdbcTemplate()方法获得JdbcTemplate对象 getJdbcTemplate().update(&quot;update account set money = ? where id = ? &quot;, account.getMoney(), account.getId()); &#125;&#125; spring事务问题1： 一般地，我们事务控制都是在service层做的。。为什么是在service层而不是在dao层呢？？有没有这样的疑问… service层是业务逻辑层，service的方法一旦执行成功，那么说明该功能没有出错。 一个service方法可能要调用dao层的多个方法…如果在dao层做事务控制的话，一个dao方法出错了，仅仅把事务回滚到当前dao的功能，这样是不合适的。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP]]></title>
    <url>%2F2019%2F09%2F22%2FAOP%2F</url>
    <content type="text"><![CDATA[AOP相关概念Joinpoint(连接点): 被拦截到的方法. Pointcut(切入点): 我们对其进行增强的方法. Advice(通知/增强): 对切入点进行的增强操作 ​ 包括前置通知,后置通知,异常通知,最终通知,环绕通知 Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 Aspect(切面): 是切入点和通知的结合 使用XML配置AOP 在bean.xml中引入约束并将通知类注入Spring容器中 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--通知类--&gt; &lt;bean id=&quot;logger&quot; class=&quot;cn.maoritian.utils.Logger&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 使用&lt;aop:config&gt;标签声明AOP配置,所有关于AOP配置的代码都写在&lt;aop:config&gt;标签内 123&lt;aop:config&gt; &lt;!-- AOP配置的代码都写在此处 --&gt;&lt;/aop:config&gt; 使用&lt;aop:aspect&gt;标签配置切面,其属性如下 id: 指定切面的id ref: 引用通知类的id 12345&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!--配置通知的类型要写在此处--&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 使用&lt;aop:pointcut&gt;标签配置切入点表达式,指定对哪些方法进行增强,其属性如下 12345&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:pointcut expression=&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot; id=&quot;pt1&quot;&gt;&lt;/aop:pointcut&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 使用&lt;aop:xxx&gt;标签配置对应类型的通知方法 其属性如下: method: 指定通知类中的增强方法名.ponitcut-ref: 指定切入点的表达式的idpoinitcut: 指定切入点表达式其中pointcut-ref和pointref属性只能有其中一个 具体的通知类型: aop:before：配置前置通知,指定的增强方法在切入点方法之前执行.aop:after-returning：配置后置通知,指定的增强方法在切入点方法正常执行之后执行.aop:afetr-throwing：配置异常通知,指定的增强方法在切入点方法产生异常后执行.aop:after：配置最终通知,无论切入点方法执行时是否发生异常,指定的增强方法都会最后执行.aop:around： 配置环绕通知,可以在代码中手动控制增强代码的执行时机. 12345678910111213&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!--指定切入点表达式--&gt; &lt;aop:pointcut expression=&quot;execution(* cn,maoritian.service.impl.*.*(..))&quot; id=&quot;pt1&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置各种类型的通知--&gt; &lt;aop:before method=&quot;printLogBefore&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=&quot;printLogAfterReturning&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;printLogAfterThrowing&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:after method=&quot;printLogAfter&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt; &lt;!--环绕通知一般单独使用--&gt; &lt;!-- &lt;aop:around method=&quot;printLogAround&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; --&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 环绕通知 前置通知,后置通知,异常通知,最终通知的执行顺序 Spring是基于动态代理对方法进行增强的,前置通知,后置通知,异常通知,最终通知在增强方法中的执行时机如下: 123456789101112131415161718// 增强方法@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; Object rtValue = null; try &#123; // 执行前置通知 // 执行原方法 rtValue = method.invoke(accountService, args); // 执行后置通知 return rtValue; &#125; catch (Exception e) &#123; // 执行异常通知 &#125; finally &#123; // 执行最终通知 &#125;&#125; 环绕通知允许我们更自由地控制增强代码执行的时机 Spring框架为我们提供一个接口ProceedingJoinPoint,它的实例对象可以作为环绕通知方法的参数,通过参数控制被增强方法的执行时机. ProceedingJoinPoint对象的getArgs()方法返回被拦截的参数ProceedingJoinPoint对象的proceed()方法执行被拦截的方法 123456789101112131415// 环绕通知方法,返回Object类型public Object printLogAround(ProceedingJoinPoint pjp) &#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs(); printLogBefore(); // 执行前置通知 rtValue = pjp.proceed(args);// 执行被拦截方法 printLogAfterReturn(); // 执行后置通知 &#125;catch(Throwable e) &#123; printLogAfterThrowing(); // 执行异常通知 &#125;finally &#123; printLogAfter(); // 执行最终通知 &#125; return rtValue;&#125; spring中对AOP的注解用于声明切面的注解 @Aspect: 声明当前类为通知类,该类定义了一个切面.相当于xml配置中的&lt;aop:aspect&gt;标签 12345@Component(&quot;logger&quot;)@Aspectpublic class Logger &#123; // ...&#125; 用于声明通知的注解@Before: 声明该方法为前置通知.相当于xml配置中的aop:before标签@AfterReturning: 声明该方法为后置通知.相当于xml配置中的aop:after-returning标签@AfterThrowing: 声明该方法为异常通知.相当于xml配置中的aop:after-throwing标签@After: 声明该方法为最终通知.相当于xml配置中的aop:after标签@Around: 声明该方法为环绕通知.相当于xml配置中的aop:around标签属性: ​ value: 用于指定切入点表达式或切入点表达式的引用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component(&quot;logger&quot;)@Aspect //表示当前类是一个通知类public class Logger &#123; // 配置前置通知 @Before(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogBefore()&#123; System.out.println(&quot;前置通知Logger类中的printLogBefore方法开始记录日志了。。。&quot;); &#125; // 配置后置通知 @AfterReturning(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfterReturning()&#123; System.out.println(&quot;后置通知Logger类中的printLogAfterReturning方法开始记录日志了。。。&quot;); &#125; // 配置异常通知 @AfterThrowing(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfterThrowing()&#123; System.out.println(&quot;异常通知Logger类中的printLogAfterThrowing方法开始记录日志了。。。&quot;); &#125; // 配置最终通知 @After(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public void printLogAfter()&#123; System.out.println(&quot;最终通知Logger类中的printLogAfter方法开始记录日志了。。。&quot;); &#125; // 配置环绕通知 @Around(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs(); printLogBefore(); // 执行前置通知 rtValue = pjp.proceed(args); // 执行切入点方法 printLogAfterReturning(); // 执行后置通知 return rtValue; &#125;catch (Throwable t)&#123; printLogAfterThrowing(); // 执行异常通知 throw new RuntimeException(t); &#125;finally &#123; printLogAfter(); // 执行最终通知 &#125; &#125;&#125; 用于指定切入点表达式的注解 @Pointcut: 指定切入点表达式,其属性如下: value: 指定表达式的内容 @Pointcut注解没有id属性,通过调用被注解的方法获取切入点表达式. 1234567891011121314151617181920212223242526@Component(&quot;logger&quot;)@Aspect //表示当前类是一个通知类public class Logger &#123; // 配置切入点表达式 @Pointcut(&quot;execution(* cn.maoritian.service.impl.*.*(..))&quot;) private void pt1()&#123;&#125; // 通过调用被注解的方法获取切入点表达式 @Before(&quot;pt1()&quot;) public void printLogBefore()&#123; System.out.println(&quot;前置通知Logger类中的printLogBefore方法开始记录日志了。。。&quot;); &#125; // 通过调用被注解的方法获取切入点表达式 @AfterReturning(&quot;pt1()&quot;) public void printLogAfterReturning()&#123; System.out.println(&quot;后置通知Logger类中的printLogAfterReturning方法开始记录日志了。。。&quot;); &#125; // 通过调用被注解的方法获取切入点表达式 @AfterThrowing(&quot;pt1()&quot;) public void printLogAfterThrowing()&#123; System.out.println(&quot;异常通知Logger类中的printLogAfterThrowing方法开始记录日志了。。。&quot;); &#125;&#125; 纯注解配置AOP1234567@Configuration@ComponentScan(basePackages=&quot;cn.maoritian&quot;)@EnableAspectJAutoProxy // 允许AOPpublic class SpringConfiguration &#123; // 具体配置 //...&#125; 参考链接https://blog.csdn.net/ncepu_Chen/article/details/94510298#SpringAOP_159]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是泛型泛型：把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 相关术语： ArrayList：E为类型参数变量 ArrayList：实际类型参数 整个ArrayList为泛型类型 整个ArrayList为参数化的类型 为什么需要泛型没有泛型的情况下： Collection、Map集合对元素的类型是没有任何限制的。本来我的Collection集合装载的是全部的Dog对象，但是外边把Cat对象存储到集合中，是没有任何语法错误的。 把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是Object。因此在get()的时候，返回的是Object。外边获取该对象，还需要强制转换 有泛型的情况下： 程序简洁（不用强制转换） 程序健壮（只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常） 可读性和稳定性（在编写集合的时候，就限定了类型） Example 1234567891011//创建集合对象ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);//遍历,由于明确了类型.我们可以增强forfor (String s : list) &#123; System.out.println(s);&#125; 泛型类 泛型方法泛型类泛型类：泛型定义在类上，用户使用该类的时候，才把类型明确下来 基本格式： 123456789101112131415/* 1:把泛型定义在类上 2:类型变量定义在类上,方法中也可以使用 */public class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125; 用户想要使用哪种类型，就在创建的时候指定类型。使用的时候，该类就会自动转换成用户想要使用的类型了。 123456789101112131415161718public static void main(String[] args) &#123; //创建对象并指定元素类型 ObjectTool&lt;String&gt; tool = new ObjectTool&lt;&gt;(); tool.setObj(new String(&quot;xxx&quot;)); String s = tool.getObj(); System.out.println(s); //创建对象并指定元素类型 ObjectTool&lt;Integer&gt; objectTool = new ObjectTool&lt;&gt;(); /** * 如果我在这个对象里传入的是String类型的,它在编译时期就通过不了了. */ objectTool.setObj(10); int i = objectTool.getObj(); System.out.println(i);&#125; 泛型方法在类上定义的泛型在方法上也能用，那泛型方法的适用情况是什么呢 小题大做：我就想在一个方法上使用泛型，又不要考虑其他的，把整个类都泛型不是有点多余了吗 基本格式： 12345//定义泛型方法..public &lt;T&gt; void show(T t) &#123; System.out.println(t);&#125; 12345678910public static void main(String[] args) &#123; //创建对象 ObjectTool tool = new ObjectTool(); //调用方法,传入的参数是什么类型,返回值就是什么类型 tool.show(&quot;hello&quot;); tool.show(12); tool.show(12.5);&#125; 泛型类的子类泛型类本质上还是一个类，可以被继承 子类明确泛型类的类型参数变量 子类不明确泛型类的类型参数变量 明确类型参数变量1234567/* 把泛型定义在接口上 */public interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125; 1234567891011/** * 子类明确泛型类的类型参数变量: */public class InterImpl implements Inter&lt;String&gt; &#123; @Override public void show(String s) &#123; System.out.println(s); &#125;&#125; 不明确类型参数变量 当子类不明确泛型类的类型参数变量时，外界使用子类的时候，也需要传递类型参数变量进来，在实现类上需要定义出类型参数变量 12345678910public static void main(String[] args) &#123; //测试第一种情况 //Inter&lt;String&gt; i = new InterImpl(); //i.show(&quot;hello&quot;); //第二种情况测试 Inter&lt;String&gt; ii = new InterImpl&lt;&gt;(); ii.show(&quot;100&quot;);&#125; 类型通配符12345678public void test(List list)&#123; for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125;&#125; 像这个遍历集合list是可以的，但是会有警告，没有明确类型 12345678public void test(List&lt;Object&gt; list)&#123; for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125;&#125; 这样行不行呢？只能遍历装载Object类型的集合 那怎么办呢，就用到我们的类型通配符了 12345678public void test(List&lt;?&gt; list)&#123; for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125;&#125; ?号通配符表示可以匹配任意类型，任意的Java类都可以匹配….. 现在非常值得注意的是，当我们使用?号通配符的时候：就只能调对象与类型无关的方法，不能调用对象与类型有关的方法。 也就是说直到我们在这遍历才知道集合元素具体的类型，现在是不知道的，不能使用类似add()的方法，往里面加元素， 通配符上限1List&lt;? extends Number&gt; 上面的代码表示的是：List集合装载的元素只能是Number的子类或自身 123456789101112131415public static void main(String[] args) &#123; //List集合装载的是Integer，可以调用该方法 List&lt;Integer&gt; integer = new ArrayList&lt;&gt;(); test(integer); //List集合装载的是String，在编译时期就报错了 List&lt;String&gt; strings = new ArrayList&lt;&gt;(); test(strings);&#125;public static void test(List&lt;? extends Number&gt; list) &#123; &#125; 通配符和泛型方法大多时候，我们都可以使用泛型方法来代替通配符的….. 123456789//使用通配符public static void test(List&lt;?&gt; list) &#123;&#125;//使用泛型方法public &lt;T&gt; void test2(List&lt;T&gt; t) &#123; &#125; 原则： 如果参数之间的类型有依赖关系，或者返回值是与参数之间有依赖关系的。那么就使用泛型方法 如果没有依赖关系的，就使用通配符，通配符会灵活一些. 类型擦除类型擦除就是虚拟机对泛型其实一无所知，所有的工作都是编译器做的 我们编写的泛型类 1234567891011121314public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125; 虚拟机执行的代码： 1234567891011121314public class Pair &#123; private Object first; private Object last; public Pair(Object first, Object last) &#123; this.first = first; this.last = last; &#125; public Object getFirst() &#123; return first; &#125; public Object getLast() &#123; return last; &#125;&#125; 所以编译器干了2件事： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 我们使用泛型时 123Pair&lt;String&gt; p = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);String first = p.getFirst();String last = p.getLast(); 虚拟机的视角： 123Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;);String first = (String) p.getFirst();String last = (String) p.getLast(); 所以编译器真的牛批，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。 也因为这样，泛型的局限就出来 不能是基本数据类型 不能取得带泛型的class Pair&lt;String&gt; p1 = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;); Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456); Class c1 = p1.getClass(); Class c2 = p2.getClass(); System.out.println(c1==c2); // true System.out.println(c1==Pair.class); // truePair是一个泛型类 编译器把都看作是Object，我们对Pair&lt;String&gt;和Pair&lt;Integer&gt;类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。 换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair&lt;Object&gt;。 不能实例化类型 123456789public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair() &#123; // Compile error: first = new T(); last = new T(); &#125;&#125; ​ 因为擦除，first = new T()， last = new T()都变成了first = new Object(); last = new Object();那你创建new Pair()和new Pair()就都是Object，显然编译器不会让你这么干的 泛型的应用只写一个抽象DAO，别的DAO只要继承该抽象DAO，就有对应的方法了。 抽象DAO 1234567891011121314151617181920212223242526272829303132333435public abstract class BaseDao&lt;T&gt; &#123; //模拟hibernate.... private Session session; private Class clazz; //哪个子类调的这个方法，得到的class就是子类处理的类型（非常重要） public BaseDao()&#123; Class clazz = this.getClass(); //拿到的是子类 ParameterizedType pt = (ParameterizedType) clazz.getGenericSuperclass(); //BaseDao&lt;Category&gt; clazz = (Class) pt.getActualTypeArguments()[0]; System.out.println(clazz); &#125; public void add(T t)&#123; session.save(t); &#125; public T find(String id)&#123; return (T) session.get(clazz, id); &#125; public void update(T t)&#123; session.update(t); &#125; public void delete(String id)&#123; T t = (T) session.get(clazz, id); session.delete(t); &#125; &#125; 123public class CategoryDao extends BaseDao&lt;Category&gt; &#123;&#125; 1234public class BookDao extends BaseDao&lt;Book&gt; &#123;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习Spring的AOP之前，有必要对动态代理有所了解（本文全部参考最后的参考文章链接） 静态代理 为现有每个类编写一个对应的代理类，并且实现相同的接口 在代理对象中通过构造器塞入目标对象，实现相同方法并进行增强。这样，我们只需要代理对象，原对象可以不用了 缺点：每个类都需要一个代理，如果是成百上千的类，岂不是得要一堆代理类，系统臃肿。 动态代理对象创建原理 在创建实例对象之前会创建一个Class对象，而Class对象是Class类的实例，Class类是描述所有类的 所以如果我们能拿到代理Class对象，从而通过反射创建对象实例，不就可以不写代理类吗 Class对象 包含有类的全部信息，构造器，方法等，那我们怎么才能获取这些信息？ 接口，因为代理类和目标对象都实现了相同的接口，从接口那我们可以获取要的全部信息。问题又来了，接口不能 实例化，那怎么办？这就进入正题了 动态代理jdk提供了 java.lang.reflect.Proxy类和 java.lang.reflect.InnovationHandler接口来帮助我们 Proxy有个静态方法，proxy.getProxyClass(ClassLoader,interfaces)，通过传入类加载器和接口，返回Class对象 这个方法会从传入的接口Class，复制一份，并且加了个构造器，这样这个新的Class对象可以创建对象了。 一句话，proProxyClass()方法以Class对象造Class对象 在获得构造器后，通过反射创造代理实例 在创建Class对象时，需要传入InnocationHandler。在调用代理对象的方法时，会自动调用InnocationHandler的invoke方法 12Object invoke(Object proxy,Method method,Object[] args) 在代理实例上处理方法调用并返回结果 怎么调用呢？原理：如下图，代理对象中有一个成员变量专门接受构造器传来的引用，代理对象的每个方法都会调用handler.invoke()方法 InvocationHandler接收三个参数 proxy，代理后的实例对象。 method，对象被调用方法。 args，调用时的参数。 但是我们每次都是先new一个目标对象，然后去执行目标对象的方法，这样会带来一个问题：来一个目标对象就要new一个，这谁顶得住，所以一般我们使用以下写法 1234567891011121314IProducer proxyProducer=(IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //提供增强的代码 Object returnValue=null; //1.获取方法执行的参数 Float money=(Float)args[0]; //2.判断当前方法是不是销售 if (&quot;saleProduct&quot;.equals(method.getName()))&#123; returnValue=method.invoke(producer,money*0.8f); &#125; return returnValue; &#125;&#125;);proxyProducer.saleProduct(10000f); 总的流程 ​ 参考链接 https://www.zhihu.com/question/20794107/answer/658139129]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入]]></title>
    <url>%2F2019%2F09%2F16%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[依赖注入概念依赖注入(Dependency Injection)是spring框架核心ioc的具体实现. 通过控制反转,我们把创建对象托管给了spring,但是代码中不可能消除所有依赖,例如:业务层仍然会调用持久层的方法,因此业务层类中应包含持久化层的实现类对象.我们等待框架通过配置的方式将持久层对象传入业务层,而不是直接在代码中new某个具体的持久化层实现类,这种方式称为依赖注入. 注入方法使用构造函数注入&lt;constructor-arg&gt;用来定义构造函数的参数,其属性可大致分为两类 寻找要赋值的字段 index：指定参数在构造函数参数列表的索引位置 name：指定参数在构造函数中的数据类型 type：指定参数在构造函数中的变量名,最常用的属性 给字段赋值 value：给基本数据类型和String类型赋值 ref：给其它Bean类型的字段赋值 1234567891011121314151617public class AccountServiceImpl implements IAccountService &#123; //如果是经常变化的数据,并不适用于注入的方式 private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 123456789&lt;!-- 使用Date类的无参构造函数创建Date对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;myname&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- birthday字段为已经注册的bean对象,其id为now --&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 使用set注入在类中提供需要注入成员属性的set方法,创建对象只调用要赋值属性的set方法 &lt;property&gt;,用来定义要调用set方法的成员. 其主要属性可大致分为两类: 指定要调用set方法赋值的成员字段 name：要调用set方法赋值的成员字段 指定赋给字段的值 value：给基本数据类型和String类型赋值 ref：给其它Bean类型的字段赋值 123456789101112131415161718192021public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday); &#125;&#125; 123456789&lt;!-- 使用Date类的无参构造函数创建Date对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;myname&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;!-- birthday字段为已经注册的bean对象,其id为now --&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 集合注入集合字段及其对应的标签按照集合的结构分为两类： 只有键的结构: 数组字段：&lt;array&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 List字段：&lt;list&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 Set字段：&lt;set&gt;标签表示集合,&lt;value&gt;标签表示集合内的成员 其中&lt;array&gt;,&lt;list&gt;,&lt;set&gt;标签之间可以互相替换使用. 键值对的结构: Map字段： &lt;map&gt;标签表示集合,&lt;entry&gt;标签表示集合内的键值对,其key属性表示键,value属性表示值 Properties字段：&lt;props&gt;标签表示集合,&lt;prop&gt;标签表示键值对,其key属性表示键,标签内的内容表示值. 下面使用set方法注入各种集合字段 12345678910111213141516171819202122232425262728293031323334public class AccountServiceImpl implements IAccountService &#123; // 集合字段 private String[] myArray; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; // 集合字段的set方法 public void setMyStrs(String[] myArray) &#123; this.myArray = myArray; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myArray)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl3&quot;&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;array&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;value&gt;value1&lt;/value&gt; &lt;value&gt;value2&lt;/value&gt; &lt;value&gt;value3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot;&gt; &lt;value&gt;value2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;myProps&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;value1&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;value2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml实现IOC]]></title>
    <url>%2F2019%2F09%2F16%2Fxml%E5%AE%9E%E7%8E%B0IOC%2F</url>
    <content type="text"><![CDATA[使用XML配置文件实现IOC使用配置文件实现IOC,要将托管给spring的类写进bean.xml配置文件中. 简单实例 创建maven项目,配置其pom.xml 12345678&lt;dependencies&gt; &lt;!-- 引入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置bean: 在类的根路径下的resource目录下创建bean.xml文件,把对象的创建交给spring来管理.每个&lt;bean&gt;标签对应一个类,其class属性为该类的全类名,id属性为该类的id,在spring配置中,通过id获取类的对象 123456789&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--把对象的创建交给spring来管理--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 在表现层文件Client.java中通过容器创建对象.通过核心容器的getBean()方法获取具体对象. 1234567891011public class Client &#123; public static void main(String[] args) &#123; // 获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); // 根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;); // 执行as的具体方法 // ... &#125;&#125; 我们常用的容器有三种: ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件 AnnotationConfigApplicationContext：读取注解创建容器 bean标签 作用: 配置托管给spring的对象,默认情况下调用类的无参构造函数,若果没有无参构造函数则不能创建成功 属性： id: 指定对象在容器中的标识,将其作为参数传入getBean()方法可以获取获取对应对象. class: 指定类的全类名,默认情况下调用无参构造函数 scope: 指定对象的作用范围,可选值如下 init-method：指定类中的初始化方法名称,在对象创建成功之后执行 destroy-method：指定类中销毁方法名称 bean的作用范围和生命周期 单例对象: scope=”singleton” 作用范围: 每个应用只有一个该对象的实例,它的作用范围就是整个应用 生命周期: 单例对象的创建与销毁 和 容器的创建与销毁时机一致 对象出生: 当应用加载,创建容器时,对象就被创建 对象活着: 只要容器存在,对象一直活着 对象死亡: 当应用卸载,销毁容器时,对象就被销毁 多例对象: scope=&quot;prototype&quot; ​ 作用范围: 每次访问对象时,都会重新创建对象实例. ​ 生命周期: 多例对象的创建与销毁时机不受容器控制 ​ 对象出生: 当使用对象时,创建新的对象实例 ​ 对象活着: 只要对象在使用中,就一直活着 ​ 对象死亡: 当对象长时间不用时,被 java 的垃圾回收器回收了 实例化bean的三种方式 使用默认无参构造函数创建对象: 默认情况下会根据默认无参构造函数来创建类对象 12&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt; 使用静态工厂的方法创建对象 1234&lt;bean id=&quot;accountService&quot; class=&quot;cn.maoritian.factory.StaticFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; 使用实例工厂的方法创建对象 123456&lt;bean id=&quot;instancFactory&quot; class=&quot;cn.maoritian.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring概念]]></title>
    <url>%2F2019%2F09%2F16%2Fspring%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[spring学习IOC的概念及作用程序的耦合和解耦耦合性：对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调 用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差。 解决程序耦合的思路以jdbc为例，是通过反射来注册驱动的，即Class.forName(“com.mysql.jdbc.Driver”） 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar包，依然可以编译。同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。解决这个问题就要使用配置文件配置。 工厂模式解耦可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 控制反转-Inversion Of Control由于我们是很多对象，肯定要找个集合来存。在应用加载时，创建一个 Map，用于存放三层对象。 我们把这个 map 称之为容器。工厂就是负责给我们从容器中获取指定对象的类。 我们在获取对象时，都是采用 new 的方式，是主动的，如下图 现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象，是被动的。 IOC：将创建对象的权力交给框架，可以削减代码间的依赖。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化序列化和反序列化的概念序列化：把对象转换成字节序列的过程 反序列化：把字节序列转换成对象的过程 什么时候使用序列化 对象序列化可以实现分布式对象。主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制“，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 序列化可以将内存中的类写入文件或数据库中。比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。 对象、文件、数据，有许多不同的格式，很难统一传输和保存。序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件 （上面也就存储在文件上用过，其余的没试过，参考的网上不错的总结，以后用到再补充） 主要用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中 在网络上传送对象的字节序列（当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象） 点进Serializable接口看一下 一个问题点进Serializable接口看一下 里面啥都没有，它是一个空接口，仅仅是一个标识，用来告诉jvm进行序列化，真正的序列化操作不是由他来完成的 demo123456789101112131415161718192021public class person implements Serializable &#123; private static final long serialVersionUID = 1L； private String name; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) throws Exception &#123; Serialization(); person per3=DestroySerialization(); System.out.println(per3.toString()); &#125; private static void Serialization() throws IOException &#123; person per1=new person(); per1.setName(&quot;小李&quot;); per1.setAge(&quot;19&quot;); ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream(new File(&quot;d:/flyPig.txt&quot;))); os.writeObject(per1); System.out.println(&quot;序列化成功&quot;); os.close(); &#125; private static person DestroySerialization() throws Exception&#123; ObjectInputStream is=new ObjectInputStream(new FileInputStream(new File(&quot;d:/flyPig.txt&quot;))); person per2=(person) is.readObject(); System.out.println(&quot;反序列化成功&quot;); return per2; &#125;&#125; 运行结果： transient和static修饰的变量不会被序列化 关于serialversionUID变量如果自己没有声明一个serialVersionUID变量，默认会自动生成一个serialVersionUID，但是推荐自己写一个，因为默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常。 serialVersionUID作用：用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialVersionUID与当前类当中的serialVersionUID一致，那么该对象才能被反序列化成功。 serialVersionUID的工作机制： 序列化时serialVersionUID会被写入到序列化的文件中去 反序列化时JVM会把传来的字节流中的serialVersionUID于本地相应实体类的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常。 参考文档 https://www.jianshu.com/p/664ef87f5fdb https://baijiahao.baidu.com/s?id=1633305649182361563&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2019%2F09%2F09%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final关键字final关键字基本用法 final修饰类 当一个类用final修饰时，这个类就不能被继承了。所以在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。 final修饰方法 如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的 final修饰变量 final成员变量表示常量，只能被赋值一次，赋值后值不再改变 先来个很常见的题目引入 1234567891011public class Test &#123; public static void main(String[] args) &#123; String a = &quot;hello2&quot;; final String b = &quot;hello&quot;; String d = &quot;hello&quot;; String c = b + 2; String e = d + 2; System.out.println((a == c)); System.out.println((a == e)); &#125; &#125; ​ 分析：final变量是基本数据类型以及String类型时 ，如果在编译器就知道其确切值，编译器就会把它当作常量来看，所以b会直接以hello来替代。常量字符串的“+”操作，编译阶段直接会合成为一个字符串。在编译期间，这种拼接会被优化，编译器直接帮你拼好 ，如string str=”ja”+”va”，在编译阶段会直接合并成语句String str=”java”，于是会去常量池中查找是否存在”java” ，从而进行创建或引用，这里的c即为“hello”+2，也就是“hello2”，所以a和c指向的是同一个hello2，而a和e则是不同对象，为什么呢，一开始我也不知道，在查阅相关博客后，对常量池等知识有了了解，下面对String创建的变量进行详细解析。 new String都是在堆上创建字符串对象。 其实这里常量池中也会有一个“abcd”的字符串，当new时，会拷贝一份该字符串存放到堆中，于是y指向了堆中的那个“abcd”字符串 。 1234567String s = new String(&quot;abc&quot;);String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); System.out.println(s == s1);System.out.println(s == s2);System.out.println(s1 == s2); 这里在详细分析以下这两行代码： 首先在常量池中创建abc对象，然后new关键字会在堆里再创建一个对象，在堆里的这个对象则是在栈中的s1所指向的 当轮到s2时，首先同样会在常量池中看有没有abc，这里已经有了，则不用自己创建。然后new自己创建一个在堆中的对象，s2指向这个对象 所以虽然s1和s2指向的最终内容都是abc，但它们是2个不同的对象，因为指向的是不同堆对象 通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。 再来个经典例子： 12345678910111213141516 1 String s1 = &quot;Hello&quot;; 2 String s2 = &quot;Hello&quot;; 3 String s3 = &quot;Hel&quot; + &quot;lo&quot;; 4 String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;); 5 String s5 = new String(&quot;Hello&quot;); 6 String s6 = s5.intern(); 7 String s7 = &quot;H&quot;; 8 String s8 = &quot;ello&quot;; 9 String s9 = s7 + s8;10 11 System.out.println(s1 == s2); // true12 System.out.println(s1 == s3); // true13 System.out.println(s1 == s4); // false14 System.out.println(s1 == s9); // false15 System.out.println(s4 == s5); // false16 System.out.println(s1 == s6); // true s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。 s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。 s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同 s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同 s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。 s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。 注意：只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中 常量池 Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 ​ 所谓静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：*字面量(Literal)和符号引用量**(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名 字段名称和描述符 方法名称和描述符 ​ 而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 常量池的好处 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。 （1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。 （2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 参考博客：https://www.cnblogs.com/lizhangyong/p/8909329.html ​ https://www.cnblogs.com/xiaoxi/p/6392154.html]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request,response]]></title>
    <url>%2F2019%2F09%2F08%2Fresponse%2F</url>
    <content type="text"><![CDATA[requestRequest 对象是一个专门用来存储HTTP 请求信息的对象 request对象的由来 浏览器发送的http请求纪要存储又要保证完整性，Servlet的解决方案就是创建一个对象进行存储，每接受一个请求，服务器就要创建一个对象进行存储 request对象中存储请求信息，服务器调用servlet时将request对象作为参数传给Servlet方法 request功能 获取请求头数据 getMethod():获取请求方式 [GET,POST或PUT] getRequestURL():获取请求路径 12System.out.println(req.getMethod()); //GET System.out.println(req.getRequestURL()); //http://localhost:8089/servlet/update 获取请求体数据 java.lang.String getHeader(java.lang.String name): 以a形式返回指定请求标头的值String。 java.util.Enumeration getHeaderNames():返回此请求包含的所有标头名称的枚举。 java.util.Enumeration getHeaders(java.lang.String name):返回指定请求头作为的所有值Enumeration的String对象。 123456789101112131415 Enumeration enums = request.getHeaderNames(); while (enums.hasMoreElements())&#123; System.out.println(enums.nextElement()); &#125; /* host:localhost:8089 connection:keep-alive upgrade-insecure-requests:1 user-agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 accept-encoding:gzip, deflate, br accept-language:zh-CN,zh;q=0.9,en;q=0.8 cookie:JSESSIONID=F054B1A83D51D3320C177469DC567048; Webstorm-66e715af=5d7e1fa0-a9e9-4c01-9c16-aaff75cf10f7*/ 获取用户信息 getMethod():获取请求方式 [GET,POST或PUT] getRequestURL():获取请求路径 response 请求消息：客户端发送给服务器的数据 数据格式： 请求行 请求头 请求空行 请求体 响应消息服务器端发给客户端的数据 响应行 响应头 响应空行 响应体 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 状态码都是3位数字 分类： 1xx：服务器接受客户端信息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功 3xx：重定向 代表:304 重定向 客户端向服务器请求a，服务器a说在c那，告诉客户端，客户端再去请求服务器c ![](https://xjhpic-1259639342.cos.ap-chengdu.myqcloud.com/response.png) 304 访问缓存：浏览器a向服务器请求a.png,服务器给，并在本地有缓存，当第二次请求时，服务器对浏览器回应304去访问自己的缓存。 4. 4xx：客户端错误。代表：404 （请求路径不对） 1. 404：路径没有对应资源 2. 405：请求方式没有对应的doxx方法 5. 5xx：服务器错误 响应头 格式：头名称：值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-Type：服务器告诉客户端义什么格式打开响应体数据 in-line：默认值在当前页面内打开 attachment：以附件形式打开响应体.文件下载 响应体：传输的数据 response功能 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name，String value) 设置响应体： 获取输出流 字符输出流：PrintWriter getwriter（） 字节输出流：ServletOutputStream getOutOutputStream() 使用输出流：将数据输出到客户端 案例 完成重定向 重定向：资源跳转的方式 代码实现 12response.setStatus(302);response.setHeader(&quot;location&quot;, &quot;/demo/responsedemo2&quot;); 1response.sendRedirect(&quot;/demo/responsedemo2&quot;); 转发特点： 1.转发地址路径不变 2.转发只能访问当前服务器下的资源 3.转发是一次请求，可以使用request对象来共享数据 重定向特点： 1.地址栏发生变化 2.重定向可以访问其他站点（服务器）的资源 3.重定向是2次请求，不能使用request对象来共享数据 foward和redirect区别 路径写法： 相对路径：通过相对路径不可以确定唯一资源 ./index.html不以/开头，以.开头 找到当前与目标资源之间的相对位置关系 ./:当前目录 ../：后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 判断定义的路径给谁用 给客户端用，需要加虚拟目录 给服务器用：不需要加 2.服务器输出字符数据到浏览器 ​ 步骤：1.获取字符数据 ​ 2.输出数据 ​ 注意乱码问题：PrintWriter pw=response.getWriter();默认编码方式是ISO-8859-1 Writer类的常用方法 void write(int n)：写入单个字符 void write(byte b[])：写入一个字符数组 void write(byte b[],int off,int len)：从字节数组中起始于偏移量off处取len个字符 123456//告诉浏览器服务器的编码方式，建议浏览器使用该编码解码（浏览器默认gbk）response.setHeader(&quot;content-type&quot;,&quot;text/html;charset= utf-8&quot;);//获取字符数据PrintWriter pw=response.getWriter();//输出数据pw.write(&quot;你好啊&quot;); 3.输出字节数据到浏览器（一般输出图片） ServletOutputStream类提供了将二进制数据写入响应的流 getBytes()返回默认编码的字节数组 OutputStream类的常用方法 void write(int n)：写入单个字节 void write(byte b[])：写入一个字节数组 void write(byte b[],int off,int len)：从字节数组中起始于偏移量off处取len个字节 1234//获取字符数据ServletOutputStream pw=response.getOutputStream();//输出数据pw.write(&quot;你好&quot;.getBytes());]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器作用： 对服务器接受的资源和响应给浏览器的资源进行管理 保护servlet 使用： 创建一个实现Filter接口的普通java类 覆写接口的方法 init方法：服务器启动即执行，资源初始化 doFilter方法：拦截请求，在此方法中对资源实现管理 要手动对资源放行：chain.doFilter(request,response) destroy方法：服务器关闭 在web.xml配置过滤器（是服务器在使用过滤器） ​ url-patten：/*表示拦截所有请求。 ​ url-patten：*.do 表示所有以.do结尾的请求。一般用来进行模块拦截。 ​ url-patten：/ts 表示拦截指定url的请求，针对某个servlet拦截，保护servlet 过滤器生命周期：服务器启动到关闭。 总结：过滤器程序员声明和配置，服务器根据请求中的url信息调用。 执行机制：浏览器发起请求到服务器，服务器接到请求后，根据url在web.xml中找到对应的过滤器执行doFilter方法，该方法对此次请求进行处理后如果符合则放行，放行后还有其他符合要求的进行过滤，找到执行对应的servlet进行处理。servlet对请求处理完毕后，service方法结束。还需继续返回相应的doFilter检修执行 案例：统一编码格式设置 ​ session管理 ​ 权限管理 ​ 资源管理 123456789101112131415161718/* * 在过滤器类前使用@WebFilter()注释 * filterName:名称 * urlPatterns:过滤器作用url地址 * initParams:初始化参数，以WebInitParam()形式存入 * */@WebFilter(filterName = &quot;filterusers&quot;,urlPatterns =&quot;/demo/*&quot;, initParams =&#123;@WebInitParam(name=&quot;ip&quot;,value = &quot;192.168.*.*&quot;)&#125; )public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); if (session.getAttribute(&quot;user&quot;)==null) &#123; response.sendRedirect(); &#125; else //放行 filterChain.doFilter(request,response);]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session]]></title>
    <url>%2F2019%2F09%2F08%2FSession%2F</url>
    <content type="text"><![CDATA[SessionSession是另一种记录浏览器状态的机制，Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务把用户的信息，以某种形式记录在服务器，这就是Session 问题：一个用户的不同请求处理的数据共享怎么办 解决：Session 原理：用户第一次访问服务器，服务器会创建一个Session对象给用户，并将该session对象的JESSIONID使用Cookie技术存储到浏览器中，保证用户的其他请求能够获取到同一个session对象，也保证不同请求能够共享数据 12345678910111213141516171819202122232425Request URL: http://localhost:8089/loginRequest Method: POSTStatus Code: 200 Remote Address: [::1]:8089Referrer Policy: no-referrer-when-downgradeContent-Length: 57Content-Type: text/html;charset=UTF-8Date: Mon, 26 Nov 2018 01:11:19 GMTSet-Cookie: UserName=3444444444444444Set-Cookie: UserPassword=23423424Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Connection: keep-aliveContent-Length: 40Content-Type: application/x-www-form-urlencodedCookie: Webstorm-66e715af=5d7e1fa0-a9e9-4c01-9c16-aaff75cf10f7; JSESSIONID=2AF4A84C2F8FC452F54C77D3092B2E1B; UserName=3444444444444444; UserPassword=23423424Host: localhost:8089Origin: http://localhost:8089Referer: http://localhost:8089/Login.jspUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/69.0.3497.100 Safari/537.36 特点： 存储在服务器 服务器进行创建 依赖Cookie技术 一次会话 默认存储时间30分钟 使用： 创建session对象/获取session对象 HttpSession hs=request.getSession() 这么理解：如果创建了session，那么在浏览器中会有JSESSIONID，那么就会返回session对象 如果没有创建，那么新建一个 设置session存储时间 hs.invalidate( ) 存储数据 hs.setAttribute(String name,Object value) 获取数据 hs.getAttribute(String name) 使用情景：用户登陆时将用户信息存入session中，供该用户的其他请求使用 注意：*JESSIONID是在浏览器中，关闭浏览器就没得了 ​ *存储和获取是在不同请求，即http://aa http://bb这样不同请求，但存储要先于获取 作用域：一次会话（即可以多次请求，主要session没失效） 代码示例 1234567891011protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); //获取请求信息 String name=&quot;张三&quot;; //处理消息 //创建session对象 HttpSession ps=request.getSession(); System.out.println(ps.getId()); ps.setAttribute(&quot;name&quot;,name);&#125; 12345678response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);//获取请求信息String name=&quot;张三&quot;;//处理消息//创建session对象HttpSession ps=request.getSession();System.out.println(&quot;session2&quot;+ps.getId());System.out.println(&quot;session2&quot;+ps.getAttribute(&quot;name&quot;)); session1存数据，session2读数据，但是是一个用户]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie]]></title>
    <url>%2F2019%2F09%2F08%2FCookie%2F</url>
    <content type="text"><![CDATA[Cookie设置CookieCookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息 。简单例子就是淘宝等账户几天内不用重复登陆。 识别返回用户包括三个步骤： 服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上，以备将来使用。 当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户 这里给一个Cookie响应头例子，来自于菜鸟 1234567HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=runoob.comConnection: closeContent-Type: text/html Set-Cookie中包含了键值对、一个 GMT 日期、一个路径和一个域 。在到期之后浏览器便会”忘记”Cookie。expire翻译有去世的意思，补充英语单词，哈哈。 特点： 这是浏览器端的数据存储技术 数据声明是在服务器 2种存储 临时存储：数据存储在浏览器运行内存中，关了就没了 ​ 定时存储：到期之后才会没得 使用： 创建一个Cookie对象，cookie 名称和 cookie 值都是字符串 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 设置最大生命周期（以秒为单位） 1cookie.setMaxAge(60*60*24); 发送Cookie到HTTP响应头 1response.addCookie(cookie); 代码示例 123456Cookie cookie=new Cookie(&quot;name&quot;,request.getParameter(&quot;name&quot;));Cookie url=new Cookie(&quot;url&quot;,request.getParameter(&quot;url&quot;));cookie.setMaxAge(60*60*24);url.setMaxAge(60*60*24);response.addCookie(cookie);response.addCookie(url);]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java装箱与拆箱]]></title>
    <url>%2F2019%2F09%2F05%2Fjava%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[包装类：基本数据类型使用方便，但没有对应方法来操作这些数据，因而使用一个类，在类中定义操作数据的方法，这些类叫做包装类 简单来说，java装箱就是基本数据类型转换成包装类类型，拆箱就是包装类类型转换成基本数据类型 对应关系如下 基本数据类型 包装类 byte Byte boolean Boolean short Short int Integer float Float double Double char Character 装箱与拆箱静态方法 1234//返回保存指定int的值的Integer对象Integer in1=Integer.valueof(1);//返回保存指定String的值的Integer对象Integer in2=Integer.valueof(&quot;1&quot;); 看一下Interger.valueof源码： 1231 public static Integer valueOf(int i) &#123;2 return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];3 &#125; 它会首先判断i的大小：如果i小于-128或者大于等于128，就创建一个Integer对象，否则执行SMALL_VALUES[i + 128] 。注意这里i如果小于-128或者大于等于128，就会创建不同对象，而处于中间的都会创建同一个对象。 总结来说装箱即valueof( )方法就是会返回Interger类型的对象 Interger构造函数 123Integer in1=new Integer(1);//这里只能是基本类型的字符串Integer in1=new Integer(&quot;1&quot;); 源码 1234567891 private final int value;2 3 public Integer(int value) &#123;4 this.value = value;5 &#125;6 //这里的String必须是基本类型的字符串，100可以，a就不行7 public Integer(String string) throws NumberFormatException &#123;8 this(parseInt(string));9 &#125; 下面看看SMALL_VALUES[i + 128]是什么东西： 11 private static final Integer[] SMALL_VALUES = new Integer[256]; 拆箱的intvalue( )源码 接着看看intValue函数,就是返回value值 12341 @Override2 public int intValue() &#123;3 return value;4 &#125; 自动装箱与拆箱123451 //自动装箱2 Integer total = 99;3 4 //自定拆箱5 int totalprim = total; 自动装箱：直接把int类型的整数赋值包装类 自动拆箱：包装类无法直接参与运算，可以自动转换为基本数据类型 123Interger total=99实际上执行了Interger total =Interger.valueof(99);int totalprim = total 实际上执行了int totalprim =total.intvalue( ); 装箱拆箱作用 将基本数据类型放入集合类中 12list.add(1);//自动装箱list.add(new Integer(1));list.get(1);//自动拆箱list.get(0).intvalue(); 包装类型和基本数据类型比较 包装类型运算 1234Integer i = 10;Integer j = 20; System.out.println(i+j); (i+j)即为(Interger.invalue(i)+interger.invalue(j)) 最后给出一道面试题 12345678910111213141516public void testAutoBox2() &#123; //1 int a = 100; Integer b = 100; System.out.println(a == b); //2 Integer c = 100; Integer d = 100; System.out.println(c == d); //3 c = 200; d = 200; System.out.println(c == d);&#125; 结果为 True True false 原因就是100 200值的不同，见上所述。 当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象 。 （缓存部分就不详细说了，本人还没看，哈哈） 字符串和基本类型的相互转换基本类型-&gt;字符串 基本类型的值+” “ 包装类的静态方法toString(参数)，不是Object类的toString() String类的静态方法valueof(参数) 123456789int i1=100;String s1=i1+&quot;&quot;;System.out.println(s1+200);//100200这里是字符串的加String s2=Integer.toString(100);System.out.println(s2+200);String s3=String.valueOf(100);System.out.println(s3+200); 字符串-&gt;基本类型 使用包装类的静态方法parsexxx(“字符串”)； ​ Integer类：static int parseInt(String s) ​ Double类：static double parseDouble(String s) 12int i=Integer.parseInt(s1);System.out.println(i);]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex]]></title>
    <url>%2F2019%2F09%2F04%2FLaTex%2F</url>
    <content type="text"><![CDATA[LaTex[TOC] LaTex预备知识第一个LaTex文档123456\documentclass&#123;article&#125; \begin&#123;document&#125;First document. This is a simple example, with no extra parameters or packages included.\end&#123;document&#125; 第一行说明文档类型，在\begin{document} \end{document}标签之间编写文档的文本。 article 排版科技期刊、短报告、程序文档、邀请函等。 report 排版多章节的长报告、短篇的书籍、博士论文等。 book 排版书籍。 slides 排版幻灯片。 序言123456\documentclass[12pt, letterpaper]&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125; \title&#123;First document&#125;\author&#123;Hubert Farnsworth \thanks&#123;funded by the ShareLaTeX team&#125;&#125;\date&#123;February 2014&#125; 在\begin{document}命令之前输入的文本称为前导码。在序言中，您可以定义要编写的文档类型和语言，加载您需要的额外包，并设置几个参数 。 下面对各部分进行说明： \documentclass[12pt, letterpaper]{article} ：在示例中，额外参数设置字体大小（12pt）和纸张大小（letterpaper）。默认大小为10pt。纸张尺寸默认为A4 \usepackage[utf8]{inputenc} ：如果不是特别需要其他编码，将此行添加到前导码中 接下来的三行是自我描述的 。如果要让标题显示，可以通过\maketitle来达到 斜体 粗体 下划线斜体：\textit{ } 粗体：\textbf{ } 下划线：\underline{ } 换行 分页 水平空格 垂直空格换行(新的一行会顶格开始) \\ \newline \hfile \break 分页 \newpage：在图片插入后换页，即图片依然可以正常显示，文本换页 \clearpage：在图片显示前换页，即图片和文本也会换页 水平空格 \hspace{ }：填指定长度空白 \hfill：填空白到行最后 垂直空格 \vspace{ }：填指定长度空白 \vfill：填空白到页面底部 段落新段落 空一行 段末 \par 1234This is the text in first paragraph. This is the text in first paragraph. This is the text in first paragraph. \parThis is the text in second paragraph. This is the text in second paragraph. This is the text in second paragraph. 居中 左对齐 右对齐左对齐示例 1234567\begin&#123;flushleft&#125;``LaTeX is a document preparation system and document markup language. LaTeX uses the TeX typesetting program for formatting its output, and is itself written in the TeX macro language. LaTeX is not the name of a particular editing program, but refers to the encoding or tagging conventions that are used in LaTeX documents&quot;.\end&#123;flushleft&#125; 图片插入图片 Latex无法自行管理图像，因此我们需要使用graphicx包 \usepackage{graphicx} \graphicspath{ {./images/} } \includegraphics{universe} universe为图片名 图片大小和旋转1\ includegraphics [ width = 3cm，height = 4cm ] &#123;lion-logo &#125; 长宽 1\ includegraphics [ width = \ textwidth ] &#123;universe &#125; 图片和文本等宽 1\ includegraphics [ scale = 1.2，angle = 45 ] &#123;lion-logo &#125; 缩放并旋转 1234567\begin&#123;document&#125; Overleaf is a great professional tool to edit online, share and backup your \LaTeX&#123;&#125; projects. Also offers a rather large help documentation. \includegraphics[scale=1.2, angle=45]&#123;lion-logo&#125; 123456\begin&#123;document&#125; The universe is immense and it seems to be homogeneous, in a large scale, everywhere we look at. \includegraphics[width=\textwidth]&#123;universe&#125; 图片与文字的组合123456In the next example the figure will be positioned right below this sentence. \begin&#123;figure&#125;[h]\includegraphics[width=8cm]&#123;Plot&#125;\end&#123;figure&#125; 该figure环境用于将图片显示为文档中的浮动元素 ，LaTex会自动对图片进行定位 h 正常位置 T 位于页面顶部 b 位于页面底部 文本包裹图片，适合图片较小的情况下 12345678910111213141516171819202122232425262728293031\begin&#123;wrapfigure&#125;&#123;r&#125;&#123;0.25\textwidth&#125; %this figure will be at the right \centering \includegraphics[width=0.25\textwidth]&#123;mesh&#125;\end&#123;wrapfigure&#125; There are several ways to plot a function of two variables, depending on the information you are interested in. For instance, if you want to see the mesh of a function so it easier to see the derivative you can use a plot like the one on the left. \begin&#123;wrapfigure&#125;&#123;l&#125;&#123;0.25\textwidth&#125; \centering \includegraphics[width=0.25\textwidth]&#123;contour&#125;\end&#123;wrapfigure&#125; On the other side, if you are only interested oncertain values you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, like the one on the left. On the other side, if you are only interested on certain values you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, you can use the contour plot, like the one on the left. 要实现如下图效果，需要先导入包wrapfig，即 \usepackage{wrapfig} 通过命令定义wrapfigure环境\begin{wrapfigure}{l}{0.25\textwidth} \end{wrapfigure} \centering 将使图片居中 {l}：定义图片的对齐方式 {0.25\textwidth}：图片相对于文本的宽度 效果图 数学表达式数学表达式的写入模式有2种：inline mode ，display mode 。第一个用于编写作为文本一部分的公式。第二个用于编写不属于文本或段落的表达式 。 inline mode(行内模式)：用这些分隔符之一：\( \)，$ $或\begin{math} \end{math} display mode (行内模式）：\[ \], $$ $$, \begin{displaymath} \end{displaymath} or \begin{equation} \end{equation} 有编号 \begin{equation} \end{equation} (没试过) 无编号 章节\section{}标记新部分的开头，在括号内设置标题，部分编号是自动的，可以禁用 。在左大括号前添加*即可去掉编号 1234567891011121314\section&#123;Introduction&#125; This is the first section. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam lobortisfacilisis sem. Nullam nec mi et neque pharetra sollicitudin. Praesent imperdietmi nec ante. Donec ullamcorper, felis non sodales... \section&#123;Second Section&#125; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam lobortis facilisissem. Nullam nec mi et neque pharetra sollicitudin. Praesent imperdiet mi necante... ​ 页眉和页脚同时有很多样式，这里用本人喜欢的风格 \usepackage{fancyhdr} 导入包 \fancyhf 清除页眉和页脚，否则将出现默认“普通”页面样式的元素。 \rhead{ } 右上角页眉 \lhead{ } 左上角页眉 \rfoot{ } 页脚 { }内推荐写 \thepage这样可以自动写入页数 12345678910111213141516\documentclass&#123;article&#125;\usepackage[english]&#123;babel&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage&#123;fancyhdr&#125;\pagestyle&#123;fancy&#125;\fancyhf&#123;&#125;\rhead&#123;Overleaf&#125;\lhead&#123;\LaTeX&#123;&#125; tutorials&#125;\rfoot&#123; \thepage&#125;\begin&#123;document&#125;\section&#123;First Section&#125;\end&#123;document&#125; 参考文献overleaf上有多种参考文献格式，这里使用常见的方式，详细步骤如下： 新建.bib文件，里面存放引用文献的信息 在谷歌学术或百度学术中找到相应文献的 “ 引用 ”功能，然后在导入链接那点击 “ BibTex ”。复制其中的内容至新建立的.bib文件 相关命令 \usepackage{biblatex} 导入包biblatex。 \addbibresource{sample.bib} 导入bibtex数据文件sample.bib，此文件包含有关每个引用的书籍，文章等信息。 \cite{einstein} 此命令在文档中插入引用[1]，在这种情况下，对应于参考书目中的元素，“einstein”是对应于sample.bib中的条目的关键字。 \printbibliography` 打印引用的参考文献列表，默认标题是文章文档类的“参考文献”和书籍和报告的“参考书目”。 1234567891011121314\documentclass&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage[english]&#123;babel&#125; \usepackage&#123;biblatex&#125;\addbibresource&#123;sample.bib&#125; \begin&#123;document&#125;Let&apos;s cite! The Einstein&apos;s journal paper \cite&#123;einstein&#125; and the Dirac&apos;s book \cite&#123;dirac&#125; are physics related items. \printbibliography \end&#123;document&#125;]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker学习（1）]]></title>
    <url>%2F2019%2F07%2F17%2Fdocker1%2F</url>
    <content type="text"><![CDATA[docker学习（1）最近在学docker相关的东西，正好写几篇博客巩记录下。 docker背景一款产品从开发到上线，从操作系统，到运行环境，再到应用配置 。因而当从一台电脑部署到另一台电脑时，环境配置会很麻烦，什么都要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 docker三要素用一张总的架构图来有一个直观的了解。Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 镜像（docker images）Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 容器（container）Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例 。一个镜像可以创建多个容器。 仓库（registery）仓库（Repository）是集中存放镜像文件的场所。 例如dockerhub就是最大的docker仓库。 docker优点docker优点简洁来说就是：“一次封装，多出运行”。用户只要配置好了环境，换到别的电脑上直接部署就完事了，很方便。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[奶奶级next主题的美化教学动态背景的设置执行git clone https://github.com/theme-next/theme-next-three 进入主题的config.yml文件修改three:,enable: true，(可以选择的),例如canvas_nest等，进入_config.yml文件可以看上面的说明，会告诉你需要的依赖，clone下来，设为true即可，当然空格问题要注意哦。 最后hexo clean hexo g hexo s三部曲一下 配置daovoice在线聊天功能进入daovoice官网，注册注册成功后，进入后台控制台，进入到 应用设置--&gt;安装到网站 页面，可以得到一个 app_id 进入themes/next/layout/_partials/head.swig 文件中添加如下代码，位置随意：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件 _config.yml，添加如下代码 : 123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 注意：添加成功后的图标可能和以后加入的例如比例图标重合，此时可以到聊天设置，修改下按钮的位置: 2.3进入themes/next/layout/_partials/head.swig 文件中添加如下代码，位置随意：]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next第一篇教学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
